<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>6-methods-and-functions</title>
  <style>
    html {
      font-size: 12pt;
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      overflow-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 12px;
      }
      h1 {
        font-size: 1.8em;
      }
    }
    @media print {
      html {
        background-color: white;
      }
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, Consolas, 'Lucida Console', monospace;
      font-size: 85%;
      margin: 0;
      hyphens: manual;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
      overflow-wrap: normal;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      background-color: #1a1a1a;
      border: none;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC ul {
      padding-left: 1.3em;
    }
    #TOC > ul {
      padding-left: 0;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
    /* CSS for syntax highlighting */
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    .sourceCode { overflow: visible; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {   }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ff0000; font-weight: bold; } /* Alert */
    code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #7d9029; } /* Attribute */
    code span.bn { color: #40a070; } /* BaseN */
    code span.bu { color: #008000; } /* BuiltIn */
    code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4070a0; } /* Char */
    code span.cn { color: #880000; } /* Constant */
    code span.co { color: #60a0b0; font-style: italic; } /* Comment */
    code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #ba2121; font-style: italic; } /* Documentation */
    code span.dt { color: #902000; } /* DataType */
    code span.dv { color: #40a070; } /* DecVal */
    code span.er { color: #ff0000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #40a070; } /* Float */
    code span.fu { color: #06287e; } /* Function */
    code span.im { color: #008000; font-weight: bold; } /* Import */
    code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #007020; font-weight: bold; } /* Keyword */
    code span.op { color: #666666; } /* Operator */
    code span.ot { color: #007020; } /* Other */
    code span.pp { color: #bc7a00; } /* Preprocessor */
    code span.sc { color: #4070a0; } /* SpecialChar */
    code span.ss { color: #bb6688; } /* SpecialString */
    code span.st { color: #4070a0; } /* String */
    code span.va { color: #19177c; } /* Variable */
    code span.vs { color: #4070a0; } /* VerbatimString */
    code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  \usepackage{listings}
  \usepackage{xcolor}

  \lstset{
      basicstyle=\ttfamily,
      backgroundcolor=\color{black!10},
      showspaces=false,
      showstringspaces=false,
      showtabs=false,
      tabsize=2,
      captionpos=b,
      breaklines=true,
      breakautoindent=true,
      linewidth=\textwidth
  }
</head>
<body>
<nav id="TOC" role="doc-toc">
<ul>
<li><a href="#methods" id="toc-methods">Methods</a>
<ul>
<li><a href="#overloading" id="toc-overloading">Overloading</a></li>
<li><a href="#invocation" id="toc-invocation">Invocation</a></li>
<li><a href="#returning" id="toc-returning">Returning</a></li>
<li><a href="#arguments" id="toc-arguments">Arguments</a></li>
</ul></li>
</ul>
</nav>
<h2 id="methods">Methods</h2>
<h3 id="overloading">Overloading</h3>
<p>Method overloading is also called
<code>compile time polymorphism</code>, this is so because we define the
methods and their behavior at compile time (for the most part that is
mostly true). These methods must have the same name, but they may not
share the same type or/and number of arguments, the return type can be
the same. The idea is that at runtime the compiler will choose the
correct implementation of the overloaded method, and invoke that
one.</p>
<div class="sourceCode" id="cb1"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> OverloadDemo <span class="op">{</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> <span class="fu">test</span><span class="op">()</span> <span class="op">{</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>        <span class="bu">System</span><span class="op">.</span><span class="fu">out</span><span class="op">.</span><span class="fu">println</span><span class="op">(</span><span class="st">&quot;No parameters&quot;</span><span class="op">);</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> <span class="fu">test</span><span class="op">(</span><span class="dt">int</span> a<span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>        <span class="bu">System</span><span class="op">.</span><span class="fu">out</span><span class="op">.</span><span class="fu">println</span><span class="op">(</span><span class="st">&quot;a: &quot;</span> <span class="op">+</span> a<span class="op">);</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> <span class="fu">test</span><span class="op">(</span><span class="dt">int</span> a<span class="op">,</span> <span class="dt">int</span> b<span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>        <span class="bu">System</span><span class="op">.</span><span class="fu">out</span><span class="op">.</span><span class="fu">println</span><span class="op">(</span><span class="st">&quot;a and b: &quot;</span> <span class="op">+</span> a <span class="op">+</span> <span class="st">&quot; &quot;</span> <span class="op">+</span> b<span class="op">);</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>    <span class="dt">double</span> <span class="fu">test</span><span class="op">(</span><span class="dt">double</span> a<span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>        <span class="bu">System</span><span class="op">.</span><span class="fu">out</span><span class="op">.</span><span class="fu">println</span><span class="op">(</span><span class="st">&quot;double a: &quot;</span> <span class="op">+</span> a<span class="op">);</span></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> a<span class="op">*</span>a<span class="op">;</span></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Below is an example of how we may call the overloaded methods, which
at runtime will be routed to the correct implementation of the method
<code>test</code></p>
<div class="sourceCode" id="cb2"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>OverloadDemo ob <span class="op">=</span> <span class="kw">new</span> <span class="fu">OverloadDemo</span><span class="op">();</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>ob<span class="op">.</span><span class="fu">test</span><span class="op">();</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>ob<span class="op">.</span><span class="fu">test</span><span class="op">(</span><span class="dv">10</span><span class="op">);</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>ob<span class="op">.</span><span class="fu">test</span><span class="op">(</span><span class="dv">10</span><span class="op">,</span> <span class="dv">20</span><span class="op">);</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>ob<span class="op">.</span><span class="fu">test</span><span class="op">(</span><span class="fl">123.25</span><span class="op">);</span></span></code></pre></div>
<p>Note that there are <code>caveats</code>, from the implementation
above we can see that, we are correctly calling the test method, without
parameters, with one int or two int parameters or one double. However
what would happen if we instead called the test method with two double
paramters, or with a float one.</p>
<div class="sourceCode" id="cb3"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>OverloadDemo ob <span class="op">=</span> <span class="kw">new</span> <span class="fu">OverloadDemo</span><span class="op">();</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>ob<span class="op">.</span><span class="fu">test</span><span class="op">(</span><span class="fl">10.0</span><span class="op">,</span> <span class="fl">20.0</span><span class="op">);</span> <span class="co">// compile time error, up-cast not possible</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>ob<span class="op">.</span><span class="fu">test</span><span class="op">(</span><span class="fl">123.25f</span><span class="op">);</span> <span class="co">// that is fine, automatic promotion</span></span></code></pre></div>
<p>In the example above, the first call will result in a compile time
error, because there is no overloaded method which takes two doubles as
arguments, however the call below will be just fine, even though we do
not have a float overload, the type system and the java compiler would
perform automatic promotion of the type casting it from float to double,
and it will invoke <code>test(double)</code></p>
<p>Constructors can also be overloaded, there are no special
requirements for them, the rules which apply for normal method
overloading also apply for constructors, the name is kept the same and
the permutation of number and type of arguments must be unique,
otherwise the compiler would complain. Type promotion also may occur for
constructor overloaded methods.</p>
<h3 id="invocation">Invocation</h3>
<p>Briefly, the way java works is that all arguments are passed by
value, meaning that a copy of the argument is created and pushed on the
stack before the method is invoked, however, there are some caveats,
since objects are a kind of reference, when we pass object to a function
as parameter which the <code>pointer</code> or <code>reference</code>
itself is copied, the actual value of the <code>reference</code> still
points to the original object, so we end up with an parameter that
points to the same object, even though the actual pass is by-value. For
other primitive types such as numbers, boolean and char there are no
special cases, they are simply copied by-value as well.</p>
<h3 id="returning">Returning</h3>
<p>Returning from methods is also done by-value, meaning that the
returned type is copied back onto the call stack, the same caveats for
object references is valid here, even though the reference itself is
copied, the value remains the same meaning that the resulting object
points to the same object on the heap. We are also allowed to return
<code>new Type()</code> from methods, and do not have to worry about
going out of scope, and the garbage collector cleaning up the created
object, as long as at least one reference to that object exists in our
program</p>
<div class="sourceCode" id="cb4"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>   <span class="bu">Box</span> <span class="fu">createBox</span><span class="op">()</span> <span class="op">{</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>       <span class="cf">return</span> <span class="kw">new</span> <span class="bu">Box</span><span class="op">();</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>   <span class="op">}</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>   <span class="bu">Box</span> b <span class="op">=</span> <span class="fu">createBox</span><span class="op">();</span> <span class="co">// b will still point to the new box, therefore the collector can not forcefully collect/sweep it</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>   <span class="fu">createBox</span><span class="op">();</span> <span class="co">// the result is not used, meaning that no reference point to the created box, eligible for collection</span></span></code></pre></div>
<h3 id="arguments">Arguments</h3>
<p>One particularly important feature in java is variable arguments
list, which can be passed to a method, to signify that the method takes
an unkown, possibly 0 number of arguments to operate on. The variable
number of arguments are defined with the <code>...</code> notation, and
it is important to know that they have to be of the same type.</p>
<div class="sourceCode" id="cb5"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> <span class="fu">vamethod</span><span class="op">(</span><span class="dt">int</span> <span class="kw">...</span> v<span class="op">)</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>    <span class="fu">vamethod</span><span class="op">(</span><span class="dv">10</span><span class="op">);</span> <span class="co">// 1 arg</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>    <span class="fu">vamethod</span><span class="op">(</span><span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span><span class="op">);</span> <span class="co">// 3 args</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>    <span class="fu">vamethod</span><span class="op">();</span> <span class="co">// no args</span></span></code></pre></div>
<p>The way this works internally is that the compiler would implicitly
define <code>v</code> the variable argument passed to the function as an
array, and thus inside the function we can iterate over these arguments,
we have access to the <code>.length</code> property of the array, but in
effect the method with a variable argument becomes something like
<code>vamethod(int[] v)</code></p>
<p><code>A method can have "normal" parameters along with a variable-length parameter. However, the variable-length parameter must be the last parameter declared by the method. Attempt to declare a second varargs type parameter is not allowed</code></p>
<p>Similarly to other normal methods, varargs can be overloaded,
remember they are just a substitute for an array of a given type
<code>type[]</code>, meaning that we can define and overload the
function with multiple types of varargs such as the following</p>
<div class="sourceCode" id="cb6"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> <span class="fu">vamethod</span><span class="op">([</span>other optional paramters<span class="op">],</span> <span class="dt">int</span> <span class="kw">...</span> v<span class="op">)</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> <span class="fu">vamethod</span><span class="op">([</span>other optional paramters<span class="op">],</span> <span class="dt">boolean</span> <span class="kw">...</span> v<span class="op">)</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> <span class="fu">vamethod</span><span class="op">([</span>other optional paramters<span class="op">],</span> <span class="dt">double</span> <span class="kw">...</span> v<span class="op">)</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> <span class="fu">vamethod</span><span class="op">([</span>other optional paramters<span class="op">],</span> <span class="dt">float</span> <span class="kw">...</span> v<span class="op">)</span></span></code></pre></div>
<p>The second way to overload a varargs method is to add one or more
normal parameters. This is what was done with vamethod(String, int â€¦).
In this case, Java uses both the number of arguments and their types.
But that is no different in esense from the regular method
overloading</p>
<div class="sourceCode" id="cb7"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> <span class="fu">vamethod</span><span class="op">(</span><span class="bu">String</span> n<span class="op">)</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> <span class="fu">vamethod</span><span class="op">(</span><span class="bu">String</span> n<span class="op">,</span> <span class="dt">int</span> <span class="kw">...</span> v<span class="op">)</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">// these two pairs are essentially equivalent, varargs is more or less syntactic sugar for an argument of type[] first and fore most</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> <span class="fu">vamethod</span><span class="op">(</span><span class="bu">String</span> n<span class="op">)</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> <span class="fu">vamethod</span><span class="op">(</span><span class="bu">String</span> n<span class="op">,</span> <span class="dt">int</span><span class="op">[]</span> v<span class="op">)</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>    <span class="co">// this is why we can actually call varargs methods like that, even though it is pointless, it demonstrates how the compiler treats them</span></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>    <span class="fu">vamethod</span><span class="op">(</span><span class="st">&quot;&quot;</span><span class="op">,</span> <span class="kw">new</span> <span class="dt">int</span><span class="op">[]{</span><span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span><span class="op">});</span></span></code></pre></div>
<p>Now what would happen if we had these two methods defined as
illustrated below, a compile time error will arise precisely because the
way the compiler implicitly treats the variable arguments paramters as
arrays of a given type, we can not have the following</p>
<div class="sourceCode" id="cb8"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> <span class="fu">vamethod</span><span class="op">(</span><span class="bu">String</span> n<span class="op">,</span> <span class="dt">int</span><span class="op">[]</span> v<span class="op">)</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> <span class="fu">vamethod</span><span class="op">(</span><span class="bu">String</span> n<span class="op">,</span> <span class="dt">int</span> <span class="kw">...</span> v<span class="op">)</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">// that is a compile time error, remember that varargs are essentially the same as type[]</span></span></code></pre></div>
<p>There might be some ambiguity when we define and call varargs
methods, which will cause compile time error, consider the following
examples</p>
<div class="sourceCode" id="cb9"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> <span class="fu">vamethod</span><span class="op">(</span><span class="dt">int</span> <span class="kw">...</span>v<span class="op">)</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> <span class="fu">vamethod</span><span class="op">(</span><span class="dt">boolean</span> <span class="kw">...</span>v<span class="op">)</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>    <span class="fu">vamethod</span><span class="op">()</span> <span class="co">// compile time error, since both are equally valid</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> <span class="fu">vamethod</span><span class="op">(</span><span class="dt">int</span> <span class="kw">...</span>v<span class="op">)</span></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> <span class="fu">vamethod</span><span class="op">(</span><span class="dt">int</span><span class="op">,</span> <span class="dt">int</span> <span class="kw">...</span>v<span class="op">)</span></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>    <span class="fu">vamethod</span><span class="op">(</span><span class="dv">1</span><span class="op">)</span> <span class="co">// compile time error, since both are equally valid</span></span></code></pre></div>
</body>
</html>
