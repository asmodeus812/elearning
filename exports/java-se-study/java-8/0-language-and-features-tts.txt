Java

Java is a high-level, class-based, object-oriented programming language. It was designed to minimize implementation dependencies, making it as platform-independent as possible. Java is a general-purpose language, and its core philosophy is “write once, run anywhere.” This means that once you compile Java code, it can run on any platform that supports Java, without needing to be recompiled.

When you write a Java application, it is typically compiled into something called bytecode. This bytecode can run on any Java Virtual Machine, or JVM, regardless of the underlying computer architecture. Java’s syntax is similar to C and C plus plus, but it intentionally leaves out many of the low-level features found in those languages.

The History

Java was created by James Gosling, Patrick Naughton, Chris Warth, Ed Frank, and Mike Sheridan at Sun Microsystems in nineteen ninety-one. It took them about eighteen months to develop the first working version. The language was originally called “Oak,” but was renamed “Java” in nineteen ninety-five.

The motivation behind Java was to create a platform-independent, or architecture-neutral, language. The goal was to enable software to be embedded in various consumer electronic devices, such as microwave ovens and remote controls. These devices use many different types of CPUs as controllers. The problem with languages like C and C plus plus is that they are designed to be compiled for a specific target, making portability difficult.

Changing the World

Applets

An applet is a special kind of Java program designed to be transmitted over the Internet and automatically executed by a Java-compatible web browser. Applets are downloaded on demand, without further user interaction. For example, if a user clicks a link containing an applet, it will be automatically downloaded and run in the browser. Applets are typically small programs used to display data from a server, handle user input, or provide simple local functions, such as a loan calculator. Essentially, applets allow some functionality to be moved from the server to the client.

Servlets

Java’s usefulness quickly extended to the server side with the introduction of servlets. A servlet is a small program that runs on the server. Just as applets extend the functionality of a web browser, servlets extend the functionality of a web server. With servlets, Java became a language that could span both sides of the client-server connection.

Security

Java achieved a high level of security by confining applets to the Java execution environment, preventing them from accessing other parts of the computer. This approach allowed users to download and run applets with confidence that their systems would not be harmed or compromised. This security model was one of Java’s most innovative features.

Portability

Portability is crucial for the Internet, which connects many different types of computers and operating systems. For a Java program to run on virtually any computer connected to the Internet, there needed to be a way to execute that program on different systems. Java’s solution was to compile programs into bytecode, which could then be run on any system with a compatible JVM.

Bytecode Magic

The output of a Java compiler is not executable code, but bytecode. Bytecode is a highly optimized set of instructions designed to be executed by the Java Virtual Machine, or JVM. The original JVM was essentially an interpreter for bytecode.

This design choice may seem surprising, since many modern languages are compiled directly into executable code for performance reasons. However, executing Java programs through the JVM solves many problems associated with web-based programs. By translating Java programs into bytecode, it becomes much easier to run them in a wide variety of environments. Only the JVM needs to be implemented for each platform. Once the JVM is available for a system, any Java program can run on it. Although the details of the JVM differ from platform to platform, all JVMs understand the same Java bytecode.

If Java programs were compiled to native code, different versions would be needed for each type of CPU. This would not be practical. Running Java programs through the JVM also enhances security.

Although Java was originally designed as an interpreted language, there is nothing preventing bytecode from being compiled into native code on the fly to improve performance. This is where HotSpot technology comes in. HotSpot introduced a Just-In-Time, or JIT, compiler for bytecode. When a JIT compiler is part of the JVM, selected portions of bytecode are compiled into executable code in real time, as needed. It is not practical to compile an entire Java program into executable code all at once, because Java performs various run-time checks that can only be done during execution. Instead, the JIT compiler compiles code as it is needed.

Core Concepts

Java is built around several core concepts. It is secure, simple, portable, object-oriented, robust, multithreaded, architecture-neutral, interpreted, high performance, distributed, and dynamic.

Java Versions

Let’s look at the major features introduced in each version of Java, with a special focus on Java 5, which marked a significant leap forward for the language.

Java 1.0, released in nineteen ninety-six, was the initial release. It introduced basic language features, the Abstract Window Toolkit for graphical user interfaces, applets, the Java Virtual Machine, garbage collection, and support for multithreading.

Java 1.1, released in nineteen ninety-seven, brought a significant update. It introduced a new event handling model called the delegation event model, inner classes, JavaBeans, Java Database Connectivity, or JDBC, Remote Method Invocation, or RMI, and deprecated some methods from version one point zero.

Java 1.2, also known as Java 2, arrived in nineteen ninety-eight. This was a major update that marked the beginning of “modern Java.” It introduced the Swing graphical user interface toolkit, the Collections Framework, integration of the Just-In-Time compiler into the JVM, the Java Plug-in, and security enhancements.

Java 1.3, released in the year two thousand, focused on performance improvements. The HotSpot JVM became the default, and the JavaSound API was added. There were also minor updates to collections and networking.

Java 1.4, released in two thousand two, introduced assertions, regular expressions, the New Input Output, or NIO, Java Web Start, a logging API, and XML parsing. This version focused on better core language support and more robust input and output.

Java 1.5, also known as Java 5, was released in two thousand four. This version introduced generics, the enhanced for loop, autoboxing and unboxing, variable arguments, annotations, enumerations, and the concurrency utilities package. The version was renamed Java 5.0 to reflect the magnitude of the updates.

Java 1.6, or Java 6, released in two thousand six, focused on performance improvements. It added a scripting API, a compiler API, web services support through JAX-WS, and enhancements to JDBC 4.0.

Java 1.7, or Java 7, released in two thousand eleven, introduced try-with-resources for better exception handling, the diamond operator, enhanced file input and output with NIO.2, the Fork and Join framework, switch statements with strings, and improvements to the JVM, including the invokedynamic bytecode.

The release of Java J2SE 5 was revolutionary. Unlike previous upgrades, which offered important but incremental improvements, J2SE 5 fundamentally expanded the scope, power, and range of the language. The significance of these new features was reflected in the version number. Instead of moving from one point four to one point five, Sun Microsystems chose to call it Java 5, emphasizing the major leap forward. The developer’s kit was called JDK 5. Internally, the version number remained one point five, which is also referred to as the developer version number. The “5” in J2SE 5 is the product version number.

This marked a significant milestone in the development of the language and its runtime. From then on, major versions would be referred to as Java SE 5, 6, 7, and so on. However, the internal development version number format of one point underscore release was kept up until the release of Java 8, which was known as Java SE one point eight.


Java SE 7 Overview

Java Standard Edition 7, often called Java SE 7, was the first major release of Java after Oracle acquired Sun Microsystems. This release brought several important additions to the Java API library. Two of the most significant enhancements were the improvements to the NIO framework and the introduction of the Fork and Join framework. The NIO, which originally stood for New Input and Output, was first added in Java version 1.4. However, the changes introduced in Java SE 7 greatly expanded its capabilities. These changes were so substantial that the term NIO.2 is often used to refer to the updated framework.

Java Features

Java Beans

Java Beans are a set of conventions for creating reusable software components in Java. They allow developers to encapsulate multiple objects into a single object, known as a bean. Java Beans use properties to store and retrieve data, which are accessed through getter and setter methods. For example, a property called name would have methods called getName and setName. Java Beans must have a no-argument, or default, constructor. This makes it easy to create instances without providing parameters. Additionally, Java Beans should implement the Serializable interface, which allows them to be easily saved and restored, or transmitted over a network. The naming convention for accessor methods is important: getter methods start with the word get, followed by the property name.

AWT, or Abstract Window Toolkit

AWT is the original graphical user interface toolkit for Java, introduced in Java Development Kit version 1.0. It provides a set of native, platform-dependent components for building graphical user interfaces. These components include basic elements such as buttons, checkboxes, labels, and text fields. AWT components are rendered by the native operating system, which means they look and behave like native components on different platforms.

Swing

Swing is a more advanced graphical user interface toolkit that was introduced in Java Development Kit version 1.2, as part of Java 2. Swing builds on top of AWT but offers a richer set of components. These include enhanced elements like JButton, JLabel, JTable, JTree, and JList, which provide greater functionality and customization options. Unlike AWT, Swing components are rendered by Java itself, not by the native operating system. This ensures a consistent look and feel across different platforms.

JDBC, or Java Database Connectivity

JDBC is a Java API that enables Java applications to interact with relational databases. It provides a standard interface for connecting to databases, executing SQL queries, and retrieving results. JDBC allows Java applications to connect to a wide variety of relational databases, such as MySQL, PostgreSQL, and Oracle, using a database driver. Through JDBC, developers can execute SQL statements, including queries, updates, and more complex commands. JDBC also provides mechanisms for processing the results returned by SQL queries, such as navigating through results, extracting data, and handling errors. Additionally, JDBC supports transaction management, allowing developers to commit or roll back transactions to ensure data integrity.

RMI, or Remote Method Invocation

RMI is a Java API that allows a Java program to invoke methods on an object located on a different Java Virtual Machine, or JVM. This can be on the same machine or across a network, enabling communication over the internet. RMI allows objects to communicate remotely, making it possible to develop distributed applications. It transmits object states between JVMs using Java's built-in serialization mechanism. Clients use stubs to interact with remote objects, while the server side uses skeletons, although skeletons are deprecated in recent versions, to handle communication.

The Java Sound API

The Java Sound API provides a set of classes and interfaces for handling audio in Java applications. It allows developers to work with audio data for tasks such as playback, recording, and processing. The API provides access to audio system resources and manages audio data, including mixing, playback, and recording. A central class in this API is AudioSystem, which provides methods for obtaining and managing audio line objects, such as mixers, data lines, and audio input or output lines.

Java Web Start

Java Web Start was a technology developed by Sun Microsystems, and later maintained by Oracle, that allowed Java applications to be launched and run over a network from a web browser. Introduced in Java 1.4, it was part of the Java Runtime Environment. Java Web Start simplified the deployment of Java applications by enabling users to launch programs directly from a web browser or desktop shortcut, without needing to install them manually. It used the Java Network Launch Protocol, or JNLP, which is an XML file describing how to launch and manage the application. The JNLP file includes information such as the application's main class, required libraries, and resources.

How Java Web Start Worked

When a user clicked on a link to a Java Web Start application, the JNLP file was downloaded and read by the Java Runtime Environment. Java Web Start then downloaded the application's JAR files and other resources specified in the JNLP file. The application was cached locally on the user's machine to improve performance for future launches. Finally, the Java Runtime Environment launched the application in its own process, providing the user interface as specified by the application.

Java Logging API

The Java Logging API, also known as the java.util.logging package, provides a standardized mechanism and a concrete implementation for logging information in Java applications. The Java Logging API is a built-in logging framework with its own set of classes and methods for logging messages. In contrast, SLF4J acts as a facade or abstraction layer, providing a common API that allows developers to switch between different logging implementations without changing their logging code. Developers can use the Java Logging API directly to create loggers and manage log messages. Alternatively, they can use SLF4J to write logging code in a generic way, which can then be routed to different logging frameworks, including the Java Logging API, Log4j, Logback, and others.

The Original Input and Output API in Java

The original input and output API in Java, introduced in Java 1.0, is part of the java.io package. This API provides classes and interfaces for performing input and output operations, primarily with files, streams, and data. There are several key components:

First, byte streams, which include InputStream as the base class for reading byte data, and OutputStream as the base class for writing byte data.

Second, character streams, which include Reader as the base class for reading character data, and Writer as the base class for writing character data.

Third, data streams, which include DataInputStream for reading primitive data types, and DataOutputStream for writing primitive data types.

Fourth, object streams, which include ObjectInputStream for reading serialized objects, and ObjectOutputStream for writing serialized objects.

Finally, file input and output, which is managed by the File class. This class represents file and directory pathnames, enabling file and directory manipulation.

The Java NIO

The Java NIO, introduced in Java 1.4 and found in the java.nio package, includes several key components designed for more efficient and flexible input and output operations.

First, buffers are containers for data that allow for efficient reading and writing. Examples include ByteBuffer, CharBuffer, and IntBuffer.

Second, channels represent connections to input and output devices and provide a way to read from and write to buffers. Examples include FileChannel, SocketChannel, and DatagramChannel.

Third, selectors allow for non-blocking input and output operations by enabling a single thread to manage multiple channels. The Selector class is used for multiplexing input and output operations.

Fourth, charsets provide support for character encoding and decoding. Key classes include Charset, CharsetEncoder, and CharsetDecoder.

Incoming HTTP Request Over a Socket

When a client, such as a web browser or another application, sends an HTTP request to a server, the request is transmitted over the network using the HTTP protocol. The HTTP request is sent over a TCP/IP connection, which involves creating a socket connection between the client and the server. On the server side, a socket acts as an endpoint for communication. The web server listens on a specific port, such as port eighty for HTTP or four hundred forty-three for HTTPS, for incoming connections. When a request arrives, the server accepts the socket connection and reads the incoming HTTP request data from the socket.

Request Handling by the Web Server

The web server parses the HTTP request to extract the request method, such as GET or POST, the URL, headers, and the body if present. The next step is routing the request.


The server determines how to handle each request by examining the URL and the HTTP method. Depending on what it finds, the server may serve static content, such as HTML files, directly to the client. Alternatively, if the request is for dynamic content or a web service, the web server forwards the request to a Java EE application server. This forwarding can happen through various mechanisms, such as proxying or direct communication between the servers.

Next, the application server—examples include Apache Tomcat or JBoss EAP—receives the request from the web server. These servers are designed to handle Java EE components. The application server then dispatches the request to the appropriate component, based on its configuration. For instance, it might route the request to a servlet or a web service.

If the request is for a web service, the application server locates the correct service endpoint by examining the request URL and method. The way the server processes the request depends on the type of web service.

For SOAP web services, which use the Java API for XML Web Services, or JAX-WS, the service is described using the Web Services Description Language, or WSDL. The server uses the WSDL file to understand the structure of the request and to determine how to process it. The application server then uses JAX-WS to handle the SOAP request, invoking the appropriate service method based on the contents of the SOAP message.

For RESTful web services, which use the Java API for RESTful Web Services, or JAX-RS, the services are defined using annotations that map HTTP methods to Java methods. The server uses JAX-RS to find the correct resource method to handle the request. The application server processes the request, which may involve executing business logic or interacting with a database, and then prepares a response.

During business logic execution, the web service might interact with other components, such as Enterprise JavaBeans, or EJBs, or with data access layers, to perform the necessary operations.

Once the processing is complete, the web service generates a response. For SOAP services, this means creating a SOAP message. For RESTful services, the response might be in JSON or XML format. The response is then sent back to the web server, which forwards it to the client. The response includes the HTTP status code, headers, and the body content. After the response is sent, the socket connection is closed, unless it is kept alive for further requests.

Release Cycle

There are several reasons for Java’s six-month release cycle.

First, increased agility. The rapid pace of technological advancement and evolving programming paradigms require a more agile approach to language updates. A six-month cycle allows for quicker iterations on features and improvements.

Second, feature-driven releases. By allowing smaller, more frequent updates, Java can incorporate new features, enhancements, and fixes without waiting for a major version release. This means developers can access improvements more frequently.

Third, a focus on quality. The smaller scope of each release helps maintain quality. Instead of waiting for a large number of features to accumulate, each release can focus on a specific set of enhancements or bug fixes.

Fourth, community engagement. Regular releases encourage community involvement. Developers can provide feedback on new features more frequently, and their input can be integrated into upcoming releases.

Finally, predictability. A consistent release schedule helps organizations plan their upgrade paths and incorporate new features into their development processes.

Future of the Six-Month Cycle

As for whether this cycle will continue indefinitely, several points are worth noting.

First, sustainability. The six-month cycle has been well-received and has proven sustainable over several years. There is no official indication from Oracle or the OpenJDK community that they plan to change this schedule in the near future.

Second, continuous improvement. The Java community regularly evaluates the release process and adapts as needed. If the community or the demands of modern software development change significantly, adjustments to the release cadence might be considered.

Third, feature proposals. The community continues to propose new features through the JDK Enhancement Proposal, or JEP, process. This iterative improvement mechanism fits well with a six-month release model.


