<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>7-primitives-and-literals</title>
  <style>
    html {
      font-size: 12pt;
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      overflow-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 12px;
      }
      h1 {
        font-size: 1.8em;
      }
    }
    @media print {
      html {
        background-color: white;
      }
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, Consolas, 'Lucida Console', monospace;
      font-size: 85%;
      margin: 0;
      hyphens: manual;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
      overflow-wrap: normal;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      background-color: #1a1a1a;
      border: none;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC ul {
      padding-left: 1.3em;
    }
    #TOC > ul {
      padding-left: 0;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
    /* CSS for syntax highlighting */
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    .sourceCode { overflow: visible; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {   }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ff0000; font-weight: bold; } /* Alert */
    code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #7d9029; } /* Attribute */
    code span.bn { color: #40a070; } /* BaseN */
    code span.bu { color: #008000; } /* BuiltIn */
    code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4070a0; } /* Char */
    code span.cn { color: #880000; } /* Constant */
    code span.co { color: #60a0b0; font-style: italic; } /* Comment */
    code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #ba2121; font-style: italic; } /* Documentation */
    code span.dt { color: #902000; } /* DataType */
    code span.dv { color: #40a070; } /* DecVal */
    code span.er { color: #ff0000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #40a070; } /* Float */
    code span.fu { color: #06287e; } /* Function */
    code span.im { color: #008000; font-weight: bold; } /* Import */
    code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #007020; font-weight: bold; } /* Keyword */
    code span.op { color: #666666; } /* Operator */
    code span.ot { color: #007020; } /* Other */
    code span.pp { color: #bc7a00; } /* Preprocessor */
    code span.sc { color: #4070a0; } /* SpecialChar */
    code span.ss { color: #bb6688; } /* SpecialString */
    code span.st { color: #4070a0; } /* String */
    code span.va { color: #19177c; } /* Variable */
    code span.vs { color: #4070a0; } /* VerbatimString */
    code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  \usepackage{listings}
  \usepackage{xcolor}

  \lstset{
      basicstyle=\ttfamily,
      backgroundcolor=\color{black!10},
      showspaces=false,
      showstringspaces=false,
      showtabs=false,
      tabsize=2,
      captionpos=b,
      breaklines=true,
      breakautoindent=true,
      linewidth=\textwidth
  }
</head>
<body>
<nav id="TOC" role="doc-toc">
<ul>
<li><a href="#primitives" id="toc-primitives">Primitives</a>
<ul>
<li><a href="#number" id="toc-number">Number</a></li>
<li><a href="#boolean" id="toc-boolean">Boolean</a></li>
<li><a href="#character" id="toc-character">Character</a></li>
</ul></li>
<li><a href="#literals" id="toc-literals">Literals</a>
<ul>
<li><a href="#types" id="toc-types">Types</a></li>
<li><a href="#range" id="toc-range">Range</a></li>
<li><a href="#separation" id="toc-separation">Separation</a></li>
<li><a href="#sequences" id="toc-sequences">Sequences</a></li>
<li><a href="#casting" id="toc-casting">Casting</a></li>
<li><a href="#promotion" id="toc-promotion">Promotion</a></li>
</ul></li>
</ul>
</nav>
<h2 id="primitives">Primitives</h2>
<p>Java defines eight primitive types of data:
<code>byte, short, int, long, char, float, double, and boolean.</code>
The primitive types are also commonly referred to as simple types,</p>
<h3 id="number">Number</h3>
<table>
<colgroup>
<col style="width: 9%" />
<col style="width: 7%" />
<col style="width: 83%" />
</colgroup>
<thead>
<tr class="header">
<th>Name</th>
<th>Width</th>
<th>Range</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>long</td>
<td>64</td>
<td>-9,223,372,036,854,775,808 to 9,223,372,036,854,775,807</td>
</tr>
<tr class="even">
<td>int</td>
<td>32</td>
<td>-2,147,483,648 to 2,147,483,647</td>
</tr>
<tr class="odd">
<td>short</td>
<td>16</td>
<td>-32,768 to 32,767</td>
</tr>
<tr class="even">
<td>byte</td>
<td>8</td>
<td>-128 to 127</td>
</tr>
<tr class="odd">
<td>double</td>
<td>64</td>
<td>4.9e-324 to 1.8e+308</td>
</tr>
<tr class="even">
<td>float</td>
<td>32</td>
<td>1.4e-045 to 3.4e+038</td>
</tr>
</tbody>
</table>
<h3 id="boolean">Boolean</h3>
<p>It can have only one of two possible values, true or false. This is
the type returned by all relational operators, as in the</p>
<h3 id="character">Character</h3>
<p>In Java, the data type used to store characters is char. However,
C/C++ programmers beware: char in Java is not the same as char in C or
C++. In C/C++, char is 8 bits wide. This is not the case in Java.
Instead, Java uses Unicode to represent characters. Unicode defines a
fully international character set that can represent all of the
characters found in all human languages. It is a unification of dozens
of character sets, such as Latin, Greek, Arabic, Cyrillic, Hebrew,
Katakana, Hangul, and many more. At the time of Java’s creation, Unicode
required 16 bits. Thus, in Java char is a 16-bit type. The range of a
char is 0 to 65,536 - holds 2 bytes, and has the same range as
<code>unsigned short</code> (in other languages)</p>
<h2 id="literals">Literals</h2>
<p>Are the special types of values that can be represented in code,
literally. They are usually stored in a special way as a part of the
program’s data segment or the stack. But what is important to note is
that they are immutable, and identical. Meaning that a number literal
<code>1</code> is identical to another number literal <code>1</code> in
the code, same applies for String literals too, a literal of “hello” is
the same as “hello” somewhere else in another part of the code, which is
unlike other languages where string literals do not exist or are not
treated at compile time</p>
<h3 id="types">Types</h3>
<h4 id="integer-literals">Integer literals</h4>
<ul>
<li>base 10 -
e.g. <code>1</code>,<code>2</code>,<code>3</code>,<code>4</code>,<code>100</code>,<code>999</code></li>
<li>base 16 -
e.g. <code>0xFE</code>,<code>0xDE</code>,<code>0xA0</code></li>
<li>base 8 - e.g. <code>073</code>,<code>012</code></li>
<li>base 2 - e.g. <code>0b1010</code>,<code>0b1111</code></li>
</ul>
<h4 id="boolean-literals">Boolean literals</h4>
<ul>
<li>boolean - e.g. <code>false</code> or <code>true</code></li>
</ul>
<p>Floating literals</p>
<ul>
<li>double - e.g. <code>9.54</code></li>
<li>float - e.g. <code>9.54f</code></li>
</ul>
<h4 id="character-literals">Character literals</h4>
<ul>
<li>char - <code>\u0061</code></li>
</ul>
<h4 id="string-literals">String literals</h4>
<ul>
<li><p>string - “value”</p>
<div class="sourceCode" id="cb1"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="bu">String</span> str1 <span class="op">=</span> <span class="st">&quot;hello&quot;</span><span class="op">;</span> <span class="co">// created</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="bu">String</span> str2 <span class="op">=</span> <span class="st">&quot;hello&quot;</span><span class="op">;</span> <span class="co">// reused</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="bu">System</span><span class="op">.</span><span class="fu">out</span><span class="op">.</span><span class="fu">println</span><span class="op">(</span>str1 <span class="op">==</span> str2<span class="op">);</span> <span class="co">// true</span></span></code></pre></div></li>
</ul>
<p>Note that unlike other literals, the string literal below has some
very special properties, similarly to other languages where string
literals are stored on the stack or the data segment of a program. Java
has a similar way of storing string literals in a pool. This pool of
strings is allocated on the heap and when a string literal is created
the JVM checks if that string already exists in the pool, reusing the
existing object - string, otherwise a new one is created. String
literals are also immutable.</p>
<p>The process of declaring a string using double quotes (e.g., String
str = “hello”;), is called automatic string interning, it is stored in
the string pool. However, if you create a string using the new keyword
(e.g., String str = new String(“hello”);), the string is not
automatically interned. This creates a new string object on the
heap.</p>
<p>Compile time constant String literals which are concatenated are
optimized during the byte code compilation step, and result into a
single string instead of multiple.</p>
<div class="sourceCode" id="cb2"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="bu">String</span> s1 <span class="op">=</span> <span class="st">&quot;hello&quot;</span> <span class="op">+</span> <span class="st">&quot; &quot;</span> <span class="op">+</span> <span class="st">&quot;world&quot;</span><span class="op">;</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="bu">String</span> s2 <span class="op">=</span> <span class="st">&quot;hello world&quot;</span><span class="op">;</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="bu">System</span><span class="op">.</span><span class="fu">out</span><span class="op">.</span><span class="fu">println</span><span class="op">(</span>s1 <span class="op">==</span> s2<span class="op">);</span> <span class="co">// true, both are optimized to the same string literal</span></span></code></pre></div>
<p>String literals are treated as constants, meaning that they can be
used where constants are expected, such as in switch statements or final
variables.</p>
<h3 id="range">Range</h3>
<p>By default all literals which we specify are actually of type
<code>int</code>, and all decimal or floating point literals (e.g. 9.54)
ones default to <code>double</code> type. To signify a literal of other
type one must suffix it with an additional character such as
<code>l</code> for long <code>f</code> for float, otherwise a
compilation error will occur</p>
<div class="sourceCode" id="cb3"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>    <span class="dt">long</span> longer <span class="op">=</span> <span class="bn">0x7fffffffffL</span><span class="op">;</span> <span class="co">// in range, suffixed with l to signify it is long</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> integer <span class="op">=</span> <span class="bn">0x7fffffffff</span><span class="op">;</span> <span class="co">// compilation error</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">byte</span> character <span class="op">=</span> <span class="bn">0x43434</span><span class="op">;</span> <span class="co">// compilation error</span></span></code></pre></div>
<h3 id="separation">Separation</h3>
<p>With java 7 it is also possible to add <code>underscores</code> for
spacing integer literals, for better readability, for example having
something like that <code>int readable = 999_999_999_999</code> or
<code>int readable = 999___999___999</code> is quite helpful, one can
also do this with other radix types such as hex
<code>int readable = 0xFF_FF_FF_FF</code>. This is also applicable for
double, float and so on.</p>
<h3 id="sequences">Sequences</h3>
<table>
<thead>
<tr class="header">
<th>Sequence</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td></td>
<td>Octal character (ddd)</td>
</tr>
<tr class="even">
<td></td>
<td>Hexadecimal Unicode character (xxxx)</td>
</tr>
<tr class="odd">
<td>'</td>
<td>Single quote</td>
</tr>
<tr class="even">
<td>"</td>
<td>Double quote</td>
</tr>
<tr class="odd">
<td>\</td>
<td>Backslash</td>
</tr>
<tr class="even">
<td> Carriage return</td>
<td></td>
</tr>
<tr class="odd">
<td></td>
<td>New line (also known as line feed)</td>
</tr>
<tr class="even">
<td> Form feed</td>
<td></td>
</tr>
<tr class="odd">
<td> Tab</td>
<td></td>
</tr>
<tr class="even">
<td> Backspace</td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="casting">Casting</h3>
<p>In java by default the language runtime will perform automatic
casting when the two types are compatible or the destination type is of
a higher ordinance than the source. An <code>int</code> is always big
enough to hold a <code>byte</code>, but the inverse is not true. Also
<code>char</code> and <code>boolean</code> unlike in other languages are
not compatible, they can not be converted from one to the other. If we
want to convert from a higher ordinance type to a lower ordinance type
we have to use a cast operator to explicitly tell java that we would
like to perform what is called a <code>narrowing</code> cast or
conversion</p>
<div class="sourceCode" id="cb4"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>    <span class="dt">byte</span> wrong <span class="op">=</span> <span class="dv">1024</span><span class="op">;</span> <span class="co">// that will produce a compile time error</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">byte</span> right <span class="op">=</span> <span class="op">(</span><span class="dt">byte</span><span class="op">)</span> <span class="dv">1024</span><span class="op">;</span> <span class="co">// this will work, however overflow</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> flat <span class="op">=</span> <span class="op">(</span><span class="dt">int</span><span class="op">)</span> <span class="fl">1.24f</span><span class="op">;</span> <span class="co">// the result will be 1 assigned to var</span></span></code></pre></div>
<h3 id="promotion">Promotion</h3>
<p>When evaluating expressions, java would automatically promote types,
consider the following</p>
<div class="sourceCode" id="cb5"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>    <span class="dt">byte</span> a <span class="op">=</span> <span class="dv">40</span><span class="op">;</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">byte</span> b <span class="op">=</span> <span class="dv">50</span><span class="op">;</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">byte</span> c <span class="op">=</span> <span class="dv">100</span><span class="op">;</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> d <span class="op">=</span> a <span class="op">*</span> b <span class="op">/</span> c<span class="op">;</span> <span class="co">// a * b will be automatically promoted to int during compile time</span></span></code></pre></div>
<p>The <code>a*b</code> will easily exceed the size of byte, which is
<code>0-255</code>, however java would make sure that the result of the
expression <code>a*b</code> is not of type byte, which are the types of
the arguments included in the expression, but rather it will
automatically promote them to higher value, in this case it might be
short or int, such that the result of the expression fits without
overflowing</p>
<div class="sourceCode" id="cb6"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>    <span class="dt">byte</span> b <span class="op">=</span> <span class="dv">50</span><span class="op">;</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>    b <span class="op">=</span> b <span class="op">*</span> <span class="dv">2</span><span class="op">;</span> <span class="co">// this will produce an error precisely because the automatic promotion.</span></span></code></pre></div>
<p>However consider the case above, since java is doing the automatic
promotion at compile time, the result of <code>b*2</code> will be
interpreted as <code>int</code> or <code>short</code> meaning we would
try to assign the intermediate result of <code>b*2</code> to
<code>b</code> which is <code>byte</code> that is not allowed, and since
we are doing an assignment from a higher ordinance type to a lower one,
compile time error occurs</p>
<p><code>Automatic promotion rules: First, all byte, short, and char values are promoted to int, as just described. Then, if one operand is a long, the whole expression is promoted to long. If one operand is a float, the entire expression is promoted to float. If any of the operands are double, the result is double.</code></p>
<div class="sourceCode" id="cb7"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>    <span class="dt">byte</span> b <span class="op">=</span> <span class="dv">42</span><span class="op">;</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">char</span> c <span class="op">=</span> <span class="ch">&#39;a&#39;</span><span class="op">;</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">short</span> s <span class="op">=</span> <span class="dv">1024</span><span class="op">;</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> i <span class="op">=</span> <span class="dv">50000</span><span class="op">;</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> f <span class="op">=</span> <span class="fl">5.67f</span><span class="op">;</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">double</span> d <span class="op">=</span> <span class="fl">.1234</span><span class="op">;</span></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>    <span class="dt">double</span> result <span class="op">=</span> <span class="op">(</span>f <span class="op">*</span> b<span class="op">)</span> <span class="op">+</span> <span class="op">(</span>i <span class="op">/</span> c<span class="op">)</span> <span class="op">-</span> <span class="op">(</span>d <span class="op">*</span> s<span class="op">);</span></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>    <span class="bu">System</span><span class="op">.</span><span class="fu">out</span><span class="op">.</span><span class="fu">println</span><span class="op">((</span>f <span class="op">*</span> b<span class="op">)</span> <span class="op">+</span> <span class="st">&quot; + &quot;</span> <span class="op">+</span> <span class="op">(</span>i <span class="op">/</span> c<span class="op">)</span> <span class="op">+</span> <span class="st">&quot; - &quot;</span> <span class="op">+</span> <span class="op">(</span>d <span class="op">*</span> s<span class="op">));</span></span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a>    <span class="bu">System</span><span class="op">.</span><span class="fu">out</span><span class="op">.</span><span class="fu">println</span><span class="op">(</span><span class="st">&quot;result = &quot;</span> <span class="op">+</span> result<span class="op">);</span></span></code></pre></div>
<ul>
<li><code>f \* b</code>, b is promoted to a <code>float</code> and the
result of the sub expression is <code>float</code>.</li>
<li><code>i/c</code>, c is promoted to <code>int</code>, and the result
is of type <code>int</code>.</li>
<li><code>d \* s</code>, the value of s is promoted to
<code>double</code>, and the type of the sub expression is
<code>double</code>.</li>
<li>finally, these three intermediate values,
<code>float, int, and double</code> are considered. The outcome of
<code>float</code> plus an <code>int</code> is a <code>float</code>.
Then the resultant <code>float</code> minus the last double is promoted
to <code>double</code>,</li>
</ul>
</body>
</html>
