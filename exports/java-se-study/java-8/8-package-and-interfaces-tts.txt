Packages

Packages provide a way to organize and compartmentalize a set of classes for a specific purpose. They serve as both a naming system and a visibility control mechanism. By defining classes inside a package, you can restrict access so that some classes are not accessible from outside that package. Additionally, you can define class members that are only visible to other members within the same package.

To create a package, you simply include a package statement as the first line in your Java source file. Any classes declared in that file will belong to the specified package. The package statement defines a namespace for your classes. If you omit the package statement, your classes are placed in the default package, which does not have a name.

Java uses file system directories to store packages. It is important to remember that case matters, and the directory name must match the package name exactly. Multiple files can use the same package statement, which simply indicates that the classes in those files belong to the same package.

You can also create a hierarchy of packages by separating each level with a period. For example, a package statement like “package java.awt.image” creates a hierarchy, and the corresponding files must be stored in a directory structure that matches this hierarchy. On Windows, this would be “java\awt\image”.

By default, the Java runtime system starts searching for packages in the current working directory. If your package is in a subdirectory of the current directory, it will be found. Alternatively, you can specify the directory path or paths by setting the CLASSPATH environment variable. You can also use the dash classpath option with the java and javac commands to specify the path to your classes.

Access

Classes and packages both help encapsulate and control the scope of variables and methods. Packages act as containers for classes and other sub-packages, while classes contain data and code.

A non-nested class in Java has only two possible access levels: default and public. If a class is declared as public, it is accessible from any other code. If a class has default access, it can only be accessed by code within the same package. When a class is public, it must be the only public class in the file, and the file must have the same name as the class.

The following example demonstrates how access modifiers affect visibility:

First, there is a class called ClassOne in package pk1. It has four members: one with default access, one public, one private, and one protected.

Next, ClassTwo is also in package pk1. In its method, it creates an instance of ClassOne. It can access the default and public members, but attempting to access the protected or private members results in a compile-time error.

Then, ClassThree is in a different package, pk2. In its method, it creates an instance of ClassOne. It can only access the public member. Attempts to access the default, protected, or private members all result in compile-time errors.

Finally, ClassFour is in package pk3 and extends ClassTwo. In its method, it can access the public member and, through inheritance, the protected member. However, it cannot access the default or private members, since it is in a different package and private members are always inaccessible outside their own class.

Importing

Java provides the import statement to bring specific classes or entire packages into visibility. Once imported, you can refer to a class directly by its name, without needing to specify its full package path. The import statement is a convenience for the programmer and is not strictly required. If you prefer, you can always use the fully qualified name of a class.

In a Java source file, import statements appear immediately after the package statement, if there is one, and before any class definitions. The general form of the import statement allows you to import a specific class or all classes in a package.

For example, importing java.util.Date allows you to use the Date class directly, and importing java.io with a star brings in all classes from the java.io package.

All standard Java classes are stored in a package called java. The basic language functions are in a subpackage called java.lang. Normally, you must import every package or class you want to use, but java.lang is implicitly imported by the compiler for all programs, since Java would be unusable without it.

If two different packages contain classes with the same name and you import both using the star form, the compiler will not complain until you try to use one of those classes. At that point, you must specify the class’s full package name to resolve the ambiguity.

Interfaces

Using the interface keyword, you can fully separate a class’s interface from its implementation. An interface specifies what a class must do, but not how it does it. Interfaces are similar to classes in syntax, but they do not have instance variables, and their methods are generally declared without a body.

Starting with Java Development Kit 8, it is possible to add a default implementation to an interface method. This means that interfaces can now specify some behavior, but default methods are a special-use feature. The original intent of interfaces—to define a contract without implementation—remains.

Once you have defined an interface, one or more classes can implement it. To do this, include the implements clause in your class definition.

Visibility

By default, all members of an interface are public, and the interface itself is also public. It would not make sense for interface types to have package-private access, as is the case with regular classes and their members when no access modifier is specified.

For example, an interface called PublicAccess is implicitly public, and its method is also implicitly public.

Constants

You can use an interface to group a set of constants that will be used in other classes implementing the interface. By default, constants defined in an interface are implicitly public, static, and final. You do not need to specify these modifiers, and they cannot be changed, since interfaces do not have instance member variables.

Java also allows you to define static methods in an interface, but these have some limitations compared to static members in regular classes.

For example, an interface called SharedConstants defines several integer constants and a static method called compute. A class called ImplementingConstants can use these constants directly, without needing to prefix them with the interface name.

However, this practice is generally discouraged. It is often better to define constants in regular classes and expose them explicitly as public static final.

To access a static constant from an interface that your class implements, you only need to reference its identifier. In contrast, static methods from interfaces are not inherited. You cannot call a static method from an interface using this dot method or just method. Instead, you must prefix the call with the interface name.

For example, in an interface called B, there is a static method named method. In a class called C, which extends another class K and implements interfaces A and B, you cannot call method directly or with this dot method. You must use B dot method. However, you can call static methods inherited from regular classes using this dot another or just another.

Implementing

To implement an interface in a class, you use the implements keyword in the class definition, optionally after an extends clause if the class also extends a superclass. The class body then provides the implementation for the interface’s methods.


Let’s begin by clarifying the relationship between classes and interfaces in object-oriented programming.

Unlike inheritance, where a child class can only extend a single base class, a class can implement any number of interfaces. This is possible because interfaces specify behavior, not state. As a result, the usual problems associated with multiple inheritance are completely avoided.

Now, let’s discuss the diamond problem, also known as the diamond inheritance problem. This issue arises in object-oriented programming languages that allow multiple inheritance. In such cases, a class can inherit from more than one parent class. The problem occurs when a class inherits from two classes, and both of those classes inherit from the same superclass. This creates an inheritance structure that looks like a diamond.

Imagine a scenario where class A is at the top. Classes B and C both inherit from A. Then, class D inherits from both B and C. In this structure, class D ends up inheriting two copies of class A. This leads to ambiguity when calling or using members of class A from class D.

Interfaces offer a solution to this problem. You can use interfaces to import shared constants into multiple classes. To do this, simply declare an interface that contains variables initialized to the desired values. Any class that implements this interface will have access to those constants.

Let’s move on to the concept of extending interfaces.

An interface can be extended to inherit behavior from other interfaces. Unlike class inheritance, where a class can only extend one other class, interfaces can extend multiple other interfaces. This allows for the extension of behavior in a reusable and optimal way.

For example, consider three interfaces: A, B, and C. Interface A declares a method called methodA. Interface B declares a method called methodB. Interface C extends both A and B, and adds its own method called methodC. Any class that implements interface C must provide implementations for all three methods: methodA, methodB, and methodC.

Now, let’s talk about default methods.

With the release of Java Development Kit 8, a new capability was added to interfaces: the default method. A default method allows you to define a default implementation for an interface method. The primary motivation for default methods was to provide a way for interfaces to be expanded without breaking existing code. Remember, all methods defined by an interface must have implementations.

For example, imagine an interface called Sequence. Initially, it defines a method called inspect. Later, two new methods, remove and insert, are added as default methods. A class called Immutable implements Sequence, but only provides an implementation for inspect. Another class, Mutable, implements all three methods. Thanks to default methods, the Immutable class does not break when new methods are added to the interface. The default implementations are used unless the class chooses to override them.

This approach allows you to extend the behavior of an interface without worrying about breaking existing implementations, as long as the new behavior makes sense. If it does not, it is better to create a new interface instead.

Now, let’s discuss some caveats.

As mentioned earlier, multiple inheritance is not allowed in Java. However, a class can implement multiple interfaces. Each interface can have default methods. What happens if a class implements two interfaces, and both provide a default method with the same signature?

If two interfaces provide the same method signature, but the method is not a default implementation, there is no problem. Since interfaces have no instance, the signature from one interface will shadow the other. If the signatures are the same, there is no compile-time error.

However, if both interfaces provide a default implementation for the same method, the class that implements both interfaces must override that method. Otherwise, the compiler will not know which default implementation to use, and a compile-time error will occur.

For example, consider two interfaces, A and B. Both provide default implementations for methods called methodOne and methodTwo. If a class C implements both A and B, it must provide its own implementation of methodOne and methodTwo. If it only overrides methodOne, the compiler will produce an error for methodTwo, because there is no way to resolve which default implementation to use.

In summary, interfaces in Java provide a flexible way to specify behavior, avoid the pitfalls of multiple inheritance, and allow for the extension of functionality through default methods. However, care must be taken when multiple interfaces provide default methods with the same signature. In such cases, the implementing class must resolve the ambiguity by providing its own implementation.


