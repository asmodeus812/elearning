Basic Design

Every non-trivial Java application makes use of data structures and algorithms. The Java Collections Framework provides a large set of general-purpose data structures and algorithms that are ready to use. These data structures and algorithms can work with any suitable data type in a type-safe manner. This is made possible through a language feature called generics.

Generics in Java may feel familiar to those who have used similar concepts in other languages, such as C plus plus. However, while the feature is similar in spirit, its implementation in Java is quite different.

Generics

The general syntax for defining generics and generic types in Java is to wrap any non-primitive type in angle brackets, such as angle bracket T angle bracket. Here, the letter T is just a placeholder. The compiler uses this placeholder during compile time and replaces it with the actual type specified by the user when a generic type is instantiated. The compiler checks that the type matches the definition and adheres to any generic rules, such as T extends K or T super K.

It is important to note that the entire generics feature in Java operates at compile time. Once the class is compiled, the actual generic type information is erased. This approach is different from how some other languages implement generics. Java chose this method to maintain backward compatibility with older versions of the language and to avoid introducing breaking changes at a fundamental level.

For example, consider a class called BoxPrinter that uses a generic type T. The class stores a value of type T, and its constructor and toString method both use this type. When you create an instance of BoxPrinter with a String, the compiler replaces T with String. Similarly, if you create an instance with an Integer, the compiler handles the conversion from a primitive type to Integer automatically, thanks to autoboxing.

The angle bracket T is simply a placeholder used in the class declaration and definition. The example above demonstrates the diamond syntax, which is used in both the declaration and instantiation of generic types.

Generics in Java operate in two stages. The first stage is declaration, where the generic type is defined and its signature is created. The second stage is instantiation, where the diamond syntax specifies the concrete type for the generic class.

This process is similar to how templates work in C plus plus. In C plus plus, the compiler performs a find-and-replace action on the template signature to create a new type for each concrete type used. For example, if you have a BoxPrinter class, the compiler would create one version for Integer and another for String.

Although this is not exactly how generics work in Java, the fundamental idea is similar. The compiler creates multiple unique versions of the type for each unique generic argument, regardless of how many generic arguments a type declares.

To illustrate, imagine two classes: BoxPrinterString, which stores a String, and BoxPrinterInteger, which stores an Integer. Each class has its own member variable for the specific type.

Syntax

As explained earlier, the diamond syntax is used to declare and define generic types in code. It is possible to omit the type in the constructor when creating an instance, making the code less verbose. For example, you can write BoxPrinter of Integer box one equals new BoxPrinter of Integer with one, or simply BoxPrinter of Integer box two equals new BoxPrinter with one. Both are functionally equivalent, as the type is inferred from the left-hand side.

However, if you omit the diamond pattern entirely, the compiler will issue a warning. For example, BoxPrinter box three equals new BoxPrinter of Integer with one tries to declare a non-generic instance, which is not recommended. The language allows this for backward compatibility, and the compiler will treat the type argument as Object when it is omitted.

If you declare BoxPrinter of Integer box five equals new BoxPrinter with one, the compiler will warn about an unchecked cast, since the left side expects Integer but the right side produces BoxPrinter of Object.

Attempting to use BoxPrinter with empty angle brackets on the left side, such as BoxPrinter angle bracket angle bracket box five equals new BoxPrinter of Integer with one, is a compile-time error. The generic placeholder can only be inferred from the left-hand side, not the right.

Raw Types

To maintain backward compatibility, Java allows certain syntaxes when defining generics. If the generic type is not specified, the compiler infers the raw type as Object, which is the top-level type from which all Java types extend. While this is allowed and the code may compile with warnings, you lose all the benefits of compile-time type checking when the actual generic type is not known.

For example, if you declare a List without specifying a type, all methods that return or work on elements of the list will return Object by default. This is not very useful, as you lose compile-time type checking.

Consider the following scenario. You create a List and add two strings to it. If you assign this list to a List of String, the compiler will warn you. If you then try to add an integer to the List of String, the compiler will produce an error. However, if you assign a List of String to a raw List and then add an integer, the code will compile but will throw a runtime exception when you try to use the list as a List of String.

Using raw types is not recommended for these reasons. The worst-case scenario is a runtime exception due to a class cast error. While there are rare situations where raw types might be necessary, in general, it is best to avoid them.

Methods

Just as you can define generic types, you can also define generic methods. Generic methods work similarly to generic types, but there are some differences. If a method is defined in a generic type and uses the type parameter, it is not a generic method by itself; it simply uses the type parameter of the class. A true generic method declares its own type parameter.

Generic methods can be either static or non-static. For example, consider a static method called fill that takes a List of type T and a value of type T. The method sets every element in the list to the given value. In the main method, you can create a List of Integer, add some values, and then call the fill method to set all elements to one hundred.

Both calls to the fill method are semantically identical. It is worth noting that if the list was of raw Object type, you could still enforce stronger type checking by specifying the type in the method call itself, using the class name as a prefix for static methods or the instance name for non-static methods.

This concludes the overview of generics in Java, including their syntax, raw types, and generic methods.


Even though this approach will print all types of warnings, it can be used to ensure that a generic type passed as an argument is treated accordingly, as long as the elements inside the generic are of a known type. For example, you might assign a raw list to an integer list, and then use a method called fill from the LitteralsAndTypes class, specifying Integer as the type, to fill the list with the value one hundred.

The method type is generic, but the type is inferred from the arguments passed in by the compiler. It is not required to specify the type of the arguments. Also, as shown above, if the argument is of a raw type, it is possible to provide the actual type of the generic by explicitly invoking the method with the desired type.

Subtypes

While it is possible to assign a derived type object to its base type reference, for generics, the type parameters must match exactly. Otherwise, a compiler error will occur. In other words, subtyping does not work for generic parameters—they have to match exactly.

Subtyping works for class types. You can assign a derived type object to its base type reference. However, subtyping does not work for generic type parameters. You cannot assign a derived generic type parameter to a base type parameter.

For example, consider this scenario: you attempt to declare a list of numbers and assign it to a new array list of integers. While Number is indeed a valid supertype for Integer, this is not valid when creating generic types and will result in a compiler error. The right-hand side of the expression creates an array list, which internally holds integers. However, the left-hand side assigns it to a less strict type, in this case, Number. If this were allowed, then that intList variable could be used in a context where you could insert any class that extends Number, such as Float. If you then called intList dot add with a new Float, this would produce a class cast exception at runtime, since the actual intList points to an ArrayList instance that holds only integers.

Wildcards

To overcome the issue above, wildcard type parameters are used. They do not specify the exact type in the left-hand side expression. Wildcards can only be used in the left-hand side expression. You cannot instantiate a generic type with a wildcard, since that is meaningless. The right-hand side of the expression must provide a concrete instance of the generic with an exact type, or if none is provided, then the raw type is used by default, which means Object.

Wildcards have a different semantic meaning. They are not a replacement for the raw type or for Object. The wildcard does not tell the compiler that the list holds different types of elements, or is heterogeneous. Instead, the wildcard tells the compiler that the variable references a generic list type of homogeneous elements that can hold any type of argument, such as a list of integers, a list of strings, or a list of floats. This means the underlying generic list instance always contains or references the same type of elements.

Wildcards are not a replacement for Object or raw types. They have a very special meaning. They imply that a variable is referencing a generic of an unknown type, but the instance is still of a generic class and of a specific homogeneous type.

For example, you might declare a wildcard list and assign it to a new array list of integers. If you then try to add an element to this wildcard list, such as the number one, you will get a compile error. This is because the wildcard is unbound. When you use a wildcard type, the code tells the compiler to ignore the type information, so the question mark stands for an unknown type. Every time you try to pass arguments to a generic type, the Java compiler tries to infer the type of the passed-in argument as well as the type of the generics, to ensure type safety. Now, calling the add method to insert an element in the list is not valid, since the variable references a list that holds unknown types, as specified by the wildcard. The compiler does not know which type to infer. That is why it produces an error. If it did not, you might end up adding a string to the list, which would fail at runtime. The compiler tries to be proactive and warn about issues as early as possible, since generics were added to the language to ensure type safety, replacing the old approach of using Object to achieve the same, not to forgo it.

In general, when you provide a wildcard parameter, you cannot call methods that modify the object. There are certain methods that can still be called, which access the object's state. For example, with the list above, methods like get, size, and isEmpty are still valid and can be called safely.

Limitations

There are many limitations of generic types due to type erasure. Here are a few important ones.

First, you cannot instantiate a generic type using the new operator. This is because the compiler does not know what the default constructor for the type T is at the moment of the generic's definition. That is only known when an actual usage of the generic type is in play, that is, when a generic type is instantiated. Remember, the type replacement happens at compile time, not at runtime. After compilation, the resulting bytecode will have the type erased, and there is no way to call a constructor of a type-erased type. If that were allowed at runtime, the expression would literally be new Object, which is not valid. For example, trying to create a new instance of T inside a generic class will result in a compiler error.

Second, you cannot instantiate an array of a generic type. Again, the type replacement happens at compile time, not at runtime. After compilation, the resulting bytecode will have the type erased, and there is no way to call the array constructor for an erased type of unknown type. If that were allowed, it would basically be new Object array of size one hundred. For example, trying to create a new array of T inside a generic class will result in a compiler error.

Third, you can declare instance fields of type T, but not static fields of type T. This is because static members are bound to the class type itself, while generics are bound to a class type instance. There is no notion of an instance for the generic class type definition itself. For example, if you try to declare a static member of type T inside a generic class, the compiler will produce an error.

Fourth, it is not possible to have generic exceptions. The reason is simple: catch statements are evaluated at runtime, and there is no way to specify a catch expression that would be able to capture different types of the generic exception, such as GenericException of String, GenericException of Number, or GenericException of Float. For example, trying to define a generic exception class that extends Throwable will result in a compiler error.

Finally, generics cannot be instantiated from primitive types. For example, List of int or List of short is not valid and would produce a compile-time error.

Summary

The implementation of generics is static in nature. This means that the Java compiler interprets the generics specified in the source code and replaces the generic code with concrete types. This process is called type erasure. After compilation, the code looks similar to what a developer would have written with concrete types. Essentially, the use of generics offers two advantages. First, it introduces an abstraction, which enables you to write generic implementations. Second, it allows you to write generic implementations with type safety.

Collections

In Java eight, the collections framework was greatly overhauled to include the usage of the new generics feature. This allows it to provide a large, reusable set of collection types that are robust and flexible.

Core

The core of the collections framework revolves around a handful of interfaces and abstract classes, which form the building blocks of the entire collections framework.


Java Collections Framework Overview

Let’s begin with an overview of the main interfaces and classes in the Java Collections Framework, focusing on their purpose and how they relate to each other.

The Iterable interface is the foundation. Any class that implements Iterable can be used in a foreach statement, allowing you to loop over its elements easily.

The Collection interface is the common base for most classes in the collection hierarchy. If you want to write methods that are very general and work with any kind of collection, you can use the Collection interface as a parameter. For example, the max method in java dot util dot Collections takes a Collection and returns the largest element.

The List interface is designed for containers that store a sequence of elements. With a List, you can access elements by their index and retrieve the same element later, which means it maintains the order in which elements were inserted. Lists can also store duplicate elements.

Set, SortedSet, and NavigableSet are interfaces for containers that do not allow duplicate elements. SortedSet keeps its elements in a sorted order, while NavigableSet adds the ability to search for the closest matches to a given value.

Queue and Deque are interfaces for containers that hold a sequence of elements for processing. Classes implementing Queue can behave as either LIFO, which stands for last in, first out, like a stack, or FIFO, which stands for first in, first out, like a traditional queue. Deque, which stands for double-ended queue, allows you to insert or remove elements from both ends.

Map, SortedMap, and NavigableMap are interfaces for containers that map keys to values. In a SortedMap, the keys are kept in sorted order. NavigableMap allows you to search and return the closest match for a given search criterion. It’s important to note that the Map hierarchy does not extend the Collection interface.

Iterator and ListIterator are interfaces for traversing containers. If a class implements Iterator, you can move through its elements in the forward direction. If it implements ListIterator, you can traverse both forward and backward.

Now, let’s look at some of the key methods provided by the Collection interface, which is the base for all other collections. These methods define a minimal set of behaviors and actions.

The addAll method adds all the elements from another collection into the current container.

The containsAll method checks if all elements from another collection are present in the current container.

The removeAll method removes all elements from the current container that are also present in another collection.

The retainAll method keeps only those elements in the current container that are also present in another collection, removing all others.

Common Concrete Classes

Next, let’s discuss several of the most well-known and widely used concrete classes from the collections framework. These classes represent the most commonly used data structures in programming.

ArrayList is implemented internally as a resizable array. It is one of the most widely used concrete classes. Searching is fast, but inserting or deleting elements is slow because the underlying array may need to be shifted. ArrayList allows duplicate elements.

LinkedList is implemented as a doubly linked list. It is fast for inserting or deleting elements, but slow for searching. LinkedList can also be used as a stack, which is last in, first out, or as a queue, which is first in, first out. It allows duplicates.

HashSet is implemented as a hash table. It is used for storing a set of elements and does not allow duplicates. Searching and retrieving elements is fast, but the order of elements is not maintained.

TreeSet is implemented as a red-black tree. Like HashSet, it does not allow duplicates, but it stores elements in a sorted order. The position of each element is determined by the sorting order.

HashMap is implemented as a hash table. It stores key and value pairs, using hashing to find where to store or search for a pair. Searching and inserting are very fast, but the elements are not stored in any particular order.

TreeMap is implemented using a red-black tree. Unlike HashMap, TreeMap stores its elements in a sorted order, with the position of each key determined by the sorting order.

PriorityQueue is implemented using a heap data structure. It is used for retrieving elements based on priority. No matter the order in which you insert elements, when you remove them, the highest priority element is retrieved first.

ArrayList in Detail

Let’s take a closer look at ArrayList. This class is used to store a sequence of elements and specifically implements a resizable array. When you create a native array in Java, such as with new String open bracket ten close bracket, the size of the array is fixed at the time of creation. In contrast, an ArrayList is dynamic and can grow in size as needed.

Internally, an ArrayList allocates a block of memory and expands as required. This makes accessing elements by index very fast. However, when you add or remove elements, the rest of the elements may need to be copied or shifted, making addition and deletion relatively costly operations.

For example, you can create a simple ArrayList of strings called languageList. Initially, if you create the ArrayList without specifying a capacity, the internal array is created with a default size of ten. You can then add elements such as "C", "C plus plus", and "Java" to the list.

To iterate over the elements, you can use the basic for-each structure in Java. This is a compile-time construct that gets compiled to use an iterator. It works for all types of collections that implement the iterator pattern and the Iterable interface. In this example, for each language in languageList, you print the language to the console.

This demonstrates how ArrayList provides a flexible and efficient way to store and access a sequence of elements, while also supporting iteration and dynamic resizing.


The iterator approach can also be used. This is equivalent to the for-each loop described earlier, but with manual control over the iteration process. By using the iterator directly, you can call the next method to skip over more than one element, stop the iteration at a specific point, or even use the remove method from the iterator to remove elements from the collection.

In the first example, an iterator is created for a list of languages. The code then loops through the list, retrieving each language and printing it out. This demonstrates how to manually iterate over a collection using an iterator.

The next example shows how you can remove elements from an array while iterating, using the iterator’s remove method. When you create an iterator, the only way to access elements is by calling the next method. However, before calling next, you must check if there is a next element by using hasNext. This is why the typical pattern is to call hasNext, followed by next.

It is important to note that you must call next before calling remove. This requirement is specified in the API documentation for the iterator’s remove method. If you call remove without first calling next, an exception will be thrown. Each call to next moves the iterator to the next element and updates its internal state. Only after this can you safely call remove to delete the current element.

Set

Sets are collections that do not allow duplicate elements. Unlike a List, a Set does not remember the order in which you inserted elements—it is unordered. There are two important concrete classes for Set: HashSet and TreeSet.

A HashSet is designed for quickly inserting and retrieving elements, but it does not maintain any sorting order for the elements it contains. In contrast, a TreeSet stores elements in a sorted order, according to either a compare function or the compareTo method from the Comparable interface.

For example, consider a pangram, which is a sentence that uses every letter of the alphabet at least once. You can break a pangram into its individual characters and store them in a TreeSet. This will automatically sort the characters.

In the example, a string containing a pangram is converted into a character array. Each character is then added to a TreeSet of Character objects. When you print the TreeSet, the characters appear in sorted order, thanks to the TreeSet’s sorting behavior.

To obtain the characters from a string in Java, you can use the toCharArray method, which returns an array of primitive char values. When adding these to a TreeSet, Java automatically converts, or auto-boxes, the primitive chars to Character objects.

Map

A map stores key-value pairs. The Map interface does not extend the Collection interface, but it provides methods that allow you to work with objects from classes that do implement Collection. The method names in Map are similar to those in Collection, making Map easy to understand and use.

There are two important concrete classes of Map: HashMap and TreeMap.

A HashMap uses a hash table data structure internally. Searching in a HashMap is fast. However, a HashMap does not remember the order in which elements were inserted, nor does it keep elements in any sorted order.

A TreeMap, on the other hand, uses a red-black tree data structure. Unlike HashMap, TreeMap keeps elements in sorted order—not in the order of insertion, but in the order defined by the keys. Searching and inserting in a TreeMap is somewhat slower than in a HashMap.

The NavigableMap interface extends the SortedMap interface. The TreeMap class is a widely used implementation of NavigableMap. As the name suggests, NavigableMap provides many methods that make it easy to navigate the map. For example, you can get the nearest value matching a given key, all values less than a given key, all values greater than a given key, and so on.

In the example, a TreeMap is used to store exam scores, with integer keys representing scores and string values representing student names. The map is printed, showing the keys in sorted order. The descendingMap method is then called to produce a new map with the elements in descending order, so higher scores appear first. The tailMap method is used to get all entries with keys greater than forty, which can be used to show students who passed the exam. The firstEntry method retrieves the entry with the lowest score, since the map is sorted in ascending order by default.

Deque

A Deque, pronounced “deck,” is a doubly linked queue. This data structure allows you to insert and remove elements from both ends. The Deque interface was introduced in Java six and extends the Queue interface, so all methods provided by Queue are also available in Deque.

There are three concrete implementations of the Deque interface: LinkedList, ArrayDeque, and LinkedBlockingDeque. The Deque interface provides methods to operate on both ends of the queue, such as addFirst, addLast, removeFirst, and removeLast. These method names are self-explanatory.

In the example, a class called SpecialQueue is defined. It uses an ArrayDeque to store strings. The class provides methods to add a customer to the back of the queue, remove a customer from the front, and remove a customer from the back. This demonstrates how you can use Deque to manage a queue with flexible insertion and removal options.

Comparable

The Comparable interface and its companion, the Comparator interface, provide ways to compare objects. These two interfaces are essential to the internals of the Java Collections framework. Many containers in the library require elements to be either comparable, or for a special comparator to be provided when creating the container. This ensures that elements can be compared when they are inserted, removed, or searched.

The Comparable interface provides a single method, compareTo. This is not a functional interface, but it is meant for types to implement so they can be compared with other types. The compareTo method returns an integer value, which represents three possible states: the left object is greater than the right, the two objects are equal, or the left object is less than the right. These correspond to positive, zero, and negative results, respectively.

For example, the Comparable interface is defined with a method called compareTo that takes an object of type T and returns an integer.

A class called Student implements Comparable for Student objects. The Student class has fields for ID, name, and CGPA. In the compareTo method, only the ID is compared. The specific comparison logic can vary greatly depending on the type of object and the business rules involved. This is why interfaces like Comparable are needed—to allow custom comparison logic based on real-world requirements.

Comparator


The Comparator Interface

The Comparator interface is a companion to Comparable. While Comparable is used to define a natural, default order for objects, Comparator is designed for one-off or custom comparison operations based on specific criteria. For example, if you have a Student class, you might want to sort students alphabetically by name in one situation, or by their grade point average, or GPA, in another. Since a single compareTo method in Comparable cannot handle all these different sorting needs, the Comparator interface exists to fill this gap. 

Comparator is a functional interface, which means you can use it to create various comparison strategies. For instance, you might define a class called CGPAComparator that implements Comparator for Student objects. This class would compare two students based on their CGPA, or cumulative grade point average. You could then use this comparator to sort a list of students according to their CGPA.

The general rule is that most real-world cases have a natural order, so Comparable is usually sufficient. However, when you need customized sorting or ordering, you can use Comparator as a substitute.

Stream

The Stream interface is one of the most important additions in Java 8. There are specialized versions for primitive types, such as DoubleStream, LongStream, and IntStream, which are designed for double, long, and int values, respectively.

Streams in Java operate using what is called a stream pipeline. This pipeline is a sequence of operations chained together on a stream object. These operations transform the data and produce a final result. Each method call in the pipeline adds a transformation, but the actual work is not performed until a terminal operation is invoked. Only then does the pipeline execute all the specified actions, and the final result is produced. Typically, the terminal operation returns the result of the entire transformation pipeline.

For example, consider a class that demonstrates the components of a stream pipeline. In this example, you start by getting all the methods of the Object class. You then create a stream from this array of methods. Next, you map each method to its name, producing a stream of strings. You then call distinct to remove duplicate method names. Finally, you use forEach as a terminal operation to print each unique method name. This example shows how intermediate operations like map and distinct are chained together, and how the terminal operation forEach triggers the execution of the pipeline.

Primitive Streams

As mentioned earlier, primitive types have their own stream interfaces: IntStream, DoubleStream, and LongStream. These do not directly extend from the Stream interface, but from BaseStream. The API for primitive streams is slightly different, since it deals with numeric types. As a result, there are additional methods specific to these types.

To create a primitive stream, there are several commonly used methods. For example, you can generate a stream of integers from a range using methods like range and rangeClosed. The range method creates a stream from a starting value up to, but not including, an end value. The rangeClosed method includes the end value. You can also concatenate two streams using concat, or create a stream from a set of values using the of method.

Another useful method is iterate, which acts like a replacement for a standard for-loop. You provide a starting value and a function to generate the next value. You can also use limit to restrict the number of elements, preventing an infinite loop.

Creating Streams

There are other ways to create streams besides the static utility methods in the Stream or IntStream classes. The Arrays class was enhanced in Java 8 to allow you to create streams from arrays. For example, you can create an IntStream from an array of integers, or a generic Stream from an array of objects.

These methods are actually used internally by the Stream.of methods, which are essentially wrappers around Arrays.stream. For example, you can create a stream from a list of integers using Stream.of, or from an array of Integer objects.

Building Streams

If you know that a collection of items will be immediately used for stream operations, you can use the Stream.Builder interface to construct a stream element by element. The builder interface provides methods like add and accept, both of which add a new element to the stream. Once all elements are added, you call build to create the stream.

Existing Interfaces

Many Java classes provide ways to construct streams directly from their APIs. For example, the Files class can generate a stream of lines from a file. The Pattern class can split a string into a stream of substrings. The Random class can generate a stream of random integers. The String class has a chars method that returns an IntStream of character codes.

It is important to note that the chars method on String returns an IntStream because characters are treated as integers in Java. In fact, they are stored as two-byte values, since Java uses UTF-16 encoding for strings.

Intermediate Operations

Intermediate operations in streams do not consume the stream, but instead refine it. This means that the operations you invoke on a stream object are only executed when a terminal operation is called, such as forEach or collect.

Some common intermediate operations include filter, which removes elements that do not match a given predicate; map, which applies a transformation function to each element; distinct, which removes duplicate elements based on the equals method; sorted, which sorts the elements in their natural order or using a custom comparator; peek, which allows you to perform an action on each element without modifying the stream; and limit, which restricts the number of elements in the stream.

These operations allow you to build powerful and flexible data processing pipelines using streams in Java.


Here is a demonstration of using intermediate operations to mutate a stream in Java. The example shows how you can peek at elements without terminating the stream, and then finally invoke the count method, which does terminate the stream. When you call the count method, it ensures that all other intermediate operations are executed in the order you specified.

In this example, a stream is created from the numbers one through five. Each number is squared using the map operation. The peek operation is then used to print each squared value. Finally, the count method is called, which triggers the execution of all the previous operations and counts the total number of elements in the stream.

Intermediate operations do not produce a result immediately. Instead, they return the original stream object, allowing you to chain more intermediate operations. Importantly, until a terminal operation is invoked, the actions of intermediate operations are never actually executed. The lambda expressions representing these operations are simply stored within the stream. This design allows the stream to optimize certain tasks internally, since the actual execution of actions only happens when the stream is terminated.

Terminal operations

Terminal, or terminating, operations are usually the last operations called on a stream. Before this point, you can call any number of intermediate operations, or none at all. Terminal operations close the stream. This means that if you have a variable referencing the stream object, and you try to use it again after a terminal operation—whether for another intermediate or terminal operation—an exception will be thrown.

Stream objects are typically intended for one-shot transformation pipelines. They are not reusable. Streams are lightweight because they simply wrap around the initial object or collection. They do not copy or clone the elements of that collection. Instead, they provide a way to generate a new collection from the original, containing the transformed elements in some state. Of course, depending on the terminal and intermediate operations you use, entirely new objects might be created. For example, using the map operation can result in new objects after the final terminal operation is called.

Here are some common terminal operations and what they do.

The forEach method takes an action and calls it for every element in the stream.

The toArray method returns an array of objects containing all the elements in the stream.

The min method returns the minimum value in the stream, comparing objects using a provided comparison function.

The max method returns the maximum value in the stream, also using a comparison function.

The count method returns the number of elements in the stream.

Once a stream has been finalized by calling a terminal operation, it is considered consumed. Any attempt to call another operation—whether terminal or intermediate—on that stream will result in an Illegal State Exception.


