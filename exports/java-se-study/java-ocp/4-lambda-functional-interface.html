<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>4-lambda-functional-interface</title>
  <style>
    html {
      font-size: 12pt;
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      overflow-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 12px;
      }
      h1 {
        font-size: 1.8em;
      }
    }
    @media print {
      html {
        background-color: white;
      }
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, Consolas, 'Lucida Console', monospace;
      font-size: 85%;
      margin: 0;
      hyphens: manual;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
      overflow-wrap: normal;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      background-color: #1a1a1a;
      border: none;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC ul {
      padding-left: 1.3em;
    }
    #TOC > ul {
      padding-left: 0;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
    /* CSS for syntax highlighting */
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    .sourceCode { overflow: visible; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {   }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ff0000; font-weight: bold; } /* Alert */
    code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #7d9029; } /* Attribute */
    code span.bn { color: #40a070; } /* BaseN */
    code span.bu { color: #008000; } /* BuiltIn */
    code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4070a0; } /* Char */
    code span.cn { color: #880000; } /* Constant */
    code span.co { color: #60a0b0; font-style: italic; } /* Comment */
    code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #ba2121; font-style: italic; } /* Documentation */
    code span.dt { color: #902000; } /* DataType */
    code span.dv { color: #40a070; } /* DecVal */
    code span.er { color: #ff0000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #40a070; } /* Float */
    code span.fu { color: #06287e; } /* Function */
    code span.im { color: #008000; font-weight: bold; } /* Import */
    code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #007020; font-weight: bold; } /* Keyword */
    code span.op { color: #666666; } /* Operator */
    code span.ot { color: #007020; } /* Other */
    code span.pp { color: #bc7a00; } /* Preprocessor */
    code span.sc { color: #4070a0; } /* SpecialChar */
    code span.ss { color: #bb6688; } /* SpecialString */
    code span.st { color: #4070a0; } /* String */
    code span.va { color: #19177c; } /* Variable */
    code span.vs { color: #4070a0; } /* VerbatimString */
    code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  \usepackage{listings}
  \usepackage{xcolor}

  \lstset{
      basicstyle=\ttfamily,
      backgroundcolor=\color{black!10},
      showspaces=false,
      showstringspaces=false,
      showtabs=false,
      tabsize=2,
      captionpos=b,
      breaklines=true,
      breakautoindent=true,
      linewidth=\textwidth
  }
</head>
<body>
<nav id="TOC" role="doc-toc">
<ul>
<li><a href="#functional-interface"
id="toc-functional-interface">Functional interface</a>
<ul>
<li><a href="#functional" id="toc-functional">Functional</a>
<ul>
<li><a href="#method-references" id="toc-method-references">Method
References</a></li>
<li><a href="#constructor-references"
id="toc-constructor-references">Constructor references</a></li>
</ul></li>
<li><a href="#interfaces" id="toc-interfaces">Interfaces</a>
<ul>
<li><a href="#primitive" id="toc-primitive">Primitive</a></li>
<li><a href="#binary" id="toc-binary">Binary</a></li>
<li><a href="#unary" id="toc-unary">Unary</a></li>
</ul></li>
</ul></li>
<li><a href="#summary" id="toc-summary">Summary</a></li>
</ul>
</nav>
<h1 id="functional-interface">Functional interface</h1>
<p>The java utility function namespace package has numerous built-in
interfaces. Other packages in the Java library make use of these
interfaces defined in this package.</p>
<p><code>Before defining a custom functional interface, consider using an existing one, defined in the util.function package, since most of the functional interfaces there cover a lot of the most common patterns used in lambda design expressions, and can also be shared and used with existing internal java libraries like Stream and so on.</code></p>
<h2 id="functional">Functional</h2>
<p>The table below shows the most commonly used functional interfaces
defined in the <code>java.util.functional</code> package. What is
important to note is that most of them have variations, meaning that
there are different versions of some - e.g <code>IntPredicate</code>,
which is a specialization of the predicate functional lambda interface,
for integral conditions and is used in <code>IntStream</code>. Another
example is the <code>UnaryOperator</code>, which is a specialization for
Function lambda functional interface, which takes and returns only one
singular result</p>
<table>
<colgroup>
<col style="width: 6%" />
<col style="width: 93%" />
</colgroup>
<thead>
<tr class="header">
<th>Method</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Predicate&lt;&gt;</td>
<td>Checks a condition and returns a boolean value as result In filter()
method in java.util.stream.Stream which is used to remove elements in
the stream that don’t match the given condition (i.e., predicate) as
argument.</td>
</tr>
<tr class="even">
<td>Consumer&lt;&gt;</td>
<td>Operation that takes an argument but returns nothing In forEach()
method in collections and in java.util.stream.Stream; this method is
used for traversing all the elements in the collection or stream.</td>
</tr>
<tr class="odd">
<td>Function&lt;, R&gt;</td>
<td>Functions that take an argument and return a result In map() method
in java.util.stream.Stream to transform or operate on the passed value
and return a result.</td>
</tr>
<tr class="even">
<td>Supplier&lt;&gt;</td>
<td>Operation that returns a value to the caller (the returned value
could be same or different values)</td>
</tr>
</tbody>
</table>
<p>The interface method names for these functional interfaces are rather
easy to remember since they extend off of the name of the interface
itself.</p>
<ul>
<li><code>Predicate</code> - boolean test(T t) - execute the actual
predicate action and return a boolean result, based on the target
argument</li>
<li><code>Consumer</code> - void accept(T t) - no result is returned,
but some action is executed on the target argument</li>
<li><code>Function</code> - R apply(T t) - apply action based on the
target argument, and return a new result of new type</li>
<li><code>Supplier</code> - T get() - simply return a result, without
accepting any external argument</li>
</ul>
<h3 id="method-references">Method References</h3>
<p>Most of the common implementations work by using function references
from existing libraries and APIs, to leverage the usage of the
functional interfaces the best, for example</p>
<div class="sourceCode" id="cb1"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="co">// predicate using the String::isEmpty, function reference, the argument of the predicate will be each string entry in</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="co">// the stream, the result, will be calling isEmpty on each of them, which returns boolean</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>Stream<span class="op">.</span><span class="fu">of</span><span class="op">(</span><span class="st">&quot;&quot;</span><span class="op">,</span> <span class="st">&quot;non-empty&quot;</span><span class="op">)</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">.</span><span class="fu">removeIf</span><span class="op">(</span><span class="bu">String</span><span class="op">::</span>isEmpty<span class="op">)</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">.</span><span class="fu">forEach</span><span class="op">(</span><span class="bu">System</span><span class="op">.</span><span class="fu">out</span><span class="op">::</span>println<span class="op">);</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="co">// consumer using the standard out println, which returns no result, however takes in at least one argument, to print</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="co">// out the elements of the stream in this case</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>Stream<span class="op">.</span><span class="fu">of</span><span class="op">(</span><span class="st">&quot;hello&quot;</span><span class="op">,</span> <span class="st">&quot;world&quot;</span><span class="op">)</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>    <span class="op">.</span><span class="fu">forEach</span><span class="op">(</span><span class="bu">System</span><span class="op">.</span><span class="fu">out</span><span class="op">::</span>println<span class="op">);</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a><span class="co">// function which maps a string to int, by leveraging the parseInt method, from Integer, which takes in one type of</span></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a><span class="co">// argument, String in this case, and returns another one, Integer, or throws if parsing fails</span></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a><span class="bu">Arrays</span><span class="op">.</span><span class="fu">stream</span><span class="op">(</span><span class="st">&quot;4, -9, 16&quot;</span><span class="op">.</span><span class="fu">split</span><span class="op">(</span><span class="st">&quot;, &quot;</span><span class="op">))</span></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>    <span class="op">.</span><span class="fu">map</span><span class="op">(</span><span class="bu">Integer</span><span class="op">::</span>parseInt<span class="op">)</span></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>    <span class="op">.</span><span class="fu">map</span><span class="op">(</span>i <span class="op">-&gt;</span> <span class="op">(</span>i <span class="op">&lt;</span> <span class="dv">0</span><span class="op">)</span> <span class="op">?</span> <span class="op">-</span>i <span class="op">:</span> i<span class="op">)</span></span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a>    <span class="op">.</span><span class="fu">forEach</span><span class="op">(</span><span class="bu">System</span><span class="op">.</span><span class="fu">out</span><span class="op">::</span>println<span class="op">);</span></span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a><span class="co">// supplier, which is in this case a function without any input arguments however it generates something on the output,</span></span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a><span class="co">// in this case on each call to nextBoolean, a new random boolean value will be generated</span></span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a><span class="bu">Random</span> random <span class="op">=</span> <span class="kw">new</span> <span class="bu">Random</span><span class="op">();</span></span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a>Stream<span class="op">.</span><span class="fu">generate</span><span class="op">(</span>random<span class="op">::</span>nextBoolean<span class="op">)</span></span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a>    <span class="op">.</span><span class="fu">limit</span><span class="op">(</span><span class="dv">2</span><span class="op">)</span></span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true" tabindex="-1"></a>    <span class="op">.</span><span class="fu">forEach</span><span class="op">(</span><span class="bu">System</span><span class="op">.</span><span class="fu">out</span><span class="op">::</span>println<span class="op">);</span></span></code></pre></div>
<p><code>Note that the examples above use function references, which is another feature which is a corner stone of the lambda and function interface feature in Java 8, which inter operates very well with streams, those three, combine effortlessly to achieve very clean and non aggressively verbose functional style of code expression</code></p>
<p>Something to take away from, is the usage of <code>instance</code>
methods as function references, such as <code>String::isEmpty</code> and
<code>random::nextBoolean</code>, both of those methods are
<code>instance</code> methods, however in the example with the String,
the implicit <code>this</code> argument is passed in as the first
argument to <code>isEmpty</code> which allows us to reference an
instance method, by not referencing any instance at all, the
<code>instance</code> is each entry in the stream for which the method
will be called, and the signature matches the <code>predicate</code>
interface - <code>boolean test(String this)</code></p>
<p>However with the <code>random::nextBoolean</code>, the instance
reference is in the declaration, therefore the first argument to
<code>nextBoolean</code> will be the <code>random</code> instance
variable. Therefore the signature matches the <code>supplier</code>
interface - <code>Boolean get()</code></p>
<p>The example with Integer:parseInt, matches the functional interface
of Function, however parseInt is a static final method in the Integer
class, and in this case no instance method is invoked, the first
argument to parseInt is String, the output is Integer, it is as simple
as that, it matches the <code>function</code> interface -
<code>Integer apply(String int)</code></p>
<p>The difference is subtle, but this feature is very powerful, however
sometimes hard to get right, or read.</p>
<h3 id="constructor-references">Constructor references</h3>
<p>The constructor references for any class are not any different than
regular method references, in fact they very much are like static
methods, they are not methods that take a reference to
<code>this</code>, since they are not instance methods. Constructors
take any number of arguments, usually none, but sometimes one or more
than one, the return of the constructor is obviously the actual class
instance or an object of the class type.</p>
<div class="sourceCode" id="cb2"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>Supplier<span class="op">&lt;</span><span class="bu">String</span><span class="op">&gt;</span> newString <span class="op">=</span> <span class="bu">String</span><span class="op">::</span><span class="kw">new</span><span class="op">;</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="bu">System</span><span class="op">.</span><span class="fu">out</span><span class="op">.</span><span class="fu">println</span><span class="op">(</span>newString<span class="op">.</span><span class="fu">get</span><span class="op">());</span></span></code></pre></div>
<p>The example above shows how a class constructor can be mapped to an
existing functional interface from the java.util package, in this case
it matches against the supplier functional interface. With a method
reference using <code>::new</code> this lambda expression gets
simplified as <code>String::new</code>.</p>
<h2 id="interfaces">Interfaces</h2>
<p>Below are listed some of the most important functional interfaces
provided in the <code>java.util.function</code>, those extend the core
four ones, with different capabilities, which are useful for different
contexts, mainly trying to create all possible cases and combinations
between raw class types and raw primitive types</p>
<h3 id="primitive">Primitive</h3>
<p>There are primitive versions of the functional interface classes
provided by <code>java.util</code>, these are created to be able to deal
with the primitive versions of the stream types like
<code>IntStream</code> and <code>DoubleStream</code> for example, here
is a table with the list of primitive functional interfaces</p>
<table>
<colgroup>
<col style="width: 37%" />
<col style="width: 62%" />
</colgroup>
<thead>
<tr class="header">
<th>Method</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>IntPredicate boolean test(int value)</td>
<td>Evaluates the condition passed as int and returns a boolean value as
result</td>
</tr>
<tr class="even">
<td>LongPredicate boolean test(long value)</td>
<td>Evaluates the condition passed as long and returns a boolean value
as result</td>
</tr>
<tr class="odd">
<td>DoublePredicate boolean test(double value)</td>
<td>Evaluates the condition passed as double and returns a boolean value
as result</td>
</tr>
<tr class="even">
<td>—————————————————-</td>
<td>————————————————————————————-</td>
</tr>
<tr class="odd">
<td>IntFunction&lt;&gt; R apply(int value)</td>
<td>Operates on the passed int argument and returns value of generic
type R</td>
</tr>
<tr class="even">
<td>LongFunction&lt;&gt; R apply(long value)</td>
<td>Operates on the passed long argument and returns value of generic
type R</td>
</tr>
<tr class="odd">
<td>DoubleFunction&lt;&gt; R apply(double value)</td>
<td>Operates on the passed double argument and returns value of generic
type R</td>
</tr>
<tr class="even">
<td>ToIntFunction&lt;&gt; int applyAsInt(T value)</td>
<td>Operates on the passed generic type argument T and returns an int
value</td>
</tr>
<tr class="odd">
<td>ToLongFunction&lt;&gt; long applyAsLong(T value)</td>
<td>Operates on the passed generic type argument T and returns a long
value</td>
</tr>
<tr class="even">
<td>ToDoubleFunction&lt;&gt; double applyAsDouble(T value)</td>
<td>Operates on the passed generic type argument T and returns an double
value</td>
</tr>
<tr class="odd">
<td>IntToLongFunction long applyAsLong(int value)</td>
<td>Operates on the passed int type argument and returns a long
value</td>
</tr>
<tr class="even">
<td>IntToDoubleFunction double applyAsDouble(int value)</td>
<td>Operates on the passed int type argument and returns a double
value</td>
</tr>
<tr class="odd">
<td>LongToIntFunction int applyAsInt(long value)</td>
<td>Operates on the passed long type argument and returns an int
value</td>
</tr>
<tr class="even">
<td>LongToDoubleFunction double applyAsLong(long value)</td>
<td>Operates on the passed long type argument and returns a double
value</td>
</tr>
<tr class="odd">
<td>DoubleToIntFunction int applyAsInt(double value)</td>
<td>Operates on the passed double type argument and returns an int
value</td>
</tr>
<tr class="even">
<td>DoubleToLongFunction long applyAsLong(double value)</td>
<td>Operates on the passed double type argument and returns a long
value</td>
</tr>
<tr class="odd">
<td>—————————————————-</td>
<td>————————————————————————————-</td>
</tr>
<tr class="even">
<td>IntConsumer void accept(int value)</td>
<td>Operates on the given int argument and returns nothing</td>
</tr>
<tr class="odd">
<td>LongConsumer void accept(long value)</td>
<td>Operates on the given long argument and returns nothing</td>
</tr>
<tr class="even">
<td>DoubleConsumer void accept(double value)</td>
<td>Operates on the given double argument and returns nothing</td>
</tr>
<tr class="odd">
<td>ObjIntConsumer&lt;&gt; void accept(T t, int value)</td>
<td>Operates on the given generic type argument T and int arguments and
returns nothing</td>
</tr>
<tr class="even">
<td>ObjLongConsumer&lt;&gt; void accept(T t, long value)</td>
<td>Operates on the given generic type argument T and long arguments and
returns nothing</td>
</tr>
<tr class="odd">
<td>ObjDoubleConsumer&lt;&gt; void accept(T t, double value)</td>
<td>Operates on the given generic type argument T and double arguments
and returns nothing</td>
</tr>
<tr class="even">
<td>—————————————————-</td>
<td>————————————————————————————-</td>
</tr>
<tr class="odd">
<td>BooleanSupplier boolean getAsBoolean()</td>
<td>Takes no arguments and returns a boolean value</td>
</tr>
<tr class="even">
<td>IntSupplier int getAsInt()</td>
<td>Takes no arguments and returns an int value</td>
</tr>
<tr class="odd">
<td>LongSupplier long getAsLong()</td>
<td>Takes no arguments and returns a long value</td>
</tr>
<tr class="even">
<td>DoubleSupplier double getAsDouble()</td>
<td>Takes no arguments and returns a double value</td>
</tr>
</tbody>
</table>
<div class="sourceCode" id="cb3"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="co">// in this example the predicate function is passed to the filter intermediate stream function, the predicate here is of</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="co">// the functional interface type `IntPredicate`</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>IntStream<span class="op">.</span><span class="fu">range</span><span class="op">(</span><span class="dv">1</span><span class="op">,</span> <span class="dv">10</span><span class="op">).</span><span class="fu">filter</span><span class="op">(</span>i <span class="op">-&gt;</span> <span class="op">(</span>i <span class="op">%</span> <span class="dv">2</span><span class="op">)</span> <span class="op">==</span> <span class="dv">0</span><span class="op">).</span><span class="fu">forEach</span><span class="op">(</span><span class="bu">System</span><span class="op">.</span><span class="fu">out</span><span class="op">.</span><span class="fu">println</span><span class="op">);</span></span></code></pre></div>
<h3 id="binary">Binary</h3>
<p>The <code>binary</code> interfaces from <code>java.util</code> simply
expand the already existing pattern of other functional interfaces, the
idea behind this is that to add one additional input argument to all of
the existing functional interfaces - Consumer, Function, Consumer,
converting them into a binary or bi functional interfaces where the
actual signature of the functional interface remains unchanged, simply
an additional argument is added</p>
<table>
<colgroup>
<col style="width: 33%" />
<col style="width: 66%" />
</colgroup>
<thead>
<tr class="header">
<th>Method</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>BiPredicate&lt;, U&gt; boolean test(T t, U u)</td>
<td>Checks if the arguments match the condition and returns a boolean
value as result</td>
</tr>
<tr class="even">
<td>BiConsumer&lt;, U&gt; void accept(T t, U u)</td>
<td>Operation that consumes two arguments but returns nothing</td>
</tr>
<tr class="odd">
<td>BiFunction&lt;, U, R&gt; R apply(T t, U u)</td>
<td>Function that takes two argument and returns a result</td>
</tr>
</tbody>
</table>
<p>As shown above the interface remains the same, meaning the method
names are unchanged, however they are now expanded with one additional
argument</p>
<h3 id="unary">Unary</h3>
<p>The <code>unary</code> functional interfaces is a variation or
specialization of the Function functional interface, it simply marks all
input and output type to be of one and the same type
<code>&lt;T&gt;</code> the signature of the unary functional interface
looks like so -
<code>UnaryOperator&lt;T&gt; extends Function&lt;T, T&gt;</code></p>
<table>
<colgroup>
<col style="width: 26%" />
<col style="width: 73%" />
</colgroup>
<thead>
<tr class="header">
<th>Method</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>UnaryOperator&lt;&gt; T accept(T t)</td>
<td>Function that takes one argument of the same type and produces
result of the same type</td>
</tr>
</tbody>
</table>
<p><code>The entirety of the java.util.function packages consists of only functional interfacse. There are only four core interfaces in this package - Predicate, Consumer, Function &amp; Supplier. The rest of the interfaces are primitive versions, binary versions and derived interfaces such as UnaryOperator interfaces. These interfaces differ mainly on the signature of the abstract methods they declare.</code></p>
<h1 id="summary">Summary</h1>
<p>Built-in interfaces</p>
<ul>
<li><p>Built-in functional interfaces Predicate, Consumer, Function, and
Supplier differ mainly based on the signature of the abstract method
they declare.</p></li>
<li><p>A Predicate tests the given condition and returns true or false;
hence it has an abstract method named “test” that takes a parameter of
generic type T and returns boolean type.</p></li>
<li><p>A Consumer “consumes” an object and returns nothing; hence it has
an abstract method named “accept” that takes an argument of generic type
T and has return type void.</p></li>
<li><p>A Function “operates” on the argument and returns a result; hence
it has an abstract method named “apply” that takes an argument of
generic type T and has generic return type R.</p></li>
<li><p>A Supplier “supplies” takes nothing but returns something; hence
it has an abstract method named “get” that takes no arguments and
returns a generic type T.</p></li>
<li><p>The forEach() method defined in <code>Iterable</code>
(implemented by collection classes) method accepts a
Consumer<T>.</p></li>
</ul>
<p>Primitive versions</p>
<ul>
<li><p>The built-in interfaces Predicate, Consumer, Function, and
Supplier operate on reference type objects. For primitive types, there
are specializations available for int, long, and double types for these
functional interfaces.</p></li>
<li><p>When the Stream interface is used with primitive types, it
results in unnecessary boxing and unboxing of the primitive types to
their wrapper types. This results in slower code as well as wastes
memory because the unnecessary wrapper objects get created. Hence,
whenever possible, prefer using the primitive type specializations of
the functional interfaces Predicate, Consumer, Function, and
Supplier.</p></li>
<li><p>The primitive versions of the functional interfaces Predicate,
Consumer, Function, and Supplier are available only for int, long and
double types (and boolean type in addition to these three types for
Supplier). You have to use implicit conversions to relevant int version
when you need to use char, byte, or short types; similarly, you can use
the version for double type when you need to use float. Develop code
that uses binary versions of functional interfaces</p></li>
<li><p>The functional interfaces <code>BiPredicate</code>,
<code>BiConsumer</code>, and <code>BiFunction</code> are binary versions
of Predicate, Consumer, and Function respectively. There is no binary
equivalent for Supplier since it does not take any arguments. The prefix
“Bi” indicates the version that takes “two” arguments.</p></li>
</ul>
<p>Unary versions</p>
<ul>
<li><p>is a functional interface and it extends Function
interface.</p></li>
<li><p>primitive type specializations of <code>UnaryOperator</code> are
<code>IntUnaryOperator</code>, <code>LongUnaryOperator</code>, and
<code>DoubleUnaryOperator</code> for int, long, and double types
respectively.</p></li>
</ul>
</body>
</html>
