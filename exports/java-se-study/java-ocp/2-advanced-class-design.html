<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>2-advanced-class-design</title>
  <style>
    html {
      font-size: 12pt;
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      overflow-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 12px;
      }
      h1 {
        font-size: 1.8em;
      }
    }
    @media print {
      html {
        background-color: white;
      }
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, Consolas, 'Lucida Console', monospace;
      font-size: 85%;
      margin: 0;
      hyphens: manual;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
      overflow-wrap: normal;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      background-color: #1a1a1a;
      border: none;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC ul {
      padding-left: 1.3em;
    }
    #TOC > ul {
      padding-left: 0;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
    /* CSS for syntax highlighting */
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    .sourceCode { overflow: visible; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {   }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ff0000; font-weight: bold; } /* Alert */
    code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #7d9029; } /* Attribute */
    code span.bn { color: #40a070; } /* BaseN */
    code span.bu { color: #008000; } /* BuiltIn */
    code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4070a0; } /* Char */
    code span.cn { color: #880000; } /* Constant */
    code span.co { color: #60a0b0; font-style: italic; } /* Comment */
    code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #ba2121; font-style: italic; } /* Documentation */
    code span.dt { color: #902000; } /* DataType */
    code span.dv { color: #40a070; } /* DecVal */
    code span.er { color: #ff0000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #40a070; } /* Float */
    code span.fu { color: #06287e; } /* Function */
    code span.im { color: #008000; font-weight: bold; } /* Import */
    code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #007020; font-weight: bold; } /* Keyword */
    code span.op { color: #666666; } /* Operator */
    code span.ot { color: #007020; } /* Other */
    code span.pp { color: #bc7a00; } /* Preprocessor */
    code span.sc { color: #4070a0; } /* SpecialChar */
    code span.ss { color: #bb6688; } /* SpecialString */
    code span.st { color: #4070a0; } /* String */
    code span.va { color: #19177c; } /* Variable */
    code span.vs { color: #4070a0; } /* VerbatimString */
    code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  \usepackage{listings}
  \usepackage{xcolor}

  \lstset{
      basicstyle=\ttfamily,
      backgroundcolor=\color{black!10},
      showspaces=false,
      showstringspaces=false,
      showtabs=false,
      tabsize=2,
      captionpos=b,
      breaklines=true,
      breakautoindent=true,
      linewidth=\textwidth
  }
</head>
<body>
<nav id="TOC" role="doc-toc">
<ul>
<li><a href="#advanced-design" id="toc-advanced-design">Advanced
design</a>
<ul>
<li><a href="#abstract" id="toc-abstract">Abstract</a></li>
<li><a href="#final" id="toc-final">Final</a>
<ul>
<li><a href="#classes" id="toc-classes">Classes</a></li>
<li><a href="#methods" id="toc-methods">Methods</a></li>
<li><a href="#variables" id="toc-variables">Variables</a></li>
</ul></li>
<li><a href="#nested-classes" id="toc-nested-classes">Nested classes</a>
<ul>
<li><a href="#static-inner-classes" id="toc-static-inner-classes">Static
inner classes</a></li>
<li><a href="#inner-classes" id="toc-inner-classes">Inner
classes</a></li>
<li><a href="#local-classes" id="toc-local-classes">Local
classes</a></li>
<li><a href="#anonymous-classes" id="toc-anonymous-classes">Anonymous
classes</a></li>
</ul></li>
<li><a href="#enums" id="toc-enums">Enums</a></li>
<li><a href="#interfaces" id="toc-interfaces">Interfaces</a>
<ul>
<li><a href="#diamond-pattern" id="toc-diamond-pattern">Diamond
pattern</a></li>
<li><a href="#functional-interfaces"
id="toc-functional-interfaces">Functional interfaces</a></li>
<li><a href="#lambda-expression" id="toc-lambda-expression">Lambda
expression</a></li>
</ul></li>
</ul></li>
<li><a href="#summary" id="toc-summary">Summary</a></li>
</ul>
</nav>
<h1 id="advanced-design">Advanced design</h1>
<p>A significant portion of the questions is usually related to changes
introduced in the Java language and the library in java 8. This chapter
covers lambda expression, which form the foundation for understanding
Streams and the new facilities available in the Java 8 release</p>
<h2 id="abstract">Abstract</h2>
<p>They provide a way to specify an abstraction, without prodviding
implementation details, an abstract class can be more suitable in
certain cases instead of interfaces, since they can provide not only
behavior (like interfaces) but also the abstraction semantics as well.
An abstract class defines a common functionality and also a more
stringent definition, for the type.</p>
<div class="sourceCode" id="cb1"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">abstract</span> <span class="kw">class</span> <span class="bu">Shape</span> <span class="op">{</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">abstract</span> <span class="dt">int</span> <span class="fu">area</span><span class="op">();</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Abstract classes can not be initialized, and they are defined by the
keyword abstract, in the class declaration as well as at least one
abstract method, which must not have an implementation, if an
implementation for that method marked as abstract is provided, the
compiler will issue an error.</p>
<p><code>If a class is defined as abstract but has not a single abstract non-implemented method, it is compile time error, if a class is not defined abstract and has an abstract non-implemented method, this is also a compile time error, also an abstract class can not be declared both abstract &amp; final</code></p>
<p>An abstract class can extend off of another abstract class as long as
the rules above remain met. Meaning that the extending abstract class
must at least leave out one abstract method not implemented</p>
<h2 id="final">Final</h2>
<p>The final keyword, can be applied to classes, method and variables.
As already mentioned final classes can not be extended off of. Final
methods can not be overridden and final variables can not be
re-assigned.</p>
<h3 id="classes">Classes</h3>
<p>Declaring a class as final has several benefits, which are usually
overlooked, but are very well quite important</p>
<ul>
<li><p>Discussed in the immutability chapter, it is a good idea to
define a class <code>final</code> to make sure that it is never
sub-classes, which would in turn make sure that the behavior of the
class is never changed, in a way sealing the class from any external 3rd
party interference, which might misuse the interface.</p></li>
<li><p>Added performance - since the compiler sees that the class is
final, meaning that it can not be sub-classed, that can be used to
optimize the calls to the member methods of the class. This is because
for a final class there is no way to have dynamic
<code>polymorphism</code> (late binding), therefore the calls to the
methods can be optimized out during byte code generation.</p></li>
</ul>
<h3 id="methods">Methods</h3>
<p>A final method has a similar behavior to a final class, it prevents
the method from being overridden, which can be used to guarantee that a
certain behavior from a super class is never changed, to ensure certain
functionality is not mutated by mistake.</p>
<h3 id="variables">Variables</h3>
<p>The final variables are mostly used when dealing with immutable
classes, they are very useful way to make sure that a member variable is
never re-assigned. A final variable can be assgined only once. This is
usually done in two places, either in the constructor (all constructors,
that are defined for a given class) or along side the variable
declaration. If a final variable is not assigned, it will lead to
compile time error.</p>
<h2 id="nested-classes">Nested classes</h2>
<p>A nested class is such a class that is defined in an enclosing class.
There are four types of nested classes</p>
<h3 id="static-inner-classes">Static inner classes</h3>
<p>These classes are defined in a static context bound to the class type
itself. There are several rules on how they can be used and what they
can access from the enclosing class or type.</p>
<ul>
<li><p>Every static inner nested class is associated
<code>with the enclosing class type itself</code>.</p></li>
<li><p>The accessibility of the static class is defined by the outer
class - meaning that even if the static inner class is defined as
public, if the outer class is package protected / default access, then
the static inner class will not be publicly accessible, even though it
has a public modifier</p></li>
<li><p>The name of the inner static class is expressed inthe context of
the wrapping outer class name - meaning that to use the nested static
inner class one has to use the following syntax -
<code>uOuterClassName.InnerClassName</code> it is also possible to
staticly import the inner class, to avoid this long expression of class
name chaining</p></li>
<li><p>When a inner static class or interface is defined inside an
enclosing interface they are defined as implicitly static, there is no
way to define a local inner class or interface inside an interface, for
the obvious reasons, the same is NOT true for abstract classes
however.</p></li>
<li><p>Static nested classes can be declared abstract or final, they can
also be used as base classes for other clases, or they can also extend
off of another class type, even the enclosing one they are in</p></li>
<li><p>Static nested classes can have static members, which is not true
for all types of nested classes.</p></li>
<li><p>Static nested classes can ONLY access static members of the
enclosing class, however if the static inner class has a reference to an
instance object of the enclosing class it can access its members, no
matter the access modifier - private or otherwise.</p></li>
<li><p>Enclosing classes can access the static members of the inner
static class, and also if they have a reference to an instance of the
inner static class, their member variables, irrespective of the access
modifiers - private or otherwise</p></li>
<li><p>To instantiate a static inner class one has to use the following
syntax, referencing the outer class name first then the static member
class -
<code>OuterClassName.InnerClassName instance = new OuterClassName.InnerClassName()</code></p></li>
</ul>
<p>An example of the relationship between the Outer and Inner static
classes</p>
<div class="sourceCode" id="cb2"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span> <span class="kw">class</span> Outer <span class="op">{</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">private</span> <span class="dt">static</span> <span class="dt">final</span> <span class="dt">int</span> outerStaticMember <span class="op">=</span> <span class="dv">5</span><span class="op">;</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">private</span> <span class="dt">int</span> outerMember<span class="op">;</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">private</span> Inner outerInstance<span class="op">;</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="fu">Outer</span><span class="op">()</span> <span class="op">{</span></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>        <span class="co">// create the instance of the inner static class passing current instance as reference</span></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>        outerInstance <span class="op">=</span> <span class="kw">new</span> <span class="fu">Inner</span><span class="op">(</span><span class="kw">this</span><span class="op">);</span></span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a>        <span class="co">// this is also valid access to a private member of the inner class</span></span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> k <span class="op">=</span> outerInstance<span class="op">.</span><span class="fu">innerMember</span><span class="op">;</span></span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="dt">static</span> <span class="kw">class</span> Inner <span class="op">{</span></span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-18"><a href="#cb2-18" aria-hidden="true" tabindex="-1"></a>        <span class="kw">private</span> <span class="dt">static</span> <span class="dt">final</span> <span class="dt">int</span> innerStaticMember <span class="op">=</span> <span class="dv">5</span><span class="op">;</span></span>
<span id="cb2-19"><a href="#cb2-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-20"><a href="#cb2-20" aria-hidden="true" tabindex="-1"></a>        <span class="kw">private</span> <span class="dt">int</span> innerMember<span class="op">;</span></span>
<span id="cb2-21"><a href="#cb2-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-22"><a href="#cb2-22" aria-hidden="true" tabindex="-1"></a>        <span class="kw">private</span> Outer innerInstance<span class="op">;</span></span>
<span id="cb2-23"><a href="#cb2-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-24"><a href="#cb2-24" aria-hidden="true" tabindex="-1"></a>        <span class="kw">public</span> <span class="fu">Inner</span><span class="op">(</span>Outer outer<span class="op">)</span> <span class="op">{</span></span>
<span id="cb2-25"><a href="#cb2-25" aria-hidden="true" tabindex="-1"></a>            <span class="co">// assign the inner instance the reference to the outer one</span></span>
<span id="cb2-26"><a href="#cb2-26" aria-hidden="true" tabindex="-1"></a>            <span class="kw">this</span><span class="op">.</span><span class="fu">innerInstance</span> <span class="op">=</span> outer<span class="op">;</span></span>
<span id="cb2-27"><a href="#cb2-27" aria-hidden="true" tabindex="-1"></a>            <span class="co">// this is valid access of the member of the outer class as long as there is an instance to use reference</span></span>
<span id="cb2-28"><a href="#cb2-28" aria-hidden="true" tabindex="-1"></a>            <span class="dt">int</span> k <span class="op">=</span> <span class="kw">this</span><span class="op">.</span><span class="fu">innerInstance</span><span class="op">.</span><span class="fu">outerMember</span><span class="op">;</span></span>
<span id="cb2-29"><a href="#cb2-29" aria-hidden="true" tabindex="-1"></a>            <span class="co">// this is also a valid reference to the outer static member which requires no instance reference</span></span>
<span id="cb2-30"><a href="#cb2-30" aria-hidden="true" tabindex="-1"></a>            <span class="kw">this</span><span class="op">.</span><span class="fu">innerMember</span> <span class="op">=</span> Outer<span class="op">.</span><span class="fu">outerStaticMember</span><span class="op">;</span></span>
<span id="cb2-31"><a href="#cb2-31" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb2-32"><a href="#cb2-32" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb2-33"><a href="#cb2-33" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb2-34"><a href="#cb2-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-35"><a href="#cb2-35" aria-hidden="true" tabindex="-1"></a><span class="co">// creating an instance of the inner class can be done by simply the Outer.Inner to create the instance. Note that the</span></span>
<span id="cb2-36"><a href="#cb2-36" aria-hidden="true" tabindex="-1"></a><span class="co">// InnerClassName has to be visible, if the OuterClassName is defined as package private (default access) the</span></span>
<span id="cb2-37"><a href="#cb2-37" aria-hidden="true" tabindex="-1"></a><span class="co">// InnerClassName will not be visible if the OuterClassName is not visible</span></span>
<span id="cb2-38"><a href="#cb2-38" aria-hidden="true" tabindex="-1"></a>Outer<span class="op">.</span><span class="fu">Inner</span> innerInstance <span class="op">=</span> <span class="kw">new</span> Outer<span class="op">.</span><span class="fu">Inner</span><span class="op">();</span></span></code></pre></div>
<h3 id="inner-classes">Inner classes</h3>
<p>These are a specialized case of the static inner class, where the
inner class is defined as non-static member inside another class. The
most important difference for the non-static inner class, compared to
the static one is that the instance in this case is not bound to the
Class type itself, but to every instance of that class. Each instance of
the class has its own instance of the non-static inner class</p>
<ul>
<li><p>Every non-static inner nested class is associated with
<code>an instance of the enclosing class type</code>. Which is different
than the static inner class, which is bound to the class type definition
itself, see above.</p></li>
<li><p>The inner class can access the members (non static ones) of the
enclosing class without needing a reference to an instance of the
enclosing class, this is because the inner non-static nested class is
bound to the instance of a class not the class itself, see
above.</p></li>
<li><p>The outer class can not access member variables of the nested
inner class without declaring an instance of it, obviously.</p></li>
<li><p>The inner non-static class can not have static members defined,
this is due to the fact that the class type definition itself is tied to
an instance of the enclosing outer class, and since static members are
bound to the class type not an instance,
<code>the inner class type definition does not exist independently of the outer class instance</code>.</p></li>
</ul>
<div class="sourceCode" id="cb3"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span> <span class="kw">class</span> Outer <span class="op">{</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">private</span> <span class="dt">static</span> <span class="dt">final</span> <span class="dt">int</span> outerStaticMember <span class="op">=</span> <span class="dv">5</span><span class="op">;</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">private</span> <span class="dt">int</span> outerMember<span class="op">;</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">private</span> Inner outerInstance<span class="op">;</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="fu">Outer</span><span class="op">()</span> <span class="op">{</span></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>        <span class="co">// create the instance of the inner static class passing current instance as reference</span></span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>        outerInstance <span class="op">=</span> <span class="kw">this</span><span class="op">.</span><span class="fu">new</span> <span class="fu">Inner</span><span class="op">();</span> <span class="co">// equivalent to calling the ctor like new Inner();</span></span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a>        <span class="co">// this is also valid access to a private member of the inner class</span></span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> k <span class="op">=</span> outerInstance<span class="op">.</span><span class="fu">innerMember</span><span class="op">;</span></span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="kw">class</span> Inner <span class="op">{</span></span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-18"><a href="#cb3-18" aria-hidden="true" tabindex="-1"></a>        <span class="kw">private</span> <span class="dt">static</span> <span class="dt">final</span> <span class="dt">int</span> innerStaticMember <span class="op">=</span> <span class="dv">5</span><span class="op">;</span></span>
<span id="cb3-19"><a href="#cb3-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-20"><a href="#cb3-20" aria-hidden="true" tabindex="-1"></a>        <span class="kw">private</span> <span class="dt">int</span> innerMember<span class="op">;</span></span>
<span id="cb3-21"><a href="#cb3-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-22"><a href="#cb3-22" aria-hidden="true" tabindex="-1"></a>        <span class="kw">public</span> <span class="fu">Inner</span><span class="op">()</span> <span class="op">{</span></span>
<span id="cb3-23"><a href="#cb3-23" aria-hidden="true" tabindex="-1"></a>            <span class="co">// this is valid access of the instance member of the enclosing class, note the call to Outer.this</span></span>
<span id="cb3-24"><a href="#cb3-24" aria-hidden="true" tabindex="-1"></a>            <span class="dt">int</span> k <span class="op">=</span> Outer<span class="op">.</span><span class="fu">this</span><span class="op">.</span><span class="fu">outerMember</span><span class="op">;</span></span>
<span id="cb3-25"><a href="#cb3-25" aria-hidden="true" tabindex="-1"></a>            <span class="co">// this is also a valid reference to the outer static member which requires no instance reference</span></span>
<span id="cb3-26"><a href="#cb3-26" aria-hidden="true" tabindex="-1"></a>            <span class="kw">this</span><span class="op">.</span><span class="fu">innerMember</span> <span class="op">=</span> Outer<span class="op">.</span><span class="fu">outerStaticMember</span><span class="op">;</span></span>
<span id="cb3-27"><a href="#cb3-27" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb3-28"><a href="#cb3-28" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb3-29"><a href="#cb3-29" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb3-30"><a href="#cb3-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-31"><a href="#cb3-31" aria-hidden="true" tabindex="-1"></a><span class="co">// creating an instance of the inner class outside the context of the enclosing class, to do so one has to use a</span></span>
<span id="cb3-32"><a href="#cb3-32" aria-hidden="true" tabindex="-1"></a><span class="co">// reference to a valid `instance` of the Outer class to reference the new operator on the outerInstance itself</span></span>
<span id="cb3-33"><a href="#cb3-33" aria-hidden="true" tabindex="-1"></a>Outer outerInstance <span class="op">=</span> <span class="kw">new</span> <span class="fu">Outer</span><span class="op">();</span></span>
<span id="cb3-34"><a href="#cb3-34" aria-hidden="true" tabindex="-1"></a>Outer<span class="op">.</span><span class="fu">Inner</span> innerInstance <span class="op">=</span> outerInstance<span class="op">.</span><span class="fu">new</span> <span class="fu">Inner</span><span class="op">();</span></span></code></pre></div>
<h3 id="local-classes">Local classes</h3>
<p>The local classes are named class definitions which exist only in the
local scope or definition of the current code block, they are only local
and are not bound to the class type or class instance within which they
are located.</p>
<ul>
<li><p>Local interfaces can not be created inside methods, constructors
or initialization blocks, however this restriction was removed in later
versions of Java</p></li>
<li><p>Local inner classes</p></li>
<li><p>It is not possible to return an instance of a locally defined
class type directly,</p>
<div class="sourceCode" id="cb4"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">// this is a compile time error, since the new class type only exists in the local scope of the method and not</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">// outside of it, it is possible to return a super type, in case LocalType was a child of another class which</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">// was defined in a higher scope, for example if LocalType implements Closeable, the method signature could be</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>    <span class="co">// `Closeable returnLocalType`, which would then be a valid return type which is visible to the outside world</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> LocalType <span class="fu">returnLocalType</span><span class="op">()</span> <span class="op">{</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>        <span class="co">// defines a local type , which only exists for the lifetime of this function execution, and not outside of it,</span></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>        <span class="co">// this prevents one from actually returning the class type directly, however that can be changed by</span></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>        <span class="co">// modifying the function to return a super type from which the local class type can extend / implement</span></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>        <span class="kw">class</span> LocalType <span class="op">{</span></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="kw">new</span> <span class="fu">LocalType</span><span class="op">();</span></span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div></li>
<li><p>Every local variable accessed in the scope of a local class type,
is effectively final, for the whole scope of the function, even outside
the local class, meaning that it can not be assigned to, the reference
can not be changed, or in case of primitives they can not be mutated
(incremented, decremented)</p>
<div class="sourceCode" id="cb5"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="dt">static</span> <span class="bu">Color</span> <span class="fu">getDescriptiveColor</span><span class="op">(</span><span class="bu">Color</span> color<span class="op">)</span> <span class="op">{</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>    <span class="bu">Color</span> color2 <span class="op">=</span> color<span class="op">;</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">// the color variable will be effectively final for the entire scope of the function not just within the local</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>    <span class="co">// class definition, this is because the variable is accessed in the local class.</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">class</span> DescriptiveColor <span class="kw">extends</span> <span class="bu">Color</span> <span class="op">{</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>        <span class="kw">public</span> <span class="bu">String</span> <span class="fu">toString</span><span class="op">()</span> <span class="op">{</span></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>            <span class="co">// access the color argument, will cause it to automatically be treated as final by the compiler even</span></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>            <span class="co">// though there is no qualifier on the variable/argument, assginments to the `color` variable are not</span></span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a>            <span class="co">// allowed in the local class scope, and outside of it</span></span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="st">&quot;You selected a color with RGB values&quot;</span> <span class="op">+</span> color<span class="op">;</span></span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a>    <span class="co">// note this assignment - that will NOT compile, and is invalid, even outside the scope of the local class,</span></span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true" tabindex="-1"></a>    <span class="co">// treated as effectively final by the compiler</span></span>
<span id="cb5-15"><a href="#cb5-15" aria-hidden="true" tabindex="-1"></a>    color <span class="op">=</span> <span class="kw">null</span><span class="op">;</span></span>
<span id="cb5-16"><a href="#cb5-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-17"><a href="#cb5-17" aria-hidden="true" tabindex="-1"></a>    <span class="co">// this however is allowed, the color2 variable is NOT used within the scope of the inner local class meaning</span></span>
<span id="cb5-18"><a href="#cb5-18" aria-hidden="true" tabindex="-1"></a>    <span class="co">// that it can be treated just as any other local variable, it is not going to be effectively final</span></span>
<span id="cb5-19"><a href="#cb5-19" aria-hidden="true" tabindex="-1"></a>    color2 <span class="op">=</span> <span class="kw">null</span><span class="op">;</span></span>
<span id="cb5-20"><a href="#cb5-20" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="kw">new</span> <span class="fu">DescriptiveColor</span><span class="op">();</span></span>
<span id="cb5-21"><a href="#cb5-21" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div></li>
</ul>
<p><code>The general rule of thumb is that one can pass only final variables to a local class, if a variable is not explicitly defined as final, it will become effectively final at the time of compilation, and any re-assignments will be caught by the compiler</code></p>
<h3 id="anonymous-classes">Anonymous classes</h3>
<p>These classes, as the name implies do not have a name. The
declaration of the class automatically derives from the
instance-creation expression. They are also referred to as simply
anonymous. The anonymous class is useful in pretty much the same cases
where one would use local class. They are the same construct
semantically as the local class, with the only difference being that
they have no name.</p>
<ul>
<li><p>Anonymous classes can not have explicit constructors, since the
constructor is named after the name of the class, and they have no name,
therefore there is no way to create a constructor for an anonymous
class</p></li>
<li><p>The anonymous is defined in the new expression itself</p></li>
<li><p>Anonymous classes can not extend other classes or implement
interfaces</p></li>
<li></li>
</ul>
<div class="sourceCode" id="cb6"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span> <span class="dt">void</span> <span class="fu">method</span><span class="op">()</span> <span class="op">{</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">// this is an example of defining a local unnamed/anonymous class, in this case it is meant to provide an</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">// implementation of the Closeable interfaces</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>    <span class="bu">Closeable</span> c <span class="op">=</span> <span class="kw">new</span> <span class="bu">Closeable</span><span class="op">()</span> <span class="op">{</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>        <span class="co">// create a member instance variable</span></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> customLocalMember f <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a>        <span class="at">@Override</span></span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a>        <span class="kw">public</span> <span class="dt">void</span> <span class="fu">close</span><span class="op">()</span> <span class="kw">throws</span> <span class="bu">IOException</span> <span class="op">{</span></span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a>            <span class="co">// add custom implementation</span></span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true" tabindex="-1"></a>    <span class="co">// this demonstrates how a local class can be used to override certain methods from another concrete class,</span></span>
<span id="cb6-15"><a href="#cb6-15" aria-hidden="true" tabindex="-1"></a>    <span class="co">// effectively producing a new type, the actual semantics of this is equivalent to having a type, which extends from</span></span>
<span id="cb6-16"><a href="#cb6-16" aria-hidden="true" tabindex="-1"></a>    <span class="co">// the ConcreteClassType and overrides the desired methods, it is the same syntax, with the only difference being that</span></span>
<span id="cb6-17"><a href="#cb6-17" aria-hidden="true" tabindex="-1"></a>    <span class="co">// no explicit constructor can be provided since the anonymous class has no name.</span></span>
<span id="cb6-18"><a href="#cb6-18" aria-hidden="true" tabindex="-1"></a>    ConcreteClassType concrete <span class="op">=</span> <span class="kw">new</span> <span class="fu">ConcreteClassType</span><span class="op">()</span> <span class="op">{</span></span>
<span id="cb6-19"><a href="#cb6-19" aria-hidden="true" tabindex="-1"></a>        <span class="co">// it is possible to define local members, which work just as any other instance member</span></span>
<span id="cb6-20"><a href="#cb6-20" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> localAnonymousMember <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb6-21"><a href="#cb6-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-22"><a href="#cb6-22" aria-hidden="true" tabindex="-1"></a>        <span class="at">@Override</span></span>
<span id="cb6-23"><a href="#cb6-23" aria-hidden="true" tabindex="-1"></a>        <span class="kw">public</span> <span class="dt">void</span> <span class="fu">concreteMethod</span><span class="op">()</span> <span class="kw">throws</span> <span class="bu">IOException</span> <span class="op">{</span></span>
<span id="cb6-24"><a href="#cb6-24" aria-hidden="true" tabindex="-1"></a>            <span class="co">// override a method from the ConcreteClassType&#39;s interface</span></span>
<span id="cb6-25"><a href="#cb6-25" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb6-26"><a href="#cb6-26" aria-hidden="true" tabindex="-1"></a>        <span class="at">@Override</span></span>
<span id="cb6-27"><a href="#cb6-27" aria-hidden="true" tabindex="-1"></a>        <span class="kw">public</span> <span class="dt">void</span> <span class="fu">toString</span><span class="op">()</span> <span class="kw">throws</span> <span class="bu">IOException</span> <span class="op">{</span></span>
<span id="cb6-28"><a href="#cb6-28" aria-hidden="true" tabindex="-1"></a>            <span class="co">// override the to string method</span></span>
<span id="cb6-29"><a href="#cb6-29" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb6-30"><a href="#cb6-30" aria-hidden="true" tabindex="-1"></a>        <span class="at">@Override</span></span>
<span id="cb6-31"><a href="#cb6-31" aria-hidden="true" tabindex="-1"></a>        <span class="kw">public</span> <span class="dt">boolean</span> <span class="fu">equals</span><span class="op">(</span><span class="bu">Object</span> o<span class="op">)</span> <span class="kw">throws</span> <span class="bu">IOException</span> <span class="op">{</span></span>
<span id="cb6-32"><a href="#cb6-32" aria-hidden="true" tabindex="-1"></a>            <span class="co">// override the to equals method</span></span>
<span id="cb6-33"><a href="#cb6-33" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb6-34"><a href="#cb6-34" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb6-35"><a href="#cb6-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-36"><a href="#cb6-36" aria-hidden="true" tabindex="-1"></a>    <span class="co">// use the concrete anonymously created instance implementation of Closeable</span></span>
<span id="cb6-37"><a href="#cb6-37" aria-hidden="true" tabindex="-1"></a>    c<span class="op">.</span><span class="fu">close</span><span class="op">();</span></span>
<span id="cb6-38"><a href="#cb6-38" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-39"><a href="#cb6-39" aria-hidden="true" tabindex="-1"></a>    <span class="co">// use the overridden local anonymously created instance version of the ConcreteClassType</span></span>
<span id="cb6-40"><a href="#cb6-40" aria-hidden="true" tabindex="-1"></a>    concrete<span class="op">.</span><span class="fu">concreteMethod</span><span class="op">();</span></span>
<span id="cb6-41"><a href="#cb6-41" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p><code>Local anonymous classes were for the most part superseded by the introduction of lambda expressions, since the use of an anonymous was almost always expansively done to implement @FunctionalInterface interfaces, in practice.</code></p>
<h2 id="enums">Enums</h2>
<p>Enums or enumeration types provide a way to define a semantic
enumeration type, unlike in other languages where the enumeration types
are simple integers, in Java the enumeration is a fully fledged class
type, it has most all features of a normal class type, and is
instantiated as well.</p>
<div class="sourceCode" id="cb7"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="co">// define the most basic form of enum, which evaluates to compile time ordinal/integer constants, equivalent to what one</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a><span class="co">// might find in other languages such as C or C++</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a><span class="kw">enum</span> PrinterType <span class="op">{</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>    DOTMATRIX<span class="op">,</span> INKJET<span class="op">,</span> LASER</span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Just as regular classes, enums can have constructors, however those
constructors are always defined as <code>private</code>. This is because
the <code>instantiation</code> of the enum is taken care by the
run-time, and not by the client of the API, meaning that creating
instances of enums is not allowed (it can be done through reflection,
but is never a good idea, and defeats the purpose of enums - which is
that each enum entry must only exist once as an instance in the runtime,
they are effectively singleton instances)</p>
<div class="sourceCode" id="cb8"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="co">// define an enum, note that each entry is invoked with an argument, which matches the constructor type</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a><span class="kw">enum</span> PrinterType <span class="op">{</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">// note the semicolon - ; at the end, this is part of the syntax, it is mandatory if the enum has other members -</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>    <span class="co">// methods, variables etc</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>    <span class="fu">DOTMATRIX</span><span class="op">(</span><span class="dv">5</span><span class="op">),</span> <span class="fu">INKJET</span><span class="op">(</span><span class="dv">10</span><span class="op">),</span> <span class="fu">LASER</span><span class="op">(</span><span class="dv">50</span><span class="op">);</span></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>    <span class="co">// an instance member of the enumeration</span></span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">private</span> <span class="dt">int</span> pagePrintCapacity<span class="op">;</span></span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a>    <span class="co">// the default, and only constructor for this enumeration, enums can have as many overloaded constructors as one</span></span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a>    <span class="co">// would like, they also have a default constructor when none is provided, just as regular classes</span></span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">private</span> <span class="fu">PrinterType</span><span class="op">(</span><span class="dt">int</span> pagePrintCapacity<span class="op">)</span> <span class="op">{</span></span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true" tabindex="-1"></a>        <span class="kw">this</span><span class="op">.</span><span class="fu">pagePrintCapacity</span> <span class="op">=</span> pagePrintCapacity<span class="op">;</span></span>
<span id="cb8-14"><a href="#cb8-14" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb8-15"><a href="#cb8-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-16"><a href="#cb8-16" aria-hidden="true" tabindex="-1"></a>    <span class="co">// enums can have custom methods, which extend their behavior,</span></span>
<span id="cb8-17"><a href="#cb8-17" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="dt">int</span> <span class="fu">getPrintPageCapacity</span><span class="op">()</span> <span class="op">{</span></span>
<span id="cb8-18"><a href="#cb8-18" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> pagePrintCapacity<span class="op">;</span></span>
<span id="cb8-19"><a href="#cb8-19" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb8-20"><a href="#cb8-20" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p><code>Enums are explicitly defined as public static final, meaning that they are always visible, can not be extended and can not be bound to class instance, i.e they can not be defined as non-static inner classes inside another class type</code></p>
<p>There are several rules which apply to enumerations in Java, here are
some important points to keep in mind, which differentiate enumerations
and their constants from class types and class instances.</p>
<ul>
<li><p>An enum can not be created with the <code>new</code> keyword,
they are created by the run-time based on their definition in the enum
type itself</p></li>
<li><p>Enumerations are comparable with the == operator, this is due to
the fact that every enum instance of a given enum type exists and is
created only once, by the run-time (see point one above).</p></li>
<li><p>Enumerations from the same type can also be compared using the
equals operator, which is equivalent to the == unless
overridden</p></li>
<li><p>By default the <code>toString()</code> of an enum type is
printing the name of the enumeration entry itself, however the
<code>toString()</code> method can be overridden just like for any other
class type</p></li>
<li><p>Using the values() method on the enumeration type, is used to
obtain an array of enumeration constants for this specific
type.</p></li>
<li><p>Enumeration constants / entries can not be cloned, the clone()
method by default is throwing a
<code>CloneNotSupportedException</code></p></li>
</ul>
<h2 id="interfaces">Interfaces</h2>
<p>Is a special type in the Java language, such that it provides no
member variables, and only has member methods, which by default are not
implemented, and usually represent some sort of behavior. Unlike
abstract classes, interfaces are not implemented using the
<code>extends</code> keyword, but the <code>implmements</code> keyword,
on top of that, one class type can <code>implement</code> as many
interfaces, while as it is well known in java a class can only
<code>extend</code> from a single parent class</p>
<p>In Java 8 the interface structure was improved with the addition of
the so called <code>default</code> methods, which provide a way to
attach a type of utility methods which are very similar to
<code>static methods</code>, however they are not static, since they can
be overridden by the class which implements the interface, if the class
implementor chooses to do so, those methods usually provide a wrapper of
some sort around the API of the interface they are within.</p>
<div class="sourceCode" id="cb9"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="co">// here is example from the iterator interface, which provides a default method, that loops over the remaining entries</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a><span class="co">// in the iterator calling hasNext and next, those methods hasNext and next are actually not implementedby default however</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a><span class="co">// the default method is wrapping their usage in a general purpose implementation which is fairly straightforward</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a><span class="kw">default</span> <span class="dt">void</span> <span class="fu">forEachRemaining</span><span class="op">(</span>Consumer<span class="op">&lt;?</span> <span class="kw">super</span> E<span class="op">&gt;</span> action<span class="op">)</span> <span class="op">{</span></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>    Objects<span class="op">.</span><span class="fu">requireNonNull</span><span class="op">(</span>action<span class="op">);</span></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>    <span class="co">// note that hasNext is actually an `instance` like call, meaning that in the end this will end up in the late</span></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>    <span class="co">// binding stage, calling the actual instance of the class implementing the Iterator interface, same is true</span></span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a>    <span class="co">// for the call to next</span></span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="op">(</span><span class="fu">hasNext</span><span class="op">())</span> <span class="op">{</span></span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a>        action<span class="op">.</span><span class="fu">accept</span><span class="op">(</span><span class="fu">next</span><span class="op">());</span></span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Several key points to remember about interfaces and how they are
different from regular classes</p>
<ul>
<li><p>Interfaces can extend from other interfaces, one or more, using
the <code>extends</code> keyword, however they can not extend from
abstract or concrete classes</p></li>
<li><p>Interfaces can not be instantiated they can not have constructors
declared or defined, however a reference variable to an interface can
refer to an object which implements it =&gt;
<code>Iterator it = new IteratorImpl();</code></p></li>
<li><p>Interfaces do not contain non-static instance variables, due to
the reason above, if a data member is defined in an interface it will
actually be implicitly declared as
<code>public static final</code></p></li>
<li><p>An interface can have
<code>abstract (implicit), default and static methods</code> - all
methods in an interface are by default abstract, there is no need to
explicitly provide that keyword, it is used in abstract classes usually
to make sure the method without implementation is marked accordingly,
however in interfaces the default is that methods do not have
implementation.</p></li>
<li><p>An interface can be declared within another interface or class,
and it is always by default <code>static</code>, known as nested
interface, there is no notion of non-static nested interface, it would
not make sense, since non-static nested types are linked to an
instance</p></li>
<li><p>An interface <code>can have an empty body</code>, usually those
interfaces are called marker interfaces, left over for future extension,
or just used during reflection stages to identify certain
behavior</p></li>
<li><p>If an abstract class implements an interface, it does not have to
implement the methods immediately, however the concrete implementations
of that class have to.</p></li>
<li><p>Only public member methods of an interface are allowed, after all
the interface would be useless if it has a hidden state that is not
accessible from the outside, the idea of an interface is to be as open
as possible exposing an action or behavior, it should not be used, and
can not be used to hide actions or behavior</p>
<div class="sourceCode" id="cb10"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="co">// both the interface and the method are by default implicitly defined public, there is no reason to provide a</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a><span class="co">// qualifier to the methods or to the interface itself</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a><span class="kw">interface</span> Public <span class="op">{</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">static</span> <span class="dt">int</span> VARIABLE <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> <span class="co">// is also final by default, has to be initialized,</span></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">protected</span> <span class="dt">void</span> <span class="fu">method2</span><span class="op">();</span> <span class="co">// not possible, and will produce a compiler error</span></span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">private</span> <span class="dt">void</span> <span class="fu">method1</span><span class="op">();</span> <span class="co">// not possible, and will produce a compiler error</span></span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> <span class="fu">method0</span><span class="op">();</span> <span class="co">// is public by default, no need to qualify the method</span></span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div></li>
<li><p>Default methods can not be qualified as synchronized, this is
because the qualifier synchronized on the method, requires the runtime
to lock the current object/instance, however interfaces are not
instantiate-able, however it is possible to use a synchronized block
inside the default method, which locks around <code>this</code></p>
<div class="sourceCode" id="cb11"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="co">// synchronizing around an interface method, can be done within the body, or if the method is overridden in the</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a><span class="co">// concrete class instead</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span> <span class="kw">interface</span> Locked <span class="op">{</span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>    <span class="co">// this is completely fine, since when the method is invoked, within the body we can refer to `this` which</span></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a>    <span class="co">// refers to the instance or object which is of the ClassType which has implemented the interface, however</span></span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a>    <span class="co">// `this` is of type of the interface of course - `Locked`</span></span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="kw">default</span> <span class="dt">void</span> <span class="fu">method</span><span class="op">()</span> <span class="op">{</span></span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a>        <span class="kw">synchronized</span><span class="op">(</span><span class="kw">this</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true" tabindex="-1"></a>            <span class="bu">System</span><span class="op">.</span><span class="fu">out</span><span class="op">.</span><span class="fu">println</span><span class="op">();</span></span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb11-12"><a href="#cb11-12" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb11-13"><a href="#cb11-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-14"><a href="#cb11-14" aria-hidden="true" tabindex="-1"></a>    <span class="co">// this is not allowed, the method can not be marked as synchronized, since the run-time does not know around</span></span>
<span id="cb11-15"><a href="#cb11-15" aria-hidden="true" tabindex="-1"></a>    <span class="co">// what/which instance to create the lock</span></span>
<span id="cb11-16"><a href="#cb11-16" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="kw">default</span> <span class="kw">synchronized</span> <span class="dt">void</span> <span class="fu">method</span><span class="op">()</span> <span class="op">{</span></span>
<span id="cb11-17"><a href="#cb11-17" aria-hidden="true" tabindex="-1"></a>        <span class="bu">System</span><span class="op">.</span><span class="fu">out</span><span class="op">.</span><span class="fu">println</span><span class="op">();</span></span>
<span id="cb11-18"><a href="#cb11-18" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb11-19"><a href="#cb11-19" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div></li>
</ul>
<h3 id="diamond-pattern">Diamond pattern</h3>
<p>There is one well known issue when declaring multiple interfaces, and
when a given class implements multiple interfaces, it is possible to
have two interfaces being implemented by a single class, where the
interfaces provide two default methods with the same signature, this
issue can happen only with default methods, for interfaces, since the
non-default ones have no implementation, therefore there is no problem
with them</p>
<div class="sourceCode" id="cb12"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="kw">interface</span> Interface1 <span class="op">{</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">default</span> <span class="kw">public</span> <span class="dt">void</span> <span class="fu">foo</span><span class="op">()</span> <span class="op">{</span> <span class="bu">System</span><span class="op">.</span><span class="fu">out</span><span class="op">.</span><span class="fu">println</span><span class="op">(</span><span class="st">&quot;Interface1&#39;s foo&quot;</span><span class="op">);</span> <span class="op">}</span></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a><span class="kw">interface</span> Interface2 <span class="op">{</span></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">default</span> <span class="kw">public</span> <span class="dt">void</span> <span class="fu">foo</span><span class="op">()</span> <span class="op">{</span> <span class="bu">System</span><span class="op">.</span><span class="fu">out</span><span class="op">.</span><span class="fu">println</span><span class="op">(</span><span class="st">&quot;Interface2&#39;s foo&quot;</span><span class="op">);</span> <span class="op">}</span></span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a><span class="co">// even at this point the compiler will produce a compile time error since it sees to methods with the same signature</span></span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a><span class="co">// coming from two different type hierarchies, to avoid this the method HAS to be overridden in the child class to</span></span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true" tabindex="-1"></a><span class="co">// explicitly say which method is to be used.</span></span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Diamond <span class="kw">implements</span> Interface1<span class="op">,</span> Interface2 <span class="op">{</span></span>
<span id="cb12-12"><a href="#cb12-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-13"><a href="#cb12-13" aria-hidden="true" tabindex="-1"></a>    <span class="at">@Override</span></span>
<span id="cb12-14"><a href="#cb12-14" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="dt">void</span> <span class="fu">foo</span><span class="op">()</span> <span class="op">{</span></span>
<span id="cb12-15"><a href="#cb12-15" aria-hidden="true" tabindex="-1"></a>        <span class="co">// the call below would produce a compiler error, since there is a conflict in the resolution of the method</span></span>
<span id="cb12-16"><a href="#cb12-16" aria-hidden="true" tabindex="-1"></a>        <span class="co">// call, the compiler does not know which default method it has to call, and since the method is not overridden in</span></span>
<span id="cb12-17"><a href="#cb12-17" aria-hidden="true" tabindex="-1"></a>        <span class="co">// the implementation, there is no way to resolve the target method to be called</span></span>
<span id="cb12-18"><a href="#cb12-18" aria-hidden="true" tabindex="-1"></a>        <span class="co">// using foo call directly will not work like so =&gt; foo();</span></span>
<span id="cb12-19"><a href="#cb12-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-20"><a href="#cb12-20" aria-hidden="true" tabindex="-1"></a>        <span class="co">// to resolve the issue above, and avoid the compiler error, one has to qualify the method using the `super`</span></span>
<span id="cb12-21"><a href="#cb12-21" aria-hidden="true" tabindex="-1"></a>        <span class="co">// keyword, similarly to `this` which refers to the current instance, the `super` keyword refers to the super class</span></span>
<span id="cb12-22"><a href="#cb12-22" aria-hidden="true" tabindex="-1"></a>        <span class="co">// or interface of a given class, both calls can be used, or referenced in here, or in any other method in `Diamond`</span></span>
<span id="cb12-23"><a href="#cb12-23" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>condition<span class="op">)</span> <span class="op">{</span></span>
<span id="cb12-24"><a href="#cb12-24" aria-hidden="true" tabindex="-1"></a>            Interface1<span class="op">.</span><span class="fu">super</span><span class="op">.</span><span class="fu">foo</span><span class="op">();</span> <span class="co">// use the default method from the first interface</span></span>
<span id="cb12-25"><a href="#cb12-25" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb12-26"><a href="#cb12-26" aria-hidden="true" tabindex="-1"></a>            Interface2<span class="op">.</span><span class="fu">super</span><span class="op">.</span><span class="fu">foo</span><span class="op">();</span> <span class="co">// use the default method from the second interface</span></span>
<span id="cb12-27"><a href="#cb12-27" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb12-28"><a href="#cb12-28" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb12-29"><a href="#cb12-29" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb12-30"><a href="#cb12-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-31"><a href="#cb12-31" aria-hidden="true" tabindex="-1"></a><span class="co">// this is fine now, after the method in Diamond correctly resolves the conflict between the two `foo` methods, the</span></span>
<span id="cb12-32"><a href="#cb12-32" aria-hidden="true" tabindex="-1"></a><span class="co">// compiler will now know that the method is explicitly overridden in the implementation and how to call it</span></span>
<span id="cb12-33"><a href="#cb12-33" aria-hidden="true" tabindex="-1"></a><span class="kw">new</span> <span class="fu">Diamond</span><span class="op">().</span><span class="fu">foo</span><span class="op">();</span></span></code></pre></div>
<p>The other scenario is when an interface and base class have the same
signature, in that case for backwards compatibility the Java run-time
would pick the method from the base class, in this case the class wins
rule is applied, in a way to make sure that this is compatible with
older versions and behavior of the language.</p>
<div class="sourceCode" id="cb13"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> BaseClass <span class="op">{</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="dt">void</span> <span class="fu">foo</span><span class="op">()</span> <span class="op">{</span> <span class="bu">System</span><span class="op">.</span><span class="fu">out</span><span class="op">.</span><span class="fu">println</span><span class="op">(</span><span class="st">&quot;BaseClass&#39;s foo&quot;</span><span class="op">);</span> <span class="op">}</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a><span class="kw">interface</span> BaseInterface <span class="op">{</span></span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">default</span> <span class="kw">public</span> <span class="dt">void</span> <span class="fu">foo</span><span class="op">()</span> <span class="op">{</span> <span class="bu">System</span><span class="op">.</span><span class="fu">out</span><span class="op">.</span><span class="fu">println</span><span class="op">(</span><span class="st">&quot;BaseInterface&#39;s foo&quot;</span><span class="op">);</span> <span class="op">}</span></span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Diamond <span class="kw">extends</span> BaseClass <span class="kw">implements</span> BaseInterface <span class="op">{</span></span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb13-11"><a href="#cb13-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-12"><a href="#cb13-12" aria-hidden="true" tabindex="-1"></a><span class="co">// in this case the BaseClass&#39;s foo will be called, even though there are two methods with the same signature, the one</span></span>
<span id="cb13-13"><a href="#cb13-13" aria-hidden="true" tabindex="-1"></a><span class="co">// coming from the interface will be totally ignored by the compiler</span></span>
<span id="cb13-14"><a href="#cb13-14" aria-hidden="true" tabindex="-1"></a><span class="kw">new</span> <span class="fu">Diamond</span><span class="op">().</span><span class="fu">foo</span><span class="op">();</span></span></code></pre></div>
<p>Now a small caveat, what will happen if the method in BaseClass was
marked as <code>final</code>, since it means that it can not be
overridden, the compiler will be confused, and it will still try to pick
the class first rule, however what if one wants to change that, well it
CAN not</p>
<div class="sourceCode" id="cb14"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span> <span class="dt">static</span> <span class="kw">class</span> BaseClass <span class="op">{</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">// note that the method is marked as final, on purpose</span></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="dt">final</span> <span class="dt">void</span> <span class="fu">foo</span><span class="op">()</span> <span class="op">{</span></span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>        <span class="bu">System</span><span class="op">.</span><span class="fu">out</span><span class="op">.</span><span class="fu">println</span><span class="op">(</span><span class="st">&quot;BaseClass&#39;s foo&quot;</span><span class="op">);</span></span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span> <span class="kw">interface</span> BaseInterface <span class="op">{</span></span>
<span id="cb14-9"><a href="#cb14-9" aria-hidden="true" tabindex="-1"></a>    <span class="co">// a normal default method implementation in the interface</span></span>
<span id="cb14-10"><a href="#cb14-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">default</span> <span class="dt">void</span> <span class="fu">foo</span><span class="op">()</span> <span class="op">{</span></span>
<span id="cb14-11"><a href="#cb14-11" aria-hidden="true" tabindex="-1"></a>        <span class="bu">System</span><span class="op">.</span><span class="fu">out</span><span class="op">.</span><span class="fu">println</span><span class="op">(</span><span class="st">&quot;BaseInterface&#39;s foo&quot;</span><span class="op">);</span></span>
<span id="cb14-12"><a href="#cb14-12" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb14-13"><a href="#cb14-13" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb14-14"><a href="#cb14-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-15"><a href="#cb14-15" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span> <span class="dt">static</span> <span class="kw">class</span> Diamond <span class="kw">extends</span> BaseClass <span class="kw">implements</span> BaseInterface <span class="op">{</span></span>
<span id="cb14-16"><a href="#cb14-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-17"><a href="#cb14-17" aria-hidden="true" tabindex="-1"></a>    <span class="co">// this will produce a compile time error, even though one might think that the compiler will assume that the method</span></span>
<span id="cb14-18"><a href="#cb14-18" aria-hidden="true" tabindex="-1"></a>    <span class="co">// to be overridden is the one from the interface, since the one coming from the class is final, that is not the case,</span></span>
<span id="cb14-19"><a href="#cb14-19" aria-hidden="true" tabindex="-1"></a>    <span class="co">// the class still wins, the compiler still wants to override the method from the class, and since it is final, it will</span></span>
<span id="cb14-20"><a href="#cb14-20" aria-hidden="true" tabindex="-1"></a>    <span class="co">// throw and error</span></span>
<span id="cb14-21"><a href="#cb14-21" aria-hidden="true" tabindex="-1"></a>    <span class="at">@Override</span></span>
<span id="cb14-22"><a href="#cb14-22" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="dt">final</span> <span class="dt">void</span> <span class="fu">foo</span><span class="op">()</span> <span class="op">{</span></span>
<span id="cb14-23"><a href="#cb14-23" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb14-24"><a href="#cb14-24" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="functional-interfaces">Functional interfaces</h3>
<p>The functional interface is a new notion introduced in the Java 8
release, it is introduced along side the lambda expressions in the
language, the idea behind functional interfaces, is that they provide
only one single method, which has to be implemented, an interface with
no method, or only default methods, is not considered a functional
interface, the Java 8 release provides a new annotation which is called
<code>@FunctionalInterface</code> which can be used to mark interfaces
at compile time, which is used to validate if a given interface is truly
a functional interface</p>
<div class="sourceCode" id="cb15"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="co">// in java.lang package</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a><span class="kw">interface</span> <span class="bu">Runnable</span> <span class="op">{</span> <span class="dt">void</span> <span class="fu">run</span><span class="op">();</span> <span class="op">}</span></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a><span class="co">// in java.util package</span></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a><span class="kw">interface</span> <span class="bu">Comparator</span><span class="op">&lt;</span>T<span class="op">&gt;</span> <span class="op">{</span> <span class="dt">boolean</span> <span class="fu">compare</span><span class="op">(</span>T x<span class="op">,</span> T y<span class="op">);</span> <span class="op">}</span></span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a><span class="co">// java.awt.event package:</span></span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a><span class="kw">interface</span> <span class="bu">ActionListener</span> <span class="op">{</span> <span class="dt">void</span> <span class="fu">actionPerformed</span><span class="op">(</span><span class="bu">ActionEvent</span> e<span class="op">);</span> <span class="op">}</span></span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a><span class="co">// java.io package</span></span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true" tabindex="-1"></a><span class="kw">interface</span> <span class="bu">FileFilter</span> <span class="op">{</span> <span class="dt">boolean</span> <span class="fu">accept</span><span class="op">(</span><span class="bu">File</span> pathName<span class="op">);</span> <span class="op">}</span></span></code></pre></div>
<p><code>A functional interface has to have at least one abstract, non implemented, non default method, to be considered a functional interface, the functional interface is tightly used and related to lambda expressions, and a huge amount of the new additions to the java.lang library uses them</code></p>
<div class="sourceCode" id="cb16"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="co">// that is perfectly fine, the interface has one abstract non-implemented and non-default method</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a><span class="at">@FunctionalInterface</span></span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span> <span class="kw">abstract</span> <span class="kw">class</span> AnnotationTest <span class="op">{</span></span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">abstract</span> <span class="dt">int</span> <span class="fu">foo</span><span class="op">();</span></span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true" tabindex="-1"></a><span class="co">// that results in compiler error, the interface is not a functional interface, it contains to methods at all, same</span></span>
<span id="cb16-8"><a href="#cb16-8" aria-hidden="true" tabindex="-1"></a><span class="co">// would happen if the interface had two abstract methods as well, when only one is allowed at most</span></span>
<span id="cb16-9"><a href="#cb16-9" aria-hidden="true" tabindex="-1"></a><span class="at">@FunctionalInterface</span></span>
<span id="cb16-10"><a href="#cb16-10" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span> <span class="kw">abstract</span> <span class="kw">class</span> AnnotationTest <span class="op">{</span></span>
<span id="cb16-11"><a href="#cb16-11" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb16-12"><a href="#cb16-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-13"><a href="#cb16-13" aria-hidden="true" tabindex="-1"></a><span class="co">// It results in a compiler error &quot;no abstract method found in interface&quot; because it only has a default</span></span>
<span id="cb16-14"><a href="#cb16-14" aria-hidden="true" tabindex="-1"></a><span class="co">// method provided but does not have any abstract methods. How about this one?</span></span>
<span id="cb16-15"><a href="#cb16-15" aria-hidden="true" tabindex="-1"></a><span class="at">@FunctionalInterface</span></span>
<span id="cb16-16"><a href="#cb16-16" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span> <span class="kw">interface</span> AnnotationTest <span class="op">{</span></span>
<span id="cb16-17"><a href="#cb16-17" aria-hidden="true" tabindex="-1"></a>    <span class="kw">default</span> <span class="dt">int</span> <span class="fu">foo</span><span class="op">()</span> <span class="op">{};</span></span>
<span id="cb16-18"><a href="#cb16-18" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>There are a few interesting caveats related to functional interfaces
and interfaces in general, interfaces
<code>do not inherit from Object</code>, but rather implicitly declare
many of the same methods as Object. If you provide an abstract method
from Object class in the interface it still remains a functional
interface.</p>
<div class="sourceCode" id="cb17"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="at">@FunctionalInterface</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span> <span class="kw">interface</span> <span class="bu">Comparator</span><span class="op">&lt;</span>T<span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> <span class="fu">compare</span><span class="op">(</span>T o1<span class="op">,</span> T o2<span class="op">);</span></span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">boolean</span> <span class="fu">equals</span><span class="op">(</span><span class="bu">Object</span> obj<span class="op">);</span></span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>The example above is actually a valid functional interface, this is
because the method <code>equals</code> matches the ones by default
defined in the Object class, and even though interfaces
<code>do not</code> inherit by default implicitly from the Object class,
they have the same methods, and in this case the signature of the equals
matches the one in Object, therefore there is no compiler error. However
had it only had the equals method in the declaration, then a compiler
error would occur, since the interface has not a one abstract method
(remember equals, and the other ones from Object are not considered
abstract, in a way, they are provided with a default implementation by
the runtime if one is not)</p>
<p><code>Declaring methods which match the default ones from Object, in a functional or regular interface, do not count as abstract methods, they are more like default methods, which are implemented, by the run-time if an implementation is not provided</code></p>
<h3 id="lambda-expression">Lambda expression</h3>
<p>One of the most important features not just of the Java 8 release,
but in general, in the language, are the new lambda functions, which are
one of the most powerful features, that the language exposes. The lambda
expression are like closures, they are an easy way for one to provide a
stateful callback or action behavior</p>
<p>There are several coordinated changes in the language, the virtual
machine and the libraries that were made to create the new feature of
lambda reference functions and make that possible.</p>
<ul>
<li><p>First a new operator was added to introduce the creation of the
lambda expression which is the <code>-&gt;</code>, this operator is used
to define and declare lambda references in user space (code)</p></li>
<li><p>The function reference operator was also introduced, which
directly related to lambda expressions and allows functions to be
converted to lambda expressions, which in tern are simple function
interfaces</p></li>
<li><p>Then the default keyword was introduced, used in interfaces and
most importantly used to make sure that one can easily convert certain
interfaces into functional interfaces while still retaining backwards
compatiblity</p></li>
<li><p>The streams library and the integration of the collections
library with streams, this change made the streams library interop with
collections library very smooth and without any significant
friction.</p></li>
</ul>
<p>The introduction of lambda expression, introduced a slight paradigm
shift in the way programs are developed, allowed by passing behavior or
actions in the form function arguments, the lambda expressions represent
some sort of stateless transformation on a piece of data which can be
passed around just as a simple variable</p>
<p><code>The functional programming style is a style of programming that focuses on writing functions to perform tasks, rather than changing the state or data of a program, in a step-by-step approach, functional design comes from languages like lisp or scheme. It promotes functions and actions into user accessible and writeable variables in user space - code</code></p>
<p>Key concepts of functional programming</p>
<ul>
<li><p><code>Pure functions</code> - each function should always give
the same output if given the same input, without relying on or changing
the state of internal or external data the function has access
to.</p></li>
<li><p><code>State immutability</code> - data is not changed directly.
Instead of modifying existing data in-place, functions create and return
new data, based on the original data, This approach avoids side effects,
where one part of the program changes something that affects another
part in unexpected way.</p></li>
<li><p><code>First class functions</code> - the functions are first
class objects, and are treated like any other variables, you can pass
them as arguments to other functiosn, return them from functions or
assign them to variables. This flexibility lets you write more modular
and expressive code</p></li>
<li><p><code>High order functions</code> - those functions are functions
which take other functions as input or argument or return functions as
output. Common examples are functions like map, filter or reduce which
apply other functions to a collection of data in useful ways.</p></li>
</ul>
<p>Lambda syntax and declaration. The lambda expression is defined by 2
main elements, the argument list, and the body, they are separated by
the special arrow operator -&gt;.</p>
<ul>
<li><p>(type variable) = () -&gt; 5; - simple one line return
statements, do not need to explicitly wrap the statement in curly
block</p></li>
<li><p>(type variable) = x -&gt; x * x; - single argument lambda
expressions where type is not provided for the argument can omit the
brackets</p></li>
<li><p>(type variable) = (arg1, arg2) -&gt; { return 5; } - arguments
are specified in the list, and the type can often be omitted, due to
type deduction based on the left hand side</p></li>
<li><p>(type variable) = (String arg1, String arg2) -&gt; { return arg1
+ arg2; } - when types need to be provided, all types have to be
provided in the list, not just some of them</p></li>
<li><p>(type variable) = (String arg1, String arg2) -&gt; { action(); }
- lambda expression do not have to always return a value, they can
simply execute another action and exit</p></li>
</ul>
<p><code>Lambda expression are always linked to some sort of a type - that can be either a user defined FunctionalInterface, or some of the existing FunctionalInterfaces which the java.lang standard library has created over the years - Function, Predicate, Consumer etc. In other words, the left hand side of a lambda is always a concrete type, it is not any different than any other variable</code></p>
<div class="sourceCode" id="cb18"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="co">// this is a custom user defined FunctionalInterface</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a><span class="kw">interface</span> LambdaFunction <span class="op">{</span></span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> <span class="fu">call</span><span class="op">();</span></span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> FirstLambda <span class="op">{</span></span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-8"><a href="#cb18-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="dt">static</span> <span class="dt">void</span> <span class="fu">main</span><span class="op">(</span><span class="bu">String</span> <span class="op">[]</span>args<span class="op">)</span> <span class="op">{</span></span>
<span id="cb18-9"><a href="#cb18-9" aria-hidden="true" tabindex="-1"></a>        <span class="co">// as described above, the left hand side of the expression of a lambda expression, always refers to some type, it</span></span>
<span id="cb18-10"><a href="#cb18-10" aria-hidden="true" tabindex="-1"></a>        <span class="co">// is that binding to a type that determines the right hand side of a lambda expression, including the body of</span></span>
<span id="cb18-11"><a href="#cb18-11" aria-hidden="true" tabindex="-1"></a>        <span class="co">// arguments and the body of the lambda itself.</span></span>
<span id="cb18-12"><a href="#cb18-12" aria-hidden="true" tabindex="-1"></a>        LambdaFunction lambdaFunction <span class="op">=</span> <span class="op">()</span> <span class="op">-&gt;</span> <span class="bu">System</span><span class="op">.</span><span class="fu">out</span><span class="op">.</span><span class="fu">println</span><span class="op">(</span><span class="st">&quot;Hello world&quot;</span><span class="op">);</span></span>
<span id="cb18-13"><a href="#cb18-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-14"><a href="#cb18-14" aria-hidden="true" tabindex="-1"></a>        <span class="co">// lambda expressions are very much like local anonymous classes, they simply provide an easier way to create</span></span>
<span id="cb18-15"><a href="#cb18-15" aria-hidden="true" tabindex="-1"></a>        <span class="co">// one, instead of defining a local anonymous class which overrides the only method in the interfaces, however.</span></span>
<span id="cb18-16"><a href="#cb18-16" aria-hidden="true" tabindex="-1"></a>        lambdaFunction<span class="op">.</span><span class="fu">call</span><span class="op">();</span></span>
<span id="cb18-17"><a href="#cb18-17" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb18-18"><a href="#cb18-18" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p><code>Calling the lambda expression is no different than accessing the respective method of the interface and passing the necessary arguments (if any), that is why lambda expression are only an extension of already existing sematnic and lexical objects from the Java language, they do not introduce a completely new type of lexical scoped object, instead they take advantage of other features of the language</code></p>
<h4 id="lambda-design">Lambda Design</h4>
<p>It is good to make a comparison to other languages, where closures
also exist, and functions can be passed as arguments, for example in
<code>javascript</code> one can assign the function itself to a
variable, and then use the call operator <code>()</code> to invoke the
function referenced in the variable, this is NOT how java wanted to
introduce lambdas since that would require a completely new type of
syntax and language changes at a much deeper level, instead the java
spec is re-using existing functionality to replicate the same.</p>
<div class="sourceCode" id="cb19"><pre
class="sourceCode js"><code class="sourceCode javascript"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="co">// reference used by foo</span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a><span class="kw">var</span> outside <span class="op">=</span> <span class="st">&quot;test&quot;</span><span class="op">;</span></span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a><span class="co">// declare foo as a closure</span></span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a><span class="kw">var</span> foo <span class="op">=</span> () <span class="kw">=&gt;</span> {</span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true" tabindex="-1"></a>    <span class="bu">console</span><span class="op">.</span><span class="fu">log</span>(outside)<span class="op">;</span></span>
<span id="cb19-7"><a href="#cb19-7" aria-hidden="true" tabindex="-1"></a>}<span class="op">;</span></span>
<span id="cb19-8"><a href="#cb19-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-9"><a href="#cb19-9" aria-hidden="true" tabindex="-1"></a><span class="co">// somewhere else, use foo</span></span>
<span id="cb19-10"><a href="#cb19-10" aria-hidden="true" tabindex="-1"></a><span class="fu">foo</span>()<span class="op">;</span></span></code></pre></div>
<p>The example above illustrates how the closures in other languages,
are different than lambda expressions in java, on a fundamental level.
That should also make it pretty obvious, why local variables referenced
in lambda expression are always <code>effectively</code> final, The
variables must not be changed, re-assigned in the lambda expressions
body or anywhere else in the local scope where the variable is
used/visible, due to the way local variables are stored in java, unlike
other languages (see below)</p>
<h4 id="effectively-final">Effectively Final</h4>
<p>Here is a simple example of what would happen when either a local
variable of a function argument or parameter would be re-assigned
somewhere in the lambda body or in the function body. Note that this is
only relevant if the referenced local variable is used in both the
lambda body and the function body. For function arguments they are
always considered effectively final within a lambda expression body</p>
<div class="sourceCode" id="cb20"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="kw">interface</span> Functional <span class="op">{</span></span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> <span class="fu">call</span><span class="op">();</span></span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> FunctionalTest <span class="op">{</span></span>
<span id="cb20-6"><a href="#cb20-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="dt">static</span> <span class="dt">void</span> <span class="fu">main</span><span class="op">(</span><span class="bu">String</span> <span class="op">[]</span>args<span class="op">)</span> <span class="op">{</span></span>
<span id="cb20-7"><a href="#cb20-7" aria-hidden="true" tabindex="-1"></a>        <span class="co">// this local variable is not defined as final, but becomes one, and is treated as such by the compiler, any</span></span>
<span id="cb20-8"><a href="#cb20-8" aria-hidden="true" tabindex="-1"></a>        <span class="co">// attempt to re-assign to this variable will yield compiler error, either in the function body outside the lambda</span></span>
<span id="cb20-9"><a href="#cb20-9" aria-hidden="true" tabindex="-1"></a>        <span class="co">// body, or in the lambda body itself</span></span>
<span id="cb20-10"><a href="#cb20-10" aria-hidden="true" tabindex="-1"></a>        <span class="bu">String</span> word <span class="op">=</span> <span class="st">&quot;hello&quot;</span><span class="op">;</span></span>
<span id="cb20-11"><a href="#cb20-11" aria-hidden="true" tabindex="-1"></a>        Functional suffixFunc <span class="op">=</span> <span class="op">()</span> <span class="op">-&gt;</span> <span class="bu">System</span><span class="op">.</span><span class="fu">out</span><span class="op">.</span><span class="fu">println</span><span class="op">(</span>word <span class="op">+</span> <span class="st">&quot;ay&quot;</span><span class="op">);</span></span>
<span id="cb20-12"><a href="#cb20-12" aria-hidden="true" tabindex="-1"></a>        suffixFunc<span class="op">.</span><span class="fu">call</span><span class="op">();</span></span>
<span id="cb20-13"><a href="#cb20-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-14"><a href="#cb20-14" aria-hidden="true" tabindex="-1"></a>        <span class="co">// this is not possible, it will yield compiler error, even though it happens outside the lambda body, or after</span></span>
<span id="cb20-15"><a href="#cb20-15" aria-hidden="true" tabindex="-1"></a>        <span class="co">// the lambda is even created, and called.</span></span>
<span id="cb20-16"><a href="#cb20-16" aria-hidden="true" tabindex="-1"></a>        word <span class="op">=</span> <span class="kw">null</span><span class="op">;</span></span>
<span id="cb20-17"><a href="#cb20-17" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb20-18"><a href="#cb20-18" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>The example below shows how a lambda expression is actually expanded
by the compiler. Fundamentally that is not true, the actual run-time
creates the lambda in a different way, but conceptually this is what
happens, it gets transformed to a named or anonymous class, which
captures the captured scope inside member variables, initialized in the
constructor</p>
<div class="sourceCode" id="cb21"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="co">// here is a simple example of a lambda expression</span></span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span> <span class="dt">static</span> <span class="dt">void</span> <span class="fu">main</span><span class="op">(</span><span class="bu">String</span><span class="op">[]</span> args<span class="op">)</span> <span class="op">{</span></span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a>    <span class="bu">String</span> foo <span class="op">=</span> <span class="st">&quot;Hello, World!&quot;</span><span class="op">;</span></span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a>    <span class="bu">Runnable</span> r <span class="op">=</span> <span class="op">()</span> <span class="op">-&gt;</span> <span class="bu">System</span><span class="op">.</span><span class="fu">out</span><span class="op">.</span><span class="fu">println</span><span class="op">(</span>foo<span class="op">);</span></span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true" tabindex="-1"></a>    r<span class="op">.</span><span class="fu">run</span><span class="op">();</span></span>
<span id="cb21-6"><a href="#cb21-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb21-7"><a href="#cb21-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-8"><a href="#cb21-8" aria-hidden="true" tabindex="-1"></a><span class="co">// here is how it might be expanded by the compiler</span></span>
<span id="cb21-9"><a href="#cb21-9" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span> <span class="dt">static</span> <span class="dt">void</span> <span class="fu">main</span><span class="op">(</span><span class="bu">String</span><span class="op">[]</span> args<span class="op">)</span> <span class="op">{</span></span>
<span id="cb21-10"><a href="#cb21-10" aria-hidden="true" tabindex="-1"></a>    <span class="bu">String</span> foo <span class="op">=</span> <span class="st">&quot;Hello, World!&quot;</span><span class="op">;</span></span>
<span id="cb21-11"><a href="#cb21-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-12"><a href="#cb21-12" aria-hidden="true" tabindex="-1"></a>    <span class="co">// expanded lambda expression into a inner local class</span></span>
<span id="cb21-13"><a href="#cb21-13" aria-hidden="true" tabindex="-1"></a>    <span class="dt">final</span> <span class="kw">class</span> GeneratedClass <span class="kw">implements</span> <span class="bu">Runnable</span> <span class="op">{</span></span>
<span id="cb21-14"><a href="#cb21-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-15"><a href="#cb21-15" aria-hidden="true" tabindex="-1"></a>        <span class="co">// the outside scope captured in as member variables</span></span>
<span id="cb21-16"><a href="#cb21-16" aria-hidden="true" tabindex="-1"></a>        <span class="kw">private</span> <span class="dt">final</span> <span class="bu">String</span> generatedField<span class="op">;</span></span>
<span id="cb21-17"><a href="#cb21-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-18"><a href="#cb21-18" aria-hidden="true" tabindex="-1"></a>        <span class="co">// initialized at the moment of lambda creation</span></span>
<span id="cb21-19"><a href="#cb21-19" aria-hidden="true" tabindex="-1"></a>        <span class="kw">private</span> <span class="fu">GeneratedClass</span><span class="op">(</span><span class="bu">String</span> generatedParam<span class="op">)</span> <span class="op">{</span></span>
<span id="cb21-20"><a href="#cb21-20" aria-hidden="true" tabindex="-1"></a>            generatedField <span class="op">=</span> generatedParam<span class="op">;</span></span>
<span id="cb21-21"><a href="#cb21-21" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb21-22"><a href="#cb21-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-23"><a href="#cb21-23" aria-hidden="true" tabindex="-1"></a>        <span class="at">@Override</span></span>
<span id="cb21-24"><a href="#cb21-24" aria-hidden="true" tabindex="-1"></a>        <span class="kw">public</span> <span class="dt">void</span> <span class="fu">run</span><span class="op">()</span> <span class="op">{</span></span>
<span id="cb21-25"><a href="#cb21-25" aria-hidden="true" tabindex="-1"></a>            <span class="bu">System</span><span class="op">.</span><span class="fu">out</span><span class="op">.</span><span class="fu">println</span><span class="op">(</span>generatedField<span class="op">);</span></span>
<span id="cb21-26"><a href="#cb21-26" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb21-27"><a href="#cb21-27" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb21-28"><a href="#cb21-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-29"><a href="#cb21-29" aria-hidden="true" tabindex="-1"></a>    <span class="bu">Runnable</span> r <span class="op">=</span> <span class="kw">new</span> <span class="fu">GeneratedClass</span><span class="op">(</span>foo<span class="op">);</span></span>
<span id="cb21-30"><a href="#cb21-30" aria-hidden="true" tabindex="-1"></a>    r<span class="op">.</span><span class="fu">run</span><span class="op">();</span></span>
<span id="cb21-31"><a href="#cb21-31" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>First it is important to mention that local variables are not shared
between threads, in java they are stored on the stack, and are not
affected by the memory model, only instance members, static fields,
array elements and so on are stored on the heap. Local variables,
exception handler parameters are never stored on the heap and not shared
between threads. Therefore since they can not be shared, a copy of the
value has to be captured in an object (like instance member field) that
can be shared between threads.</p>
<p>When the lambda is created what really happens is that local capture,
becomes an instance variable of the unnamed or anonymous class (lambda
expression), it holds the same value like the value that is held by the
local variable, the reference is the same the variables are different,
one of them is the local one from the function, the other is a member of
the anonymous class, however both are assigned the same starting
value.</p>
<p>Now imagine if the language provided a way to change and re-assign
this, in user land, the code, it would seem that the same variable - the
one from the function scope and the one from the lambda scope are the
same (even though they are not, they share the same name only, for ease
of use, and share the same initial value), allowing re-assignment
separately and independently in the outer function scope and lambda
body, would be quite confusing. Member variables are not subject to such
restrictions, the lambda automatically captures <code>this</code> and an
access the members without referencing <code>this</code> explicitly,
however <code>this</code> can be used to be more verbose of course, so
can <code>super</code>, since the lambda captures the immediate instance
which is enclosing it</p>
<p><code>Only local variables and function arguments are required to be treated as effectively final, due to the reasons above, if a lambda expression references a member variable, it is not subject to these restrictions, due to the reasons mentioned above, related to the way the memory model works in java, which means that member variables will be mutable, and re-assignable outside and inside the lambda body, this is important to remember</code></p>
<h1 id="summary">Summary</h1>
<p>Abstract classes and methods</p>
<ul>
<li><p>An abstraction specifying functionality supported without
disclosing finer level details.</p></li>
<li><p>You cannot create instances of an abstract class.</p></li>
<li><p>Abstract classes enable run-time polymorphism, and run-time
polymorphism in turn enables loose coupling.</p></li>
</ul>
<p>Final variables &amp; methods</p>
<ul>
<li><p>A final class is a non-inheritable class (i.e., you cannot
inherit from a final class).</p></li>
<li><p>A final method is a non-overridable method (i.e., subclasses
cannot override a final method).</p></li>
<li><p>All methods of a final class are implicitly final (i.e.,
non-overridable).</p></li>
<li><p>A final variable can be assigned only once.</p></li>
</ul>
<p>Inner, local and anonymous classes</p>
<ul>
<li><p>Java supports four types of nested classes: static nested
classes, inner classes, local inner classes, and anonymous inner
classes.</p></li>
<li><p>Static nested classes may have static members, whereas the other
flavors of nested classes cant.</p></li>
<li><p>Static nested classes and inner classes can access members of an
outer class (even private members). However, static nested classes can
access only static members of outer classes.</p></li>
<li><p>Local classes (both local inner classes and anonymous inner
classes) can access all variables declared in the outer scope (whether a
method, constructor, or a statement block). Use enumerated types
including methods, and constructors in an enum type</p></li>
<li><p>Enums are a typesafe way to achieve restricted input from
users.</p></li>
<li><p>You cannot use new with enums, even inside the enum
definition.</p></li>
<li><p>Enum classes are by default final classes.</p></li>
<li><p>All enum classes are implicitly derived from
java.lang.Enum.</p></li>
</ul>
<p>Interfaces and Overriding</p>
<ul>
<li><p>An interface can have three kinds of methods: abstract methods,
default methods, and static methods.</p></li>
<li><p>The diamond problem occurs when a derived type inherits two
method definitions in the base types that have the same
signature.</p></li>
<li><p>If two super interfaces have the same method name and one of them
has a definition, the compiler will issue an error; this conflict has to
be resolved manually.</p></li>
<li><p>If a base class and a base interface define methods with the same
signature, the method definition in the class is used and the interface
definition is ignored.</p></li>
<li><p>A functional interface consists of exactly one abstract method
but can contain any number of default or static methods.</p></li>
<li><p>A declaration of a functional interface results in a functional
interface type that can be used with lambda expressions.</p></li>
<li><p>For a functional interface, declaring methods from Object class
in an interface does not count as an abstract method.</p></li>
</ul>
<p>Lambda expressions</p>
<ul>
<li><p>In a lambda expression, the left side of the -&gt; provides the
parameters; the right side, the body. The arrow operator (-&gt;) helps
in concise expressions of lambda functions.</p></li>
<li><p>You can create a reference to a functional interface and assign a
lambda expression to it. If you invoke the abstract method from that
interface, it will call the assigned lambda expression.</p></li>
<li><p>Compiler can perform type inferences of lambda parameters if
omitted. When declared, parameters can have modifiers such as
final.</p></li>
<li><p>Variables accessed by a lambda function are considered to be
effectively final.</p></li>
</ul>
</body>
</html>
