NIO Streams

Java offers a rich set of application programming interfaces, or APIs, that you can use to manipulate files and directories. In Java 7, a new set of input and output APIs was introduced, called NIO dot two, which stands for New Input Output. This update provided convenient ways to perform operations related to the file system. Starting with Java 8, these APIs can also be used alongside the Stream API.

Path

All file systems are typically organized as a tree. The file system starts with a root directory, which contains files and other directories. Each directory, in turn, may have its own subdirectories or files. To locate a specific file, you need to combine the directories from the root down to the immediate directory containing the file, and then add the file name itself, using the correct file separator for your operating system. This combination forms a unique resource name, or identifier, for the file on disk—sometimes called a URN.

A path can be either absolute or relative. An absolute path always starts from the root directory. A relative path, on the other hand, is defined in relation to the current working directory. The current working directory is the directory from which a program or process is started, and it is always an absolute path from the root. The operating system provides ways to obtain this current working directory.

Another important concept is symbolic links. A symbolic link acts like a pointer or reference to an actual file. In general, symbolic links are transparent to applications, meaning that most operations are performed directly on the files they point to, rather than on the links themselves. However, certain operations, such as deleting or moving, may behave differently. Symbolic links are often referred to as "sym links" in practice.

The Path interface is a programming abstraction for a file or directory path. A Path object contains the names of directories and files that make up the full path to a resource. The Path abstraction provides methods to extract, manipulate, and append path elements. Almost all methods that access or manipulate files and directories use Path objects.

The new Path interface is the cornerstone of the NIO library and serves as the building block for nearly the entire API.

Key Methods of the Path Interface

The Path interface provides several important methods:

The getRoot method returns a Path object representing the root of the given path, or null if the path does not have a root.

The getFileName method returns the file or directory name of the given path. This is always the last element in the path.

The getParent method returns the Path object representing the parent of the given path, or null if there is no parent component.

The getNameCount method returns the number of file or directory names in the given path. If the path represents the root, it returns zero.

The getName method returns the file or directory name at a specific index, starting from zero, which is the name closest to the root.

The subpath method returns a Path object that represents a portion of the original path. The returned Path starts at the specified begin index and ends just before the end index. If the indices are out of range or invalid, this method throws an IllegalArgumentException.

The normalize method removes redundant elements in the path, such as the single dot, which indicates the current directory, and the double dot, which indicates the parent directory.

The resolve method combines the current path with another path and returns the resulting path.

The isAbsolute method returns true if the path is absolute, and false if it is relative.

The startsWith method returns true if the Path object starts with the specified path.

The toAbsolutePath method returns the absolute version of the path.

Information

In the following example, you will see how to obtain full information for a given path that points to a test file on the D drive in a Windows environment.

This code creates a Path object for the file located at D colon backslash test backslash testfile dot t x t, using the static get method from the Paths class. It then prints out basic information about the path, including the file name, the root of the path, and the parent directory. Finally, it iterates over the elements of the path and prints each one. This demonstrates how to use the Path interface to access and display detailed information about a file path.


Let’s walk through what the output of this code might look like. Imagine that the path elements are printed from top to bottom. In this example, there are only two elements, and the root drive is not included.

The path instance is obtained using the Paths utility class. You call its static get method, passing in the path location. The get method can accept a variable number of string arguments, which represent the path elements. This means you can build a path from individual elements, for example, by calling Paths dot get with the arguments D colon, test, and testfile dot txt.

The code prints information about a file. It displays the file name, which is testfile dot txt. It shows the root of the path as D colon backslash, and the parent of the target as D colon backslash test. Then, it prints the elements of the path, listing test and testfile dot txt as the path elements.

Next, let’s look at how to obtain an object for a relative path. This is based on where the program is started. The actual current path will be used, and this is where the Test directory will be resolved to point to. For example, it might resolve to the current absolute path, followed by backslash Test.

In the code, a path object is created with a relative path by calling Paths dot get with dot backslash Test. The code then prints the file name, which is Test. It prints the URI, which includes the file protocol and the full path, including the dot. It prints the absolute path, which also includes the dot. It prints the normalized path, which is simply Test. Then, it creates another path object using the normalized string, and prints its normalized absolute path, which no longer includes the dot. Finally, it attempts to print the normalized real path by calling toRealPath with the option to not follow links.

This last call to toRealPath will fail, because the Test directory probably does not exist. The toRealPath method tries to resolve the real path to this directory, and if it does not exist, it throws an exception.

The output shows the file name as Test. The URI is printed as file colon slash slash slash D colon slash OCPJP slash programs slash NIO2 slash dot slash Test. The absolute path is D colon backslash OCPJP backslash programs backslash NIO2 backslash dot backslash Test. The normalized path is Test. The normalized absolute path is D colon backslash OCPJP backslash programs backslash NIO2 backslash Test. Then, an exception is thrown, specifically a NoSuchFileException, indicating that the directory does not exist.

Notice how the different paths are printed. The URI and absolute path include the slash and the dot, but the normalized absolute path does not. This is why it is usually a good practice to normalize a path, especially if it is derived from user input, before doing any work on it.

The toPath method in the java dot io dot File class returns a Path object. This method was added in Java 7. Similarly, you can use the toFile method in the Path interface to get a File object. This is one of the many bridges between the old IO and the newer NIO, which Java provides out of the box.

Comparison

The Path interface provides two methods to compare Path objects: equals and compareTo. The equals method checks if two Path objects are equal and returns true or false. The compareTo method compares two Path objects character by character and returns an integer. It returns zero if the paths are equal, a negative integer if the current path is lexicographically less than the parameter path, and a positive integer if it is greater.

In the example, two Path objects are created. The first is path1, which is created from the string Test. The second is path2, which is created from the absolute path D colon backslash OCPJP backslash programs backslash NIO2 backslash Test.

The code compares the two paths using the compareTo method and prints whether the result is zero. It also compares the two paths using the equals method and prints the result. Finally, it compares path2 to the absolute version of path1 using equals and prints the result.

Assume that the current working directory is D colon backslash OCPJP backslash programs backslash NIO2. The output of these comparisons will show that comparing path1 and path2 directly yields false, both for compareTo and equals. However, when comparing path2 to the absolute version of path1, the equals check returns true. This is because the Path class does not make any hidden assumptions. Even though the two paths are logically the same, one is relative and the other is absolute, so their data fields are not identical. The methods return results based on the actual data, which is a good design. You would not want the library to make broad assumptions and consider both the relative and absolute paths equal.

The output will be as follows. The compareTo check is false. The equals check is false. The equals check with the absolute path is true.

Files

The previous sections discussed how to create and work with Path instances, and how to extract useful information from them. In this section, Path objects are used to manipulate files or directories.

Java 7 introduced the Files class, which is in the java dot nio dot file package. This class can be used to perform various file-related operations on files or directories. Note that Files is a utility class. It is a final class with a private constructor and consists only of static methods. You can use the Files class by calling its static methods, such as copy, to copy files. This class provides a wide range of functionality.


File and Directory Operations in Java NIO

Let’s walk through some of the key methods available for working with files and directories using the Java NIO package. These methods help you create, copy, move, and inspect files and directories, as well as manage their attributes.

First, the createDirectory method allows you to create a new directory at a specified path, applying any given file attributes. If the directory already exists, or if the attributes cannot be set as requested, this method may throw an exception such as FileAlreadyExistsException or UnsupportedOperationException.

In contrast, the createDirectories method goes a step further. It creates not only the target directory, but also any intermediate directories along the specified path that do not already exist. This is useful when you need to ensure the entire directory structure is present.

Next, the createTempFile method creates a temporary file in a specified directory. You can provide a prefix and suffix for the file name, as well as any desired file attributes. This is commonly used for creating files that are needed only for a short time during program execution.

Similarly, the createTempDirectory method creates a temporary directory with a given prefix and attributes in the specified location. This is helpful when you need a workspace for temporary files.

The copy method copies a file from a source path to a target path. You can specify options such as replacing an existing file, copying file attributes, or not following symbolic links. If the target file already exists, or if there are issues with the copy operation, exceptions may be thrown.

The move method is similar to copy, but it also removes the source file after moving it to the target location. If the source and target are in the same directory, this operation effectively renames the file.

To check if two Path objects refer to the same file, you can use the isSameFile method. This is useful for verifying file identity, especially when working with symbolic links or different path representations.

The exists method checks whether a file or directory exists at the given path. You can specify options to control whether symbolic links are followed.

To determine if a path represents a regular file, use the isRegularFile method. This returns true if the file is not a directory or a special file.

The isSymbolicLink method returns true if the path points to a symbolic link, while isHidden checks if the file is hidden.

To find out the size of a file in bytes, use the size method.

For file ownership, getOwner retrieves the owner of a file, and setOwner allows you to change the owner.

To manage file modification times, getLastModifiedTime returns the last modified timestamp, and setLastModifiedTime lets you update it.

Finally, getAttribute and setAttribute provide a way to get or set specific attributes of a file, such as permissions or timestamps, by specifying the attribute name.

These methods together provide a comprehensive toolkit for managing files and directories in Java applications, allowing you to create, modify, inspect, and control file system resources with precision.


Metadata

To quickly check some basic file metadata, you can use several methods provided by the Java NIO package. In a previous section, we looked at an example that tried to determine if two paths pointed to the same file. There is a more robust way to do this by using the isSameFile method.

In this approach, you create two Path objects, one with a relative path and the other with an absolute path. Then, you use the Files.isSameFile method to check if both paths refer to the same file on disk. If the file or directory does not exist at the given path, a NoSuchFileException will be thrown.

To avoid such exceptions, you can first check if a file or directory exists using the exists or isDirectory methods. For example, you can create a Path object and use Files.exists with the LinkOption.NOFOLLOW_LINKS option to check for existence. If the path exists, you can then check whether it is a directory or a file using Files.isDirectory. It is important to note that the exists method alone cannot tell you if the path is a directory or a file, and sometimes the path itself does not provide enough information. This is especially true on operating systems where files and directories can have the same names, or where files do not have extensions. Using these methods helps you avoid unnecessary exceptions in your code, which is generally considered good practice.

To check if you have permission to read or write to a file or directory, you can use the isReadable and isWritable methods. There is also an isExecutable method to check if a path points to an executable file. For example, if you have a path that points to a directory, and you check its readability and writability, these calls should return true. However, checking if it is executable will typically return false for a directory.

To get a broader view of a file’s attributes, you can use the Files.getAttribute method. This allows you to retrieve properties such as creation time, last modified time, size, whether the file is hidden, and whether it is a directory. The tricky part here is specifying the correct attribute name pattern. The attribute name should be in the format view:attribute, where view is the type of FileAttributeView and attribute is the name of the attribute supported by that view. If no view is specified, it defaults to the basic view. For example, creationTime, size, and isDirectory are basic view attributes and are supported across operating systems. If you specify an incorrect view or attribute name, an UnsupportedOperationException will be thrown.

There is also a way to read all attributes of a file or directory at once. You can use the Files.readAttributes method with the BasicFileAttributes class. This allows you to retrieve properties such as file size, whether it is a directory, whether it is a regular file, whether it is a symbolic link, and the last access and modification times. There are also PosixFileAttributes and DosFileAttributes classes for POSIX and DOS compliant operating systems, which provide access to OS-specific file attributes. However, before using these, you should check the current operating system type to ensure you are using the correct attribute type.

Copying

Copying a file is straightforward using the copy method from the Files class. The third argument to the copy method specifies file copy options, such as what to do if the destination file already exists. For example, you can copy a file from a source path to a destination path. If you try to copy the same file again without specifying an option to replace the existing file, a FileAlreadyExistsException will be thrown. To force the file to be overwritten, you can pass the StandardCopyOption.REPLACE_EXISTING option as the third argument.

If the destination is a directory path that does not exist, a NoSuchFileException will be thrown. The full destination path must exist before you can copy a file or directory. For example, if you are copying a directory named Test, both the source directory and the destination location must exist. If you are copying a file named test.txt, the source file and the destination directory must exist as well.

It is important to note that the copy method does not copy the files or directories contained within a directory. It only copies the top-level directory itself. If you want to copy the contents of a directory, you must do so recursively or explicitly.

Moving

Moving a file is similar to copying, but with some differences. Like the copy operation, the move method must handle the case where a file or directory already exists at the destination. You can provide explicit instructions to replace the destination if it already exists by passing the StandardCopyOption.REPLACE_EXISTING option. Otherwise, a FileAlreadyExistsException will be thrown.

If you are moving a symbolic link, only the link itself is moved, not the file or directory it points to. There is an option to move the file itself by using the FOLLOW_LINKS option. A non-empty directory can be moved as long as the move does not require moving the contained files or directories separately. For example, moving a directory from one location to another may fail if the operation cannot move all the contents. The move method can also be specified as an atomic operation using the ATOMIC_MOVE copy option. With this option, either the entire move completes successfully, or the source remains unchanged. If the move is not performed as an atomic operation and it fails during the process, the state of both the source and destination files or directories is unknown and undefined.

Deleting

The section on deleting is not included in the provided text, but typically, deleting a file or directory can be done using the Files.delete method. This method removes the file or directory at the specified path. If the file or directory does not exist, a NoSuchFileException will be thrown. If the directory is not empty, an exception will also be thrown unless you delete its contents first.


The Files class provides a delete method as well. This method allows you to delete a file, a directory, or a symbolic link. There are a few important points to remember about deleting, especially when it comes to directories. The delete method should only be used on an empty directory—otherwise, it will fail. If you use it on a symbolic link, only the link itself is deleted, not the target file that the link points to. The file or directory you intend to delete must actually exist; otherwise, a NoSuchFileException will be thrown.

If you want to delete a file or directory without worrying about whether it exists, you can use the deleteIfExists method instead. This method will not throw an error if the file does not exist; it simply deletes the file if it is present. Also, keep in mind that if a file is read-only, some platforms may prevent you from deleting it.

The API for the delete method is quite simple. It accepts only the path of the target to be deleted. No other options or actions can be passed to this method, or to the deleteIfExists method. In essence, you provide the path, and the method attempts to delete the file or directory at that location.

Notes

Here are some general notes related to the classes we have already reviewed.

Do not confuse the File class with the Files class, or the Path interface with the Paths class. These are very different. File is an older class that represents file or directory path names. Files, on the other hand, was introduced in Java 7 as a utility class with comprehensive support for input and output operations. The Path interface represents a file or directory path and defines a useful list of methods. Paths is a utility class that offers only two methods, both of which are used to construct path objects.

It is also important to note that the file or directory represented by a Path object may not actually exist. Other than methods such as toRealPath, most methods in Path do not require that the underlying file or directory be present for a Path object to be created or used.

Streaming

As already mentioned, the Stream API, which was added in Java 8, can be used along with the new Files and Path classes from the NIO package. There are several new methods in the Files class that produce streams, which can then be used to read file contents or metadata.

List

The list method lists all files or directories in the current directory. Internally, it uses DirectoryStream, so the close method must be called to release the input and output resources.

In practice, the list method returns a stream, but this stream holds input and output resources. That is why you should use a try-with-resources block, which will close the stream when you are done. Under the hood, DirectoryStream itself does not extend Stream, but its iterator is wrapped around an anonymous Stream implementation.

This means you can use the list method to get a stream of entries in the current directory, and then process each entry as needed. However, the list method does not perform any recursive traversal. It only lists the entries in the current path.

If you need to traverse directories recursively, you can use the walk method. The walk method walks the tree formed by the path you pass in as an argument. The FileVisitOption enumeration has one value, FOLLOW_LINKS, which allows you to follow symbolic links during traversal. The overloaded version of walk also takes a maxDepth argument, which is useful for limiting how deep the traversal goes. However, using FOLLOW_LINKS does not guarantee that infinite recursion cannot occur. The walk method has no built-in loop detection. For example, if a symbolic link somewhere in the tree points to a parent directory, you could end up in an infinite loop.

The walk method returns a stream of Path objects by recursively traversing the directory tree. You can specify the maximum depth and whether to follow symbolic links.

Here is a simple usage example. This code walks the current directory, follows symbolic links, and restricts the depth to a maximum of four levels or directories deep. It then counts the number of entries found.

Find

The find method is used to locate a file somewhere in the current directory tree formed by the path argument. Find is built on top of walk. It does essentially the same operations as walk, but only returns files that match a given predicate. In other words, it is like applying a filter operation to the stream returned by walk, but it is much more efficient. The method signature of find matches that of walk.

The find method returns a stream that is lazily populated with Path objects by searching for files in a file tree rooted at a given starting file. For each file encountered, a given BiPredicate is invoked with its Path and BasicFileAttributes. The Path object is obtained as if by the walk method.

Lines

There is also a way to obtain the lines from a file using the lines or readAllLines methods. Both are slightly different. The lines method returns a stream of strings, which is an anonymous implementation that wraps around the NIO operations. The stream can then be used to read the lines lazily. This means that depending on the type of operation—such as findFirst or findAny—you might not read the entire file. For example, you might only read the first N lines, and then the stream is closed, which also closes the internal file resources.

The readAllLines method, on the other hand, eagerly reads the entire file and all of its lines, returning a list of strings.

To summarize, the lines method allows you to obtain a stream object to the lines of the file pointed to by a given path. The returned stream is an anonymous implementation that wraps the file resource and input and output operations to obtain the lines lazily as the stream is being iterated over. This can be more efficient, depending on what operations you apply to the stream. For example, if you only need the first few lines, you do not need to read the entire file. Internally, Files.lines uses BufferedReader.lines, which returns a stream.

Summary

Let’s review the key points about the Path interface and related operations.

A Path object is a programming abstraction that represents the path of a file or directory. You can get an instance of Path using the get method of the Paths class. Path provides two methods to compare Path objects: equals and compareTo. Even if two Path objects point to the same file or directory, the equals method is not guaranteed to return true.

For reading, deleting, copying, moving, and managing metadata:

You can check the existence of a file using the exists method of the Files class. The Files class also provides the methods isReadable, isWritable, and isExecutable to check whether the program can read, write, or execute a file programmatically. You can retrieve the attributes of a file using the getAttributes method. You can use the readAttributes method of the Files class to read file attributes in bulk. The copy method can be used to copy a file from one location to another. Similarly, the move method moves a file from one location to another. While copying, all the directories—except the last one, if you are copying a directory—on the specified path must exist to avoid a NoSuchFileException. Use the delete method to delete a file, and use the deleteIfExists method to delete a file only if it exists.

For streams and NIO.2:

The Files.list method returns a stream of Path objects. It does not recursively traverse the directories in the given path. The Files.walk method returns a stream of Path objects by recursively traversing the entries from the given path. In one of its overloaded versions, you can also pass the maximum depth for such traversal and provide FileVisitOption.FOLLOW_LINKS as an option. The Files.find method returns a stream of Path objects by recursively traversing the entries from the given path. It also takes the maximum depth to search, a BiPredicate, and an optional FileVisitOption as arguments. Finally, Files.lines is a very convenient method to read the contents of a file. It returns a stream of strings.

This concludes the overview of the Files and Path classes, their methods, and how they interact with the Stream API in Java.


