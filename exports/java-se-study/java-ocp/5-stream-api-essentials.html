<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>5-stream-api-essentials</title>
  <style>
    html {
      font-size: 12pt;
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      overflow-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 12px;
      }
      h1 {
        font-size: 1.8em;
      }
    }
    @media print {
      html {
        background-color: white;
      }
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, Consolas, 'Lucida Console', monospace;
      font-size: 85%;
      margin: 0;
      hyphens: manual;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
      overflow-wrap: normal;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      background-color: #1a1a1a;
      border: none;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC ul {
      padding-left: 1.3em;
    }
    #TOC > ul {
      padding-left: 0;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
    /* CSS for syntax highlighting */
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    .sourceCode { overflow: visible; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {   }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ff0000; font-weight: bold; } /* Alert */
    code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #7d9029; } /* Attribute */
    code span.bn { color: #40a070; } /* BaseN */
    code span.bu { color: #008000; } /* BuiltIn */
    code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4070a0; } /* Char */
    code span.cn { color: #880000; } /* Constant */
    code span.co { color: #60a0b0; font-style: italic; } /* Comment */
    code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #ba2121; font-style: italic; } /* Documentation */
    code span.dt { color: #902000; } /* DataType */
    code span.dv { color: #40a070; } /* DecVal */
    code span.er { color: #ff0000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #40a070; } /* Float */
    code span.fu { color: #06287e; } /* Function */
    code span.im { color: #008000; font-weight: bold; } /* Import */
    code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #007020; font-weight: bold; } /* Keyword */
    code span.op { color: #666666; } /* Operator */
    code span.ot { color: #007020; } /* Other */
    code span.pp { color: #bc7a00; } /* Preprocessor */
    code span.sc { color: #4070a0; } /* SpecialChar */
    code span.ss { color: #bb6688; } /* SpecialString */
    code span.st { color: #4070a0; } /* String */
    code span.va { color: #19177c; } /* Variable */
    code span.vs { color: #4070a0; } /* VerbatimString */
    code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  \usepackage{listings}
  \usepackage{xcolor}

  \lstset{
      basicstyle=\ttfamily,
      backgroundcolor=\color{black!10},
      showspaces=false,
      showstringspaces=false,
      showtabs=false,
      tabsize=2,
      captionpos=b,
      breaklines=true,
      breakautoindent=true,
      linewidth=\textwidth
  }
</head>
<body>
<nav id="TOC" role="doc-toc">
<ul>
<li><a href="#streams" id="toc-streams">Streams</a>
<ul>
<li><a href="#optional" id="toc-optional">Optional</a></li>
<li><a href="#operations" id="toc-operations">Operations</a>
<ul>
<li><a href="#searching" id="toc-searching">Searching</a></li>
<li><a href="#calculation" id="toc-calculation">Calculation</a></li>
<li><a href="#sorting" id="toc-sorting">Sorting</a></li>
<li><a href="#collecting" id="toc-collecting">Collecting</a></li>
<li><a href="#grouping" id="toc-grouping">Grouping</a></li>
<li><a href="#mapping" id="toc-mapping">Mapping</a></li>
</ul></li>
</ul></li>
<li><a href="#summary" id="toc-summary">Summary</a></li>
</ul>
</nav>
<h1 id="streams">Streams</h1>
<p>Possibly the most important addition to the Java library in the Java
8 release, the stream API. The stream API is part of the
<code>java.util.stream</code> package.</p>
<h2 id="optional">Optional</h2>
<p>The optional class type was introduced to allow users of the language
to express a value that might be empty or in the case of java, null, the
optional class provides certain methods to validate that the value which
it holds is not nil, before it can be used, it also provides convenient
interface to avoid the dreaded
<code>if not nil do-this else do-that</code> blocks which can often make
code less readable, instead the optional interface often provides way to
express these expressions in one line of code, chaining certain
operations.</p>
<p>One can certainly think of the Optional class / interface as a Stream
with one element only, since some of the methods do match the ones in
the Stream interface, Optional values can be extracted, mapped and
filtered</p>
<p>To create a Optional object there are several options by default
provided by default from the language</p>
<ul>
<li><p>Creating from no value - <code>Optional.empty()</code> - this is
usually required when for example a method that returns an optional
value does not find any value to return, so instead of returning plain
<code>null</code> the empty optional is preferred</p></li>
<li><p>Creating from concrete value -
<code>Optional.of(&lt;value&gt;)</code> - wrapping a value in an
optional, can be done by using the Optional.of(variable), note that this
method is nil checking, if the variable is nil, calling this method will
throw an exception.</p></li>
<li><p>Creating from nullable value -
<code>Optional.ofNullable(&lt;value&gt;)</code> - allows one to create
both an empty and non-empty optional with a single statement, meaning
that if the value is nil, the optional that will be created is an empty
one, and exception will NOT be thrown</p></li>
</ul>
<p>The optional class type similarly to the streams has also primitive
versions - <code>OptionalDouble</code>, <code>OptionalLong</code>,
<code>OptionalInt</code>, the interface of these optional types is
pretty much the same as the regular Optional type, however with some
very slight differences, they also do not inherit from the Optional
type, just as like the primitive streams does not inherit from Stream,
only from <code>BaseStream</code></p>
<div class="sourceCode" id="cb1"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>DoubleStream temperatures <span class="op">=</span> DoubleStream<span class="op">.</span><span class="fu">of</span><span class="op">(</span><span class="fl">24.5</span><span class="op">,</span> <span class="fl">23.6</span><span class="op">,</span> <span class="fl">27.9</span><span class="op">,</span> <span class="fl">21.1</span><span class="op">,</span> <span class="fl">23.5</span><span class="op">,</span> <span class="fl">25.5</span><span class="op">,</span> <span class="fl">28.3</span><span class="op">);</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>OptionalDouble max <span class="op">=</span> temperatures<span class="op">.</span><span class="fu">max</span><span class="op">();</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>max<span class="op">.</span><span class="fu">ifPresent</span><span class="op">(</span><span class="bu">System</span><span class="op">.</span><span class="fu">out</span><span class="op">::</span>println<span class="op">);</span></span></code></pre></div>
<p><code>The primitive versions of the Streams use the primitive versions of the Optional types, which should be obvious and expected, the primitive streams do not interact with the base Optional non-primitive type, as it is only a wrapper around object / class type and can not be used on primitive types</code></p>
<p>Note that of course there is a way to convert between the primitive
version of the optional and the object type by simply for example using
the auto-boxed numeric types, which are classes</p>
<h2 id="operations">Operations</h2>
<p>There are certain important operations which are exposed by the
stream API, to allow one to search, filter and convert data in the
stream. They are used to build up the stream transformation pipeline</p>
<h3 id="searching">Searching</h3>
<p>Methods ending with the word “Match and methods starting with the
word”find” in the Stream interface are useful for searching data from
the stream. These methods return a <code>boolean</code> value. For
searching operations <code>findFirst()</code> and <code>findAny()</code>
matching elements may not be present in the Stream, so they return
Optional<T></p>
<table>
<colgroup>
<col style="width: 21%" />
<col style="width: 78%" />
</colgroup>
<thead>
<tr class="header">
<th>Method</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>boolean anyMatch(Predicate&lt;? super T&gt; check)</td>
<td>Returns true if there is any elements in the stream that matches the
given predicate. Returns false if the stream is empty or if there are no
matching elements.</td>
</tr>
<tr class="even">
<td>boolean allMatch(Predicate&lt;? super T&gt; check)</td>
<td>Returns true only if all elements in the stream matches the given
predicate. Returns true if the stream is empty without evaluating the
predicate!</td>
</tr>
<tr class="odd">
<td>boolean noneMatch(Predicate&lt;? super T&gt; check)</td>
<td>Returns true only if none of the elements in the stream matches the
given predicate. Returns true if the stream is empty without evaluating
the predicate!</td>
</tr>
<tr class="even">
<td>Optional<T> findFirst()</td>
<td>Returns the first element from the stream; if there is no element
present in the stream, it returns an empty Optional<T> object.</td>
</tr>
<tr class="odd">
<td>Optional<T> findAny()</td>
<td>Returns one of the elements from the stream; if there is no element
present in the stream, it returns an empty Optional<T> object.</td>
</tr>
</tbody>
</table>
<p><code>Unlike the anyMatch() method that returns false when the stream is empty the allMatch() and noneMatch() return true if the stream is empty. Which should be rather obvious, since no elements in the stream will always imply that match allMatch() or noneMatch() return true for any condition for those methods</code></p>
<div class="sourceCode" id="cb2"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="dt">boolean</span> anyMatch <span class="op">=</span> IntStream<span class="op">.</span><span class="fu">of</span><span class="op">(-</span><span class="dv">56</span><span class="op">,</span> <span class="op">-</span><span class="dv">57</span><span class="op">,</span> <span class="op">-</span><span class="dv">55</span><span class="op">,</span> <span class="op">-</span><span class="dv">52</span><span class="op">,</span> <span class="op">-</span><span class="dv">48</span><span class="op">,</span> <span class="op">-</span><span class="dv">51</span><span class="op">,</span> <span class="op">-</span><span class="dv">49</span><span class="op">).</span><span class="fu">anyMatch</span><span class="op">(</span>temp <span class="op">-&gt;</span> temp <span class="op">&gt;</span> <span class="dv">0</span><span class="op">);</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="bu">System</span><span class="op">.</span><span class="fu">out</span><span class="op">.</span><span class="fu">println</span><span class="op">(</span><span class="st">&quot;anyMatch(temp -&gt; temp &gt; 0): &quot;</span> <span class="op">+</span> anyMatch<span class="op">);</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a><span class="dt">boolean</span> allMatch <span class="op">=</span> IntStream<span class="op">.</span><span class="fu">of</span><span class="op">(-</span><span class="dv">56</span><span class="op">,</span> <span class="op">-</span><span class="dv">57</span><span class="op">,</span> <span class="op">-</span><span class="dv">55</span><span class="op">,</span> <span class="op">-</span><span class="dv">52</span><span class="op">,</span> <span class="op">-</span><span class="dv">48</span><span class="op">,</span> <span class="op">-</span><span class="dv">51</span><span class="op">,</span> <span class="op">-</span><span class="dv">49</span><span class="op">).</span><span class="fu">allMatch</span><span class="op">(</span>temp <span class="op">-&gt;</span> temp <span class="op">&gt;</span> <span class="dv">0</span><span class="op">);</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a><span class="bu">System</span><span class="op">.</span><span class="fu">out</span><span class="op">.</span><span class="fu">println</span><span class="op">(</span><span class="st">&quot;allMatch(temp -&gt; temp &gt; 0): &quot;</span> <span class="op">+</span> allMatch<span class="op">);</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a><span class="dt">boolean</span> noneMatch <span class="op">=</span> IntStream<span class="op">.</span><span class="fu">of</span><span class="op">(-</span><span class="dv">56</span><span class="op">,</span> <span class="op">-</span><span class="dv">57</span><span class="op">,</span> <span class="op">-</span><span class="dv">55</span><span class="op">,</span> <span class="op">-</span><span class="dv">52</span><span class="op">,</span> <span class="op">-</span><span class="dv">48</span><span class="op">,</span> <span class="op">-</span><span class="dv">51</span><span class="op">,</span> <span class="op">-</span><span class="dv">49</span><span class="op">).</span><span class="fu">noneMatch</span><span class="op">(</span>temp <span class="op">-&gt;</span> temp <span class="op">&gt;</span> <span class="dv">0</span><span class="op">);</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a><span class="bu">System</span><span class="op">.</span><span class="fu">out</span><span class="op">.</span><span class="fu">println</span><span class="op">(</span><span class="st">&quot;noneMatch(temp -&gt; temp &gt; 0): &quot;</span> <span class="op">+</span> noneMatch<span class="op">);</span></span></code></pre></div>
<p>The example above demonstrates a simple usage of the matching
functions, those are useful to avoid filtering first and then checking
the size count/size of the final collection, instead, this operation is
condensed into a single searching operation instead.</p>
<p>The other companion function to the <code>boolean</code> any/all/none
match, are the find first and any, the example below demonstrates how
one can use a transformation pipeline to first filter on all methods in
the Stream API / interface, that end with “Match”, sort and then extract
the first one that is found, in this case the sorting will be in
ascending order, in that case the <code>allMatch</code>, since all is
sorted before <code>anyMatch</code>, and <code>noneMatch</code>. Note
that the find similarly to the boolean match methods, are also
terminating operations</p>
<div class="sourceCode" id="cb3"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="bu">Method</span><span class="op">[]</span> methods <span class="op">=</span> Stream<span class="op">.</span><span class="fu">class</span><span class="op">.</span><span class="fu">getMethods</span><span class="op">();</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>Optional<span class="op">&lt;</span><span class="bu">String</span><span class="op">&gt;</span> methodName <span class="op">=</span> <span class="bu">Arrays</span><span class="op">.</span><span class="fu">stream</span><span class="op">(</span>methods<span class="op">)</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>                    <span class="op">.</span><span class="fu">map</span><span class="op">(</span>method <span class="op">-&gt;</span> method<span class="op">.</span><span class="fu">getName</span><span class="op">())</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>                    <span class="op">.</span><span class="fu">filter</span><span class="op">(</span>name <span class="op">-&gt;</span> name<span class="op">.</span><span class="fu">endsWith</span><span class="op">(</span><span class="st">&quot;Match&quot;</span><span class="op">))</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>                    <span class="op">.</span><span class="fu">sorted</span><span class="op">()</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>                    <span class="op">.</span><span class="fu">findFirst</span><span class="op">();</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a><span class="bu">System</span><span class="op">.</span><span class="fu">out</span><span class="op">.</span><span class="fu">println</span><span class="op">(</span><span class="st">&quot;Result: &quot;</span> <span class="op">+</span> methodName<span class="op">.</span><span class="fu">orElse</span><span class="op">(</span><span class="st">&quot;No suitable method found&quot;</span><span class="op">));</span></span></code></pre></div>
<p><code>The reason there are two find methods in the API, is that the method called findAny is tailored for usecases which involve parallel streams, however for any streams, the findFirst is always defined to return the first element in the stream, however the findAny's behavior is not defined for normal and parallel streams, it may return any element in the stream, especially true for parallel streams.</code></p>
<p>It is prudent to note that the match and find operations are
short-circuiting in nature, meaning that the moment they find the
matching element they will terminate, and the iteration over the rest of
the entries in the stream is not done.</p>
<h3 id="calculation">Calculation</h3>
<p>There are certain calculation methods on the Stream and primitive
streams API. Methods like min(), max() and average(). These operations
are also called implicit <code>reducers</code>, since internally they
are implemented using the reduce method of the stream, which is made to
accumulate a result of some computation and then returns that result.
The reduce() method is however much more general and has applications
outside the simple operations such as the ones listed above.</p>
<div class="sourceCode" id="cb4"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="bu">String</span><span class="op">[]</span> string <span class="op">=</span> <span class="st">&quot;you never know what you have until you clean your room&quot;</span><span class="op">.</span><span class="fu">split</span><span class="op">(</span><span class="st">&quot; &quot;</span><span class="op">);</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="bu">System</span><span class="op">.</span><span class="fu">out</span><span class="op">.</span><span class="fu">println</span><span class="op">(</span><span class="bu">Arrays</span><span class="op">.</span><span class="fu">stream</span><span class="op">(</span>string<span class="op">).</span><span class="fu">min</span><span class="op">(</span><span class="bu">String</span><span class="op">::</span>compareTo<span class="op">).</span><span class="fu">get</span><span class="op">());</span></span></code></pre></div>
<p>The min and max methods in the Stream version (non primitive one)
require a comparator to be passed in in order for the min/max
calculation to be performed, otherwise there is no way to truly find a
meaningful result to the min/max expression. For the primitive versions
of the streams, that is not necessary, since the integral types have
well defined comparison rules.</p>
<table>
<colgroup>
<col style="width: 29%" />
<col style="width: 70%" />
</colgroup>
<thead>
<tr class="header">
<th>Method</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>long count()</td>
<td>Returns the number of elements in the stream; 0 if the stream is
empty.</td>
</tr>
<tr class="even">
<td>Optional<T> min(Comparator&lt;? super T&gt; comparator)</td>
<td>Returns the minimum value in the stream; an empty Optional value in
case the stream is empty.</td>
</tr>
<tr class="odd">
<td>Optional<T> max(Comparator&lt;? super T&gt; comparator)</td>
<td>Returns the maximum value in the stream; an empty Optional value in
case the stream is empty.</td>
</tr>
<tr class="even">
<td>—————————————-</td>
<td>——————————————————————————————————————-</td>
</tr>
<tr class="odd">
<td>int sum()</td>
<td>Returns the sum of elements in the stream; 0 in case the stream is
empty.</td>
</tr>
<tr class="even">
<td>long count()</td>
<td>Returns the number of elements in the stream; 0 if the stream is
empty.</td>
</tr>
<tr class="odd">
<td>Optional{Primitive} min()</td>
<td>Returns the minimum integer value in the stream; an empty
Optional{Primitive} value in case the stream is empty.</td>
</tr>
<tr class="even">
<td>Optional{Primitive} max()</td>
<td>Returns the maximum integer value in the stream; an empty
Optional{Primitive} value in case the stream is empty.</td>
</tr>
<tr class="odd">
<td>OptionalDouble average()</td>
<td>Returns the average value of the elements in the stream; an empty
OptionalDouble value in case the stream is empty.</td>
</tr>
<tr class="even">
<td>{Primitive}SummaryStatistics summaryStatistics()</td>
<td>Returns an {Primitive}SummaryStatistics object that has sum, count,
average, min, and max values.</td>
</tr>
</tbody>
</table>
<p>The table above shows the interfaces for both the Stream and
primitive Stream versions, note that not all methods from the primitive
versions are present in the base Stream API. That is because not all of
them make sense on non primitive types such as <code>sum</code> or
<code>average</code> for example</p>
<p>The <code>summaryStatistics</code> is one of the more interesting
methods, it provides a detailed information about the contents of the
stream, things like average, min, max and sum in one shot, basically
collates the calls to all methods into one object, which can be used to
obtain information about the stream, since after calling the sum or
count the stream will be otherwise closed, and unable to call any more
termination operations on it</p>
<div class="sourceCode" id="cb5"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="bu">String</span> limerick <span class="op">=</span> <span class="st">&quot;There was a young lady named Bright &quot;</span> <span class="op">+</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>                    <span class="st">&quot;who traveled much faster than light &quot;</span> <span class="op">+</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>                    <span class="st">&quot;She set out one day &quot;</span> <span class="op">+</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>                    <span class="st">&quot;in a relative way &quot;</span> <span class="op">+</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>                    <span class="st">&quot;and came back the previous night &quot;</span><span class="op">;</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>IntSummaryStatistics wordStatistics <span class="op">=</span> <span class="bu">Pattern</span><span class="op">.</span><span class="fu">compile</span><span class="op">(</span><span class="st">&quot; &quot;</span><span class="op">)</span></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>                    <span class="op">.</span><span class="fu">splitAsStream</span><span class="op">(</span>limerick<span class="op">)</span></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>                    <span class="op">.</span><span class="fu">mapToInt</span><span class="op">(</span>word <span class="op">-&gt;</span> word<span class="op">.</span><span class="fu">length</span><span class="op">())</span></span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a>                    <span class="op">.</span><span class="fu">summaryStatistics</span><span class="op">();</span></span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a><span class="bu">System</span><span class="op">.</span><span class="fu">out</span><span class="op">.</span><span class="fu">printf</span><span class="op">(</span><span class="st">&quot; Number of words = </span><span class="sc">%d</span><span class="st"> </span><span class="sc">\n</span><span class="st"> Sum of the length of the words = </span><span class="sc">%d</span><span class="st"> </span><span class="sc">\n</span><span class="st">&quot;</span> <span class="op">+</span></span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a>                    <span class="st">&quot; Minimum word size = </span><span class="sc">%d</span><span class="st"> </span><span class="sc">\n</span><span class="st"> Maximum word size </span><span class="sc">%d</span><span class="st"> </span><span class="sc">\n</span><span class="st"> &quot;</span> <span class="op">+</span></span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a>                    <span class="st">&quot; Average word size = </span><span class="sc">%f</span><span class="st"> </span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> wordStatistics<span class="op">.</span><span class="fu">getCount</span><span class="op">(),</span></span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true" tabindex="-1"></a>                    wordStatistics<span class="op">.</span><span class="fu">getSum</span><span class="op">(),</span> wordStatistics<span class="op">.</span><span class="fu">getMin</span><span class="op">(),</span></span>
<span id="cb5-15"><a href="#cb5-15" aria-hidden="true" tabindex="-1"></a>                    wordStatistics<span class="op">.</span><span class="fu">getMax</span><span class="op">(),</span> wordStatistics<span class="op">.</span><span class="fu">getAverage</span><span class="op">());</span></span></code></pre></div>
<h3 id="sorting">Sorting</h3>
<p>Sorting is another of the capabilities of the stream, allows the
items within the stream to be ordered based on some sort of criteria.
The method sorted(Compoarator&lt;? super T&gt; compartor) is used to do
that</p>
<div class="sourceCode" id="cb6"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="bu">List</span> words <span class="op">=</span> <span class="bu">Arrays</span><span class="op">.</span><span class="fu">asList</span><span class="op">(</span><span class="st">&quot;follow your heart but take your brain with you&quot;</span><span class="op">.</span><span class="fu">split</span><span class="op">(</span><span class="st">&quot; &quot;</span><span class="op">));</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a><span class="bu">Comparator</span><span class="op">&lt;</span><span class="bu">String</span><span class="op">&gt;</span> lengthCompare <span class="op">=</span> <span class="op">(</span>str1<span class="op">,</span> str2<span class="op">)</span> <span class="op">-&gt;</span> str1<span class="op">.</span><span class="fu">length</span><span class="op">()</span> <span class="op">-</span> str2<span class="op">.</span><span class="fu">length</span><span class="op">();</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>words<span class="op">.</span><span class="fu">stream</span><span class="op">().</span><span class="fu">distinct</span><span class="op">().</span><span class="fu">sorted</span><span class="op">(</span>lengthCompare<span class="op">).</span><span class="fu">forEach</span><span class="op">(</span><span class="bu">System</span><span class="op">.</span><span class="fu">out</span><span class="op">::</span>println<span class="op">);</span></span></code></pre></div>
<p>The example splits the string into words, and they are sorted based
on the length of the words, in this case in ascending order (since the
comparison is doing left.length - right.length).</p>
<p>Now what if one wanted to sort them based on their length and then
alphabetically, the <code>Compartor</code> method has additional ways of
chaining comparison operations.</p>
<div class="sourceCode" id="cb7"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="co">// compare and sort based on the length of the words first, then do an alphabetically, the way thenComparing works, is</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a><span class="co">// if the first comparator considers the two entries to be equal, then the second comparator, in this case</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a><span class="co">// String::compareTo, is used to resolve the comparison operations, these can be chained as many times, since thenComparing</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a><span class="co">// variants return a comparator instance</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>words<span class="op">.</span><span class="fu">stream</span><span class="op">()</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">.</span><span class="fu">distinct</span><span class="op">()</span></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">.</span><span class="fu">sorted</span><span class="op">(</span>lengthCompare<span class="op">.</span><span class="fu">thenComparing</span><span class="op">(</span><span class="bu">String</span><span class="op">::</span>compareTo<span class="op">))</span></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">.</span><span class="fu">forEach</span><span class="op">(</span><span class="bu">System</span><span class="op">.</span><span class="fu">out</span><span class="op">::</span>println<span class="op">);</span></span></code></pre></div>
<p>Another option is to reverse the order of the sorting, by default the
compator functions, by convention should sort in ascending order,
comparing the first to second argument, the way they are passed in to
the compareTo method by the sorting algorithm internally, however to
obtain a reverse order there are two ways - modify the compartor to
compare the second to the first argument, which is not always possible,
if re-using existing comparison method (i.e. String::compareTo) or to
use reversed(), which basically wraps the previous comparator instance,
previously chained, internally, calling the compare to with swapped
arguments instead</p>
<div class="sourceCode" id="cb8"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="co">// the compartor interface also provides means of reversing the natural order, by calling reversed, what it does is</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a><span class="co">// return an instance of comparator which wraps the previous one chained, and simply inverts the passed arguments to the</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a><span class="co">// compare to method, so instead of comparing (a, b) it executes the comparator with (b, a), which reversed the order in</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a><span class="co">// essence</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>words<span class="op">.</span><span class="fu">stream</span><span class="op">()</span></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">.</span><span class="fu">distinct</span><span class="op">()</span></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">.</span><span class="fu">sorted</span><span class="op">(</span>lengthCompare<span class="op">.</span><span class="fu">thenComparing</span><span class="op">(</span><span class="bu">String</span><span class="op">::</span>compareTo<span class="op">).</span><span class="fu">reversed</span><span class="op">())</span></span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">.</span><span class="fu">forEach</span><span class="op">(</span><span class="bu">System</span><span class="op">.</span><span class="fu">out</span><span class="op">::</span>println<span class="op">);</span></span></code></pre></div>
<p><code>The natural order term which is often used in the Comparable and Comparator interface is the default order which is implied when comparing, as mentioned above, that is comparing the elements in the order they are passed to the compare method, this is done to avoid confusion and introduce a consistency across the API.</code></p>
<h3 id="collecting">Collecting</h3>
<p>The stream API has several methods which allows the transformation to
be captured in a re-usable data structure, after the transformation
pipeline has finished and all the operations chained on it have
finished.</p>
<p>There is one generic method - collect, which accepts a Collector
interface on its input, allowing the elements of the stream to be
collected in an arbitrary way, there are also helper functions which
provide a pre-defined collectors for list, set and map.</p>
<div class="sourceCode" id="cb9"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="co">// this simple example splits words : into a stream and then collects them into a list, note the usage of the</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a><span class="co">// pre-defined toList method in the Collectors interface, which provides a dirty and fast way to simply provide a</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a><span class="co">// container, by default ArrayList, where to collect the entries of the stream</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a><span class="bu">String</span> frenchCounting <span class="op">=</span> <span class="st">&quot;un:deux:trois:quatre&quot;</span><span class="op">;</span></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a><span class="bu">List</span> gmailList <span class="op">=</span> <span class="bu">Pattern</span><span class="op">.</span><span class="fu">compile</span><span class="op">(</span><span class="st">&quot;:&quot;</span><span class="op">)</span></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>                <span class="op">.</span><span class="fu">splitAsStream</span><span class="op">(</span>frenchCounting<span class="op">)</span></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>                <span class="op">.</span><span class="fu">collect</span><span class="op">(</span>Collectors<span class="op">.</span><span class="fu">toList</span><span class="op">());</span></span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a>gmailList<span class="op">.</span><span class="fu">forEach</span><span class="op">(</span><span class="bu">System</span><span class="op">.</span><span class="fu">out</span><span class="op">::</span>println<span class="op">);</span></span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a><span class="co">// similar example as the one above, using the pre-defined method toSet from the Collectors, in this case by default the</span></span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a><span class="co">// set that is created is HashSet, where each element is hashed using the hashCode of the object and put into the set,</span></span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true" tabindex="-1"></a><span class="co">// remember that sets do not allow duplicate values</span></span>
<span id="cb9-13"><a href="#cb9-13" aria-hidden="true" tabindex="-1"></a><span class="bu">String</span> <span class="op">[]</span>roseQuote <span class="op">=</span> <span class="st">&quot;a rose is a rose is a rose&quot;</span><span class="op">.</span><span class="fu">split</span><span class="op">(</span><span class="st">&quot; &quot;</span><span class="op">);</span></span>
<span id="cb9-14"><a href="#cb9-14" aria-hidden="true" tabindex="-1"></a><span class="bu">Set</span> words <span class="op">=</span> <span class="bu">Arrays</span><span class="op">.</span><span class="fu">stream</span><span class="op">(</span>roseQuote<span class="op">).</span><span class="fu">collect</span><span class="op">(</span>Collectors<span class="op">.</span><span class="fu">toSet</span><span class="op">());</span></span>
<span id="cb9-15"><a href="#cb9-15" aria-hidden="true" tabindex="-1"></a>words<span class="op">.</span><span class="fu">forEach</span><span class="op">(</span><span class="bu">System</span><span class="op">.</span><span class="fu">out</span><span class="op">::</span>println<span class="op">);</span></span>
<span id="cb9-16"><a href="#cb9-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-17"><a href="#cb9-17" aria-hidden="true" tabindex="-1"></a><span class="co">// in this example the more complex mapping is used, the Collectors also provide a toMap method, which however accepts</span></span>
<span id="cb9-18"><a href="#cb9-18" aria-hidden="true" tabindex="-1"></a><span class="co">// at least two arguments (there are overloads which make it take up to four). The first one is how to map the key of the</span></span>
<span id="cb9-19"><a href="#cb9-19" aria-hidden="true" tabindex="-1"></a><span class="co">// HashMap from the stream entry, the second is the value for this key mapping, in the example below, the key entry itself,</span></span>
<span id="cb9-20"><a href="#cb9-20" aria-hidden="true" tabindex="-1"></a><span class="co">// the value is the string entry length</span></span>
<span id="cb9-21"><a href="#cb9-21" aria-hidden="true" tabindex="-1"></a><span class="bu">Map</span><span class="op">&lt;</span><span class="bu">String</span><span class="op">,</span> <span class="bu">Integer</span><span class="op">&gt;</span> nameLength <span class="op">=</span> Stream<span class="op">.</span><span class="fu">of</span><span class="op">(</span><span class="st">&quot;Arnold&quot;</span><span class="op">,</span> <span class="st">&quot;Alois&quot;</span><span class="op">,</span> <span class="st">&quot;Schwarzenegger&quot;</span><span class="op">)</span></span>
<span id="cb9-22"><a href="#cb9-22" aria-hidden="true" tabindex="-1"></a><span class="op">.</span><span class="fu">collect</span><span class="op">(</span>Collectors<span class="op">.</span><span class="fu">toMap</span><span class="op">(</span>name <span class="op">-&gt;</span> name<span class="op">,</span> name <span class="op">-&gt;</span> name<span class="op">.</span><span class="fu">length</span><span class="op">()));</span></span>
<span id="cb9-23"><a href="#cb9-23" aria-hidden="true" tabindex="-1"></a>nameLength<span class="op">.</span><span class="fu">forEach</span><span class="op">((</span>name<span class="op">,</span> len<span class="op">)</span> <span class="op">-&gt;</span> <span class="bu">System</span><span class="op">.</span><span class="fu">out</span><span class="op">.</span><span class="fu">printf</span><span class="op">(</span><span class="st">&quot;</span><span class="sc">%s</span><span class="st"> - </span><span class="sc">%d</span><span class="st"> </span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> name<span class="op">,</span> len<span class="op">));</span></span>
<span id="cb9-24"><a href="#cb9-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-25"><a href="#cb9-25" aria-hidden="true" tabindex="-1"></a><span class="co">// this example shows how to provide a custom lambda reference for the creation of the collection, since all collections</span></span>
<span id="cb9-26"><a href="#cb9-26" aria-hidden="true" tabindex="-1"></a><span class="co">// have a way to add elements, in the most simplest collection, one needs provide only a way to create the desired</span></span>
<span id="cb9-27"><a href="#cb9-27" aria-hidden="true" tabindex="-1"></a><span class="co">// collection, the rest is handled internally, adding the elements of the Stream to that collection instance</span></span>
<span id="cb9-28"><a href="#cb9-28" aria-hidden="true" tabindex="-1"></a><span class="bu">String</span> <span class="op">[]</span>roseQuote <span class="op">=</span> <span class="st">&quot;a rose is a rose is a rose&quot;</span><span class="op">.</span><span class="fu">split</span><span class="op">(</span><span class="st">&quot; &quot;</span><span class="op">);</span></span>
<span id="cb9-29"><a href="#cb9-29" aria-hidden="true" tabindex="-1"></a><span class="bu">Set</span> words <span class="op">=</span> <span class="bu">Arrays</span><span class="op">.</span><span class="fu">stream</span><span class="op">(</span>roseQuote<span class="op">).</span><span class="fu">collect</span><span class="op">(</span>Collectors<span class="op">.</span><span class="fu">toCollection</span><span class="op">(</span><span class="bu">TreeSet</span><span class="op">::</span><span class="kw">new</span><span class="op">));</span></span>
<span id="cb9-30"><a href="#cb9-30" aria-hidden="true" tabindex="-1"></a>words<span class="op">.</span><span class="fu">forEach</span><span class="op">(</span><span class="bu">System</span><span class="op">.</span><span class="fu">out</span><span class="op">::</span>println<span class="op">);</span></span></code></pre></div>
<h3 id="grouping">Grouping</h3>
<p>There is another sub-set of collection operations which is the
grouping, the grouping operation provides a way to create a collation of
the map entries based on some criteria, i.e. to group them based on
certain rule, in this case for the grouping result a Map is always used,
where the key of the map is the unique criteria, and the value of the
Map, is a List, where the list represents all the values which match the
criteria</p>
<div class="sourceCode" id="cb10"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="co">// this simple example simply groups all words in the split string based on the length of the word, the final map will</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a><span class="co">// have keys which describe the length, and a list of words which match these lengths as the value</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a><span class="bu">String</span> <span class="op">[]</span>string<span class="op">=</span> <span class="st">&quot;you never know what you have until you clean your room&quot;</span><span class="op">.</span><span class="fu">split</span><span class="op">(</span><span class="st">&quot; &quot;</span><span class="op">);</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>Stream<span class="op">&lt;</span><span class="bu">String</span><span class="op">&gt;</span> distinctWords <span class="op">=</span> <span class="bu">Arrays</span><span class="op">.</span><span class="fu">stream</span><span class="op">(</span>string<span class="op">).</span><span class="fu">distinct</span><span class="op">();</span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a><span class="bu">Map</span><span class="op">&lt;</span><span class="bu">Integer</span><span class="op">,</span> <span class="bu">List</span><span class="op">&lt;</span><span class="bu">String</span><span class="op">&gt;&gt;</span> wordGroups <span class="op">=</span> distinctWords<span class="op">.</span><span class="fu">collect</span><span class="op">(</span>Collectors<span class="op">.</span><span class="fu">groupingBy</span><span class="op">(</span><span class="bu">String</span><span class="op">::</span>length<span class="op">));</span></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a><span class="co">// the example below shows a special case of grouping which partition, the partition is pretty much like grouping but</span></span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a><span class="co">// instead of resolving to one concrete value for each group, the values are loosely grouped, in the example, all words</span></span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a><span class="co">// with length less than 4 are grouped in the map key {false} and all words with length greater than 4 are grouped under the</span></span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a><span class="co">// map key of {true}. Note the map is not keyed on Integer, but rather on the result of the grouping which in this case</span></span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a><span class="co">// is a boolean one, either the length is greater than 4 or not</span></span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true" tabindex="-1"></a><span class="bu">String</span> <span class="op">[]</span>string<span class="op">=</span> <span class="st">&quot;you never know what you have until you clean your room&quot;</span><span class="op">.</span><span class="fu">split</span><span class="op">(</span><span class="st">&quot; &quot;</span><span class="op">);</span></span>
<span id="cb10-13"><a href="#cb10-13" aria-hidden="true" tabindex="-1"></a>Stream<span class="op">&lt;</span><span class="bu">String</span><span class="op">&gt;</span> distinctWords <span class="op">=</span> <span class="bu">Arrays</span><span class="op">.</span><span class="fu">stream</span><span class="op">(</span>string<span class="op">).</span><span class="fu">distinct</span><span class="op">();</span></span>
<span id="cb10-14"><a href="#cb10-14" aria-hidden="true" tabindex="-1"></a><span class="bu">Map</span><span class="op">&lt;</span><span class="bu">Boolean</span><span class="op">,</span> <span class="bu">List</span><span class="op">&lt;</span><span class="bu">String</span><span class="op">&gt;&gt;</span> wordBlocks <span class="op">=</span></span>
<span id="cb10-15"><a href="#cb10-15" aria-hidden="true" tabindex="-1"></a>distinctWords<span class="op">.</span><span class="fu">collect</span><span class="op">(</span>Collectors<span class="op">.</span><span class="fu">partitioningBy</span><span class="op">(</span>str <span class="op">-&gt;</span> str<span class="op">.</span><span class="fu">length</span><span class="op">()</span> <span class="op">&gt;</span> <span class="dv">4</span><span class="op">));</span></span></code></pre></div>
<p><code>The groupingBy method always accepts at least one argument which is a of the type Function from the functional interface, however the partitioningBy always accepts an argument of type Predicate again from the functional interface package java.util.function. This is due to the nature of both methods - one groups the entries into neat buckets, while the other splits them into at most two groups, ones that match the predicate and the rest that do not</code></p>
<h3 id="mapping">Mapping</h3>
<p>Mapping is the process of converting the starting type of the stream
entry, to another one, these operations can be chained, meaning that
unlimited calls to .map can be made transforming each preceding type
into a new one. Mapping is very handy when the starting type of the
stream entries is not suitable to perform some sort of operations and
one wishes to refine the type, so the calculation can be performed more
efficiently or performed at all in the first place</p>
<div class="sourceCode" id="cb11"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="bu">List</span><span class="op">&lt;</span><span class="bu">Integer</span><span class="op">&gt;</span> integers <span class="op">=</span> <span class="bu">Arrays</span><span class="op">.</span><span class="fu">asList</span><span class="op">(</span><span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span><span class="op">,</span> <span class="dv">4</span><span class="op">,</span> <span class="dv">5</span><span class="op">);</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>integers<span class="op">.</span><span class="fu">stream</span><span class="op">()</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>        <span class="op">.</span><span class="fu">map</span><span class="op">(</span>i <span class="op">-&gt;</span> i <span class="op">*</span> i<span class="op">)</span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>        <span class="op">.</span><span class="fu">forEach</span><span class="op">(</span><span class="bu">System</span><span class="op">.</span><span class="fu">out</span><span class="op">::</span>println<span class="op">);</span></span></code></pre></div>
<p>The example above simply finds and converts the map entries into
their squares, the mapped type is not changed however, it still remains
an Integer, only the value is. However this is the most simplest
demonstration of what mapping means, it allows one to mutate each entry
of the stream, the value and even the its type, however note that each
map must return the same type. It is not possible to return
heterogeneous types (unless they are all children of the same super
type)</p>
<table>
<colgroup>
<col style="width: 46%" />
<col style="width: 53%" />
</colgroup>
<thead>
<tr class="header">
<th>Method</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>DoubleStream mapToDouble(ToDoubleFunction&lt;? super T&gt;)</td>
<td>Maps the current stream into a primitive double stream</td>
</tr>
<tr class="even">
<td>LongStream mapToLong(ToLongFunction&lt;? super T&gt;)</td>
<td>Maps the current stream into a primitive long stream</td>
</tr>
<tr class="odd">
<td>IntStream mapToInt(ToIntFunction&lt;? super T&gt;)</td>
<td>Maps the current stream into a primitive integer stream</td>
</tr>
<tr class="even">
<td>Stream<T> map(Function&lt;? super T, ? extends R&gt;) <R></td>
<td>Maps the current stream into one containing elements of type T</td>
</tr>
</tbody>
</table>
<p>Flat mapping is a special case of the regular mapping, it is usually
used when the source collection is a nested 2 or N dimensional one, in
the most simplest example a 2 dimensional array, flat mapping means that
this structure will be reduced into a single dimension or level after
the mapping. Flat map always accepts a Function which as an input
argument takes the current type of entry in the stream and returns a
Stream (or the primitive versions of the streams).</p>
<table>
<colgroup>
<col style="width: 86%" />
<col style="width: 13%" />
</colgroup>
<thead>
<tr class="header">
<th>Method</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>DoubleStream flatMapToDouble(Function&lt;? super T, ? extends
DoubleStream&gt;)</td>
<td></td>
</tr>
<tr class="even">
<td>LongStream flatMapToLong(Function&lt;? super T, ? extends
LongStream&gt;)</td>
<td></td>
</tr>
<tr class="odd">
<td>IntStream flatMapToInt(Function&lt;? super T, ? extends
IntStream&gt;)</td>
<td></td>
</tr>
<tr class="even">
<td>Stream<T> flatMap(Function&lt;? super T, ? extends Stream&lt;?
extends R&gt;&gt;) <R></td>
<td></td>
</tr>
</tbody>
</table>
<div class="sourceCode" id="cb12"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="co">// this example the stream starts as a stream of words, however the desired effect is to find the unique characters in</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a><span class="co">// the sentence, therefore each word has to be split into characters, then only the unique ones extracted, however each</span></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a><span class="co">// word is an array of characters, therefore this example will not work, since the map method here would map the &#39;word&#39;</span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a><span class="co">// entry to a String[], why an array, calling split on each word, will produce an array of String[].</span></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a><span class="bu">String</span> <span class="op">[]</span>string<span class="op">=</span> <span class="st">&quot;you never know what you have until you clean your room&quot;</span><span class="op">.</span><span class="fu">split</span><span class="op">(</span><span class="st">&quot; &quot;</span><span class="op">);</span></span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a><span class="bu">Arrays</span><span class="op">.</span><span class="fu">stream</span><span class="op">(</span>string<span class="op">)</span></span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a>            <span class="op">.</span><span class="fu">map</span><span class="op">(</span>word <span class="op">-&gt;</span> word<span class="op">.</span><span class="fu">split</span><span class="op">(</span><span class="st">&quot;&quot;</span><span class="op">))</span></span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a>            <span class="op">.</span><span class="fu">distinct</span><span class="op">()</span></span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a>            <span class="op">.</span><span class="fu">forEach</span><span class="op">(</span><span class="bu">System</span><span class="op">.</span><span class="fu">out</span><span class="op">::</span>print<span class="op">);</span></span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true" tabindex="-1"></a><span class="co">// this is the fixed version of the example above, using flatMap, flatMap will make sure that mapping a nested streams</span></span>
<span id="cb12-12"><a href="#cb12-12" aria-hidden="true" tabindex="-1"></a><span class="co">// is flattened out into its composite elements instead.</span></span>
<span id="cb12-13"><a href="#cb12-13" aria-hidden="true" tabindex="-1"></a><span class="bu">String</span> <span class="op">[]</span>string<span class="op">=</span> <span class="st">&quot;you never know what you have until you clean your room&quot;</span><span class="op">.</span><span class="fu">split</span><span class="op">(</span><span class="st">&quot; &quot;</span><span class="op">);</span></span>
<span id="cb12-14"><a href="#cb12-14" aria-hidden="true" tabindex="-1"></a><span class="bu">Arrays</span><span class="op">.</span><span class="fu">stream</span><span class="op">(</span>string<span class="op">)</span></span>
<span id="cb12-15"><a href="#cb12-15" aria-hidden="true" tabindex="-1"></a>            <span class="op">.</span><span class="fu">flatMap</span><span class="op">(</span>word <span class="op">-&gt;</span> <span class="bu">Arrays</span><span class="op">.</span><span class="fu">stream</span><span class="op">(</span>word<span class="op">.</span><span class="fu">split</span><span class="op">(</span><span class="st">&quot;&quot;</span><span class="op">)))</span></span>
<span id="cb12-16"><a href="#cb12-16" aria-hidden="true" tabindex="-1"></a>            <span class="op">.</span><span class="fu">distinct</span><span class="op">()</span></span>
<span id="cb12-17"><a href="#cb12-17" aria-hidden="true" tabindex="-1"></a>            <span class="op">.</span><span class="fu">forEach</span><span class="op">(</span><span class="bu">System</span><span class="op">.</span><span class="fu">out</span><span class="op">::</span>print<span class="op">);</span></span></code></pre></div>
<h1 id="summary">Summary</h1>
<p>Optional</p>
<ul>
<li><p>When there are no entries in a stream and operations such as max
are called, then instead of returning null or throwing an exception, the
(better) approach taken in Java 8 is to return Optional values.</p></li>
<li><p>Primitive type versions of Optional<T> for int, long, and double
are <code>OptionalInteger</code>, <code>OptionalLong</code>, and
<code>OptionalDouble</code> respectively.</p></li>
</ul>
<p>Streams</p>
<ul>
<li><p>The Stream<T> interface has data and calculation methods
<code>count()</code>, <code>min()</code> and <code>max()</code>; you
need to pass a <code>Comparator</code> object as the parameter when
invoking these <code>min()</code> and <code>max()</code>
methods.</p></li>
<li><p>The primitive type versions of Stream interface have the
following data and calculation methods: <code>count()</code>,
<code>sum()</code>, <code>average()</code>, <code>min()</code>, and
<code>max()</code>.</p></li>
<li><p>The <code>summaryStatistics()</code> method in
<code>IntStream</code>, <code>LongStream</code>, and
<code>DoubleStream</code> have methods for calculating count, sum,
average, minimum, and maximum values of elements in the stream.</p></li>
<li><p>The <code>peek()</code> method is useful for debugging: it helps
us understand how the elements are transformed in the pipeline.</p></li>
<li><p>You can transform (or just extract) elements in a stream using
<code>map()</code> method Search for data by using search methods of the
Stream classes including <code>findFirst</code>, <code>findAny</code>,
<code>anyMatch</code>, <code>allMatch</code>,
<code>noneMatch</code></p></li>
<li><p>You can match for a given predicate in a stream using the
<code>allMatch()</code>, <code>noneMatch()</code>, and
<code>anyMatch()</code> methods. Unlike the <code>anyMatch()</code>
method that returns false when the stream is empty, the
<code>allMatch()</code> and <code>noneMatch()</code> methods return true
if the stream is empty.</p></li>
<li><p>You can look for elements in a stream using the
<code>findFirst()</code> and <code>findAny()</code> methods. The
<code>findAny()</code> method is faster to use than the
<code>findFirst()</code> method in case of parallel streams.</p></li>
<li><p>The “match” and “find” methods “short-circuit”: the evaluation
stops once the result is found and the rest of the stream is not
evaluated.</p></li>
</ul>
<p>Comparator &amp; Comparable</p>
<ul>
<li><p>One way to sort a collection is to get a stream from the
collection and call <code>sorted()</code> method on that stream. The
<code>sorted()</code> method sorts the elements in the stream in natural
order (it requires that the stream elements implements the Comparable
interface).</p></li>
<li><p>When you want to sort elements in the stream other than the
natural order, you can pass a <code>Comparator</code> object to the
<code>sorted()</code> method.</p></li>
<li><p>The <code>Comparator</code> interface has been enhanced with many
useful static or default methods in Java 8 such as
<code>thenComparing()</code> and <code>reversed()</code>
methods.</p></li>
</ul>
<p>Collectors &amp; Collections</p>
<ul>
<li><p>The <code>collect()</code> method of the Collectors class has
methods that support the task of collecting elements to a
collection.</p></li>
<li><p>The Collectors class provides methods such as
<code>toList()</code>, <code>toSet()</code>, <code>toMap()</code>, and
<code>toCollection()</code> to create a collection from a
stream.</p></li>
<li><p>You can group the elements in a stream using the
Collectors.<code>groupingBy()</code> method and pass the criteria for
grouping (given as a Function) as the argument.</p></li>
<li><p>You can separate the elements in a stream based on a condition
(given as a Predicate) using the <code>partition()</code> method in the
Collectors class. . Use <code>flatMap()</code> method of the Stream
API</p></li>
<li><p>The <code>flatMap()</code> method in Stream flattens the streams
that result from mapping each element into one flat stream.</p></li>
</ul>
</body>
</html>
