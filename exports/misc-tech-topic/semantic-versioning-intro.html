<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>semantic-versioning-intro</title>
  <style>
    html {
      font-size: 12pt;
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      overflow-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 12px;
      }
      h1 {
        font-size: 1.8em;
      }
    }
    @media print {
      html {
        background-color: white;
      }
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, Consolas, 'Lucida Console', monospace;
      font-size: 85%;
      margin: 0;
      hyphens: manual;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
      overflow-wrap: normal;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      background-color: #1a1a1a;
      border: none;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC ul {
      padding-left: 1.3em;
    }
    #TOC > ul {
      padding-left: 0;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
  </style>
  \usepackage{listings}
  \usepackage{xcolor}

  \lstset{
      basicstyle=\ttfamily,
      backgroundcolor=\color{black!10},
      showspaces=false,
      showstringspaces=false,
      showtabs=false,
      tabsize=2,
      captionpos=b,
      breaklines=true,
      breakautoindent=true,
      linewidth=\textwidth
  }
</head>
<body>
<nav id="TOC" role="doc-toc">
<ul>
<li><a href="#introduction" id="toc-introduction">Introduction</a></li>
<li><a href="#specification" id="toc-specification">Specification</a>
<ul>
<li><a href="#why-use-semantic-versioning"
id="toc-why-use-semantic-versioning">Why use semantic
versioning</a></li>
<li><a href="#frequently-asked-questions"
id="toc-frequently-asked-questions">Frequently asked questions</a>
<ul>
<li><a href="#how-to-deal-with-revision-0.y.z-of-initial-development"
id="toc-how-to-deal-with-revision-0.y.z-of-initial-development">How to
deal with revision 0.y.z of initial development</a></li>
<li><a href="#how-to-know-when-to-release-1.0.0"
id="toc-how-to-know-when-to-release-1.0.0">How to know when to release
1.0.0</a></li>
<li><a
href="#doesnt-this-discourage-rapid-development-and-fact-iteration"
id="toc-doesnt-this-discourage-rapid-development-and-fact-iteration">Doesn’t
this discourage rapid development and fact iteration ?</a></li>
<li><a
href="#if-even-the-tiniest-backward-incompatible-change-to-the-public-api-require-a-major-version-wont-we-end-up-at-version-42.0.0-very-quickly"
id="toc-if-even-the-tiniest-backward-incompatible-change-to-the-public-api-require-a-major-version-wont-we-end-up-at-version-42.0.0-very-quickly">If
even the tiniest backward incompatible change to the public API require
a major version, won’t we end up at version 42.0.0 very quickly</a></li>
<li><a href="#documentation-is-too-much-work"
id="toc-documentation-is-too-much-work">Documentation is too much
work</a></li>
<li><a
href="#what-to-do-if-accidentally-a-backward-incompatible-change-is-released-as-a-minor-version"
id="toc-what-to-do-if-accidentally-a-backward-incompatible-change-is-released-as-a-minor-version">What
to do if accidentally a backward incompatible change is released as a
minor version</a></li>
<li><a href="#how-to-handle-deprecated-functionality"
id="toc-how-to-handle-deprecated-functionality">How to handle deprecated
functionality</a></li>
<li><a href="#does-semver-have-a-size-limit-of-the-version-string"
id="toc-does-semver-have-a-size-limit-of-the-version-string">Does SemVer
have a size limit of the version string</a></li>
<li><a href="#is-v1.2.3-a-valid-semantic-version"
id="toc-is-v1.2.3-a-valid-semantic-version">Is “v1.2.3” a valid semantic
version</a></li>
</ul></li>
</ul></li>
</ul>
</nav>
<h1 id="introduction">Introduction</h1>
<p>Given a version number <code>MAJOR.MINOR.PATCH</code> increment
the:</p>
<ol type="1">
<li><code>MAJOR</code> - version when you make incompatible API
changes</li>
<li><code>MINOR</code> - version when you add functionality in a
backward compatible manner</li>
<li><code>PATCH</code> - version when you make backward compatible bug
fixes</li>
</ol>
<p>Additional labels for <code>pre-release</code> and build
<code>metadata</code> are available as extensions to the
<code>MAJOR.MINOR.PATCH</code> format</p>
<p>In the world of software management there exists a dreaded place
called dependency hell. The bigger your system grows and the more
packages you integrate into your software, the more likely you are to
find yourself one day in this pit of despair.</p>
<p>In systems with many dependencies, releasing new package versions can
quickly become a nightmare. If the dependency specifications are too
tight, you are in danger of version lock - the inability to upgrade a
package without having to release a new version of every dependent
package. If dependencies are specified too loosely you will inevitably
be bitten by version promiscuity.</p>
<ul>
<li><p><code>Version lock</code> - when a dependency specification are
too strict - requires an exact version of a very narrow range, it
creates a situation where dependent packages cannot be upgraded without
releasing a new version of all packages that rely on them. Suppose the
package A requires version <code>1.2.3</code> of package B. If package B
updates to <code>1.3.0</code> you can not use the new version of package
B unless you also release a new version of package A that explicitly
allows <code>1.3.0</code> in its dependency specification, this cascades
across the dependency tree, making upgrades cumbersome and
error-prone</p></li>
<li><p><code>Version promiscuity</code> - when dependency specifications
are too loose allowing any version you risk unexpected breakage because
the software may end up using version of the dependencies that are
incompatible or introduce bugs. Suppose that package A specified it
works with <code>&gt;=1.0.0</code> of package B, and a breaking change
is introduced in <code>2.0.0</code> then package A might unexpectedly
break when package B updates to <code>2.0.0</code></p></li>
</ul>
<p>As a solution to this problem we propose a simple set of rules and
requirements that dictate how version numbers are assigned and
incremented. These rules are based on but not necessarily limited to
<code>pre-existing</code> widespread common practices in use in both
closed and open source software. For this system to work, you need to
declare a public API. This may consist of documentation or be enforced
by the code itself. Regardless, it is important that this API be clear
and precise. Once you identify your public API, you communicate changes
to it with specific increments to your version number. Consider a
version format of <code>x.y.z</code> Bug fixes not affecting the API
increment the patch version, backward compatible API additions/changes
increment the minor version, and backward incompatible API changes
increment the major version.</p>
<p><code>This system is called semantic versioning, under this scheme version numbers and the way they change, convey meaning about the underlying code and what had been modified from one version to the next.</code></p>
<h1 id="specification">Specification</h1>
<p>Software using semantic <code>versioning</code> must declare a public
api. This api could be declared in the code itself or exist strictly in
documentation. However it is done, it should be precise and
comprehensive.</p>
<ul>
<li><p>A normal version number must take the form of <code>x.y.z</code>
where x, y and z are non-negative integers, and must not contain leading
zeroes. X is the major version, Y is the minor version, and Z is the
patch version. Each element must increase numerically.</p></li>
<li><p>Once a versioned package has been released, the contents of that
version must not be modified any modifications must be released as a new
version.</p></li>
<li><p>Major version 0.y.z is for initial development. Anything may
change at any time. The public API should not be considered
stable.</p></li>
<li><p>Version 1.0.0 defines the public API. The way in which the
version number is incremented after this release is dependent on this
public api and how it changes.</p></li>
<li><p>Patch version Z must be incremented if only backward compatible
bug fixes are introduces. A bug fix is defined as an internal change
that fixes incorrect behavior. 1.1.5</p></li>
<li><p>Minor version Y must be incremented if new backward compatible
functionality is introduced to the PUBLIC API. It must be incremented if
any public API functionality is marked as deprecated. It maybe
incremented if substantial new functionality or improvements are
introduced within the private code. It may include patch level changes.
Path version must be reset to 0 when minor version is incremented.
1.1.0</p></li>
<li><p>Major version X must be incremented if any backward incompatible
changes are introduced to the public API. It may also include minor and
patch level changes. Patch and minor version must be reset to 0 when
major version is incremented. 1.0.0</p></li>
<li><p>A <code>pre-release</code> version may be denoted by appending a
hyphen and a series of dot separated identifiers immediately following
the patch version. Identifiers must comprise only ASCII alphanumeric and
hyphens. Identifiers must not be empty. Numeric identifiers must not
include leading zeroes. <code>Pre-release</code> versions have a lower
precedence than the associated normal version. A
<code>pre-release</code> version indicates that the version is unstable
and might not satisfy the intended compatibility requirements as denoted
by its associated normal version. 1.0.0-alpha, 1.0.0-alpha.1,
1.0.0-0.3.7 and so on.</p></li>
<li><p>Build <code>metadata</code> may be denoted by appending a plus
sign and a series of dot separated identifiers following the patch or
<code>pre-release</code> version, Identifiers must comprise only ASCII
alphanumeric and hyphens. Identifiers must not be empty build
<code>metadata</code> a must be ignored when determining version
precedence. Thus two versions that differ only in the build
<code>metadata</code> have the same precedence. 1.0.0-alpha+001,
1.0.0+201303313144700, and so on.</p></li>
<li><p>Precedence refers to how versions are compared to each other when
ordered. Precedence must be calculated by separating the version into
major minor patch and <code>pre-release</code> identifiers in that order
(build <code>metadata</code> does not figure into precedence)</p></li>
<li><p>Precedence is determined by the first difference when comparing
each of these identifiers from left to right as follows: major, minor
and patch version are always compared numerically. 1.0.0 &lt; 2.0.0 &lt;
2.1.0 &lt; 2.1.1</p></li>
<li><p>When all the major, minor and patch version are equal a
<code>pre-release</code> version has lower precedence than a normal
version 1.0.0-alpha &lt; 1.0.0</p></li>
<li><p>Precedence for two <code>pre-release</code> versions with the
same major, minor and patch version must be determined by comparing each
dot separated identifier from left to right until a difference is found
as follows:</p>
<ol type="1">
<li>Identifiers consisting of only digits are compared numerically.</li>
<li>Identifiers with letters or hyphens are compared lexically in ASCII
sort order.</li>
<li>Numeric identifiers always have lower precedence than non-numeric
identifiers</li>
<li>Precedence for two <code>pre-release</code> versions with the same
major, minor and patch versions must be determined by comparing each dot
separated identifier from left to right until a difference is found</li>
</ol></li>
</ul>
<h2 id="why-use-semantic-versioning">Why use semantic versioning</h2>
<p>This is not a new or revolutionary idea. In fact, you probably do
something close to this already. The problem is that close is not good
enough. Without compliance to some sort of formal specification version
numbers are essentially useless for dependency management. By giving a
name and clear definition to the ideas above, it becomes easy to
communicate your intentions to the users of your software. Once these
intentions are clear flexible but not too flexible dependency
specifications can finally be made.</p>
<h2 id="frequently-asked-questions">Frequently asked questions</h2>
<h3 id="how-to-deal-with-revision-0.y.z-of-initial-development">How to
deal with revision 0.y.z of initial development</h3>
<p>The simplest thing to do is start your initial development release at
0.1.0 and then increment the minor version for each subsequent
release.</p>
<h3 id="how-to-know-when-to-release-1.0.0">How to know when to release
1.0.0</h3>
<p>If your software is being used in production, it should probably
already be 1.0.0 if you have a stable API on which users have come to
depend you should be at 1.0.0. If you are worrying a lot about backward
compatibility you should already be at 1.0.0</p>
<h3
id="doesnt-this-discourage-rapid-development-and-fact-iteration">Doesn’t
this discourage rapid development and fact iteration ?</h3>
<p>Major version zero is all about rapid development. If you are
changing the API every day you should either still be in version 0.y.z
or on a separate development branch working on the next major
version.</p>
<h3
id="if-even-the-tiniest-backward-incompatible-change-to-the-public-api-require-a-major-version-wont-we-end-up-at-version-42.0.0-very-quickly">If
even the tiniest backward incompatible change to the public API require
a major version, won’t we end up at version 42.0.0 very quickly</h3>
<p>This is a question of responsible development and foresight.
Incompatible changes should not be introduced lightly to software that
has a lot of dependent code. The cost that must be incurred to upgrade
can be significant. Having to bump a major versions to release
incompatible changes means you will think through the impact of your
changes, and evaluate the cost/benefit ratio involved.</p>
<h3 id="documentation-is-too-much-work">Documentation is too much
work</h3>
<p>It is your responsibility as a professional developer to properly
document software that is intended for use by other people. Managing
software complexity is a hugely important part of keeping a project
efficient and that is hard to do if nobody knows how to use your
software or what methods are safe to call. In the long run, semantic
versioning and the insistence on a well defined public API can keep
everyone and everything running smoothly.</p>
<h3
id="what-to-do-if-accidentally-a-backward-incompatible-change-is-released-as-a-minor-version">What
to do if accidentally a backward incompatible change is released as a
minor version</h3>
<p>As soon as you realize that your have broken the contract and the
semantic versioning spec, fix the problem and release a new minor
version that corrects the problem and restores the backward
compatibility. Even under this circumstance, it is unacceptable to
modify versioned releases. If it is appropriate, document the offending
version and inform your users of the problem so that they are aware of
the offending version.</p>
<h3 id="how-to-handle-deprecated-functionality">How to handle deprecated
functionality</h3>
<p>Deprecating existing functionality is a normal part of software
development and is often required to make forward progress. When you
deprecate part of your public API, you should do two things - (1) update
your documentation to let users know about the change, (2) issue a new
minor release with the deprecation in place. Before you completely
remove the functionality in a new major release there should be at least
one minor release that contains the deprecation so that users can
smoothly transition to the new API.</p>
<h3 id="does-semver-have-a-size-limit-of-the-version-string">Does SemVer
have a size limit of the version string</h3>
<p>No, but use a good judgment, A 255 character version string is
probably overkill, for example. Also specific systems may impose their
own limits on the size of the string</p>
<h3 id="is-v1.2.3-a-valid-semantic-version">Is “v1.2.3” a valid semantic
version</h3>
<p>No, that is not a semantic version, however prefixing a semantic
version with a v is common way to indicate it is a version number.
Abbreviating “version” as “v” is often seen with version control.</p>
</body>
</html>
