Important topics

For each of the following topics, make sure you know how to use and implement them—first on paper, then on a computer.

Structures

You should be comfortable with linked lists, trees, tries, and graphs. Also, understand how to use stacks and queues, heaps, vectors or arrays, and hash tables.

Algorithms

Be able to implement and use breadth-first search and depth-first search. Know how to perform binary search, merge sort, and quick sort. You should also be familiar with other sorting algorithms.

Concepts

Understand bit manipulation and how memory works, including the stack and heap. Be able to use recursion and dynamic programming. Finally, know how to analyze time and space complexity using Big O notation.

Solving process

When approaching a problem, start by making sure you fully understand it. Ask for paper and pen, and write the problem down. Do not try to memorize it—writing helps you capture important details.

Ask for examples, and draw them out. Make your examples as specific to the problem as possible. Use the data you are given, or create your own, but make sure it relates directly to the problem. Draw large examples so you can spot patterns and edge cases.

Consider trading off space for time, or vice versa. For example, you might store data in a hash table, vector, list, stack, or tree, or you might sort data to make the solution easier.

Sometimes, it helps to write an implementation that is not fully correct or complete, just to get started.

Here is a step-by-step process:

First, listen carefully to the problem description. Pay close attention to every detail, and ask for more information to clarify anything that is unclear. Try not to make assumptions.

Second, ask for examples. Get more than one if you need to. Be persistent with your questions to avoid misunderstandings.

Third, try to solve the problem in the most straightforward, naive way you can think of. This is your brute force approach.

Fourth, look for ways to optimize your solution. Consider techniques like dynamic programming or memoization. Try to avoid bottlenecks and unnecessary or duplicated work.

Fifth, walk through your solution. Analyze the problem and describe your approach. If it does not make sense, go back to your example and start over from step two.

Sixth, implement your solution. Make sure your code is well structured.

Seventh, test your code. If you need to make changes to adjust the logic, go back to step three and repeat the process.

Compilation and Interpretation

Compiled Languages

In strictly compiled languages, such as C and C plus plus, the source code is translated directly into machine code by a compiler before execution. The resulting machine code is specific to the target hardware architecture.

The compilation process involves translating the entire source code into machine code in one pass. This generates an executable file containing native machine code that can be directly executed by the CPU.

Strictly compiled languages produce standalone executables that are independent of the original source code. The compiled code is executed directly by the CPU, without the need for an intermediate runtime environment.

Interpreted Languages

In interpreted languages, such as Python and JavaScript, the source code is executed line by line by an interpreter at runtime. The interpreter reads and executes each statement of the source code sequentially.

The interpretation process involves the interpreter reading the source code, parsing it into intermediate representations—such as bytecode or an abstract syntax tree—and executing it immediately. There is no separate compilation step to generate machine code.

Interpreted languages typically require an interpreter to be installed on the target system to execute the source code. The interpreter translates and executes the source code on the fly, without producing standalone executables.

Key and Core Differences

The main differences between compiled and interpreted languages are as follows.

First, compilation versus interpretation. A compiler translates the entire source code into machine code before execution. An interpreter executes the source code line by line at runtime, without prior translation.

Second, the output. A compiler produces standalone executable files containing native machine code. An interpreter executes the source code directly, without generating standalone executables.

Third, execution speed. Compilers generally produce faster-executing code, as it is optimized for the target hardware architecture. Interpreters may have slower execution speed compared to compiled languages, due to the overhead of interpretation at runtime.

Fourth, portability. Compilers generate machine code specific to the target hardware architecture, which can limit portability. Interpreters, on the other hand, allow for greater portability, since the source code is platform-independent and the interpreter translates and executes code on the fly.

In summary, strictly compiled languages translate source code into machine code before execution, resulting in standalone executables. Interpreted languages execute source code directly at runtime using an interpreter.

Compiled and Interpreted

Several interpreted languages use Just-In-Time, or JIT, compilation techniques to improve performance. Here are some examples.

JavaScript, with engines like V8, uses JIT compilation to dynamically compile frequently executed JavaScript code into native machine code for better performance.

Python, while traditionally interpreted, has projects like PyPy that implement a JIT compiler. PyPy’s JIT compiler dynamically compiles Python bytecode into native machine code at runtime, resulting in significant performance improvements over traditional interpreters.

Ruby, with the YARV interpreter, includes a JIT compiler called MJIT. MJIT dynamically compiles Ruby methods into native machine code, providing performance enhancements for Ruby applications.

PHP, with the HipHop Virtual Machine, or HHVM, includes a JIT compiler for PHP code. HHVM’s JIT compiler dynamically compiles PHP bytecode into native machine code, offering performance improvements over traditional PHP interpreters.

Lua has LuaJIT, a Just-In-Time compiler for the Lua programming language. LuaJIT dynamically compiles Lua bytecode into highly optimized native machine code at runtime, resulting in significant performance gains for Lua applications.

Java, with the Java Virtual Machine, or JVM, uses JIT compilation as well. The JVM dynamically compiles frequently executed bytecode sequences into optimized native machine code during runtime. This process aims to improve the performance of Java applications by translating bytecode into efficient machine code.

Java Virtual Machine

Introduction and Description

There are several implementations of the Java Virtual Machine, or JVM, developed by different organizations and communities. Here are some notable examples.

First, Oracle HotSpot VM. This is developed and maintained by Oracle Corporation. HotSpot is the default JVM implementation included in Oracle’s Java Development Kit distributions. It is known for high performance, advanced optimization techniques, and support for features like Just-In-Time compilation and multiple garbage collection algorithms.

Second, OpenJ9. This is developed and maintained by the Eclipse Foundation, formerly IBM. OpenJ9 is an open-source JVM implementation that focuses on high performance, low memory footprint, and fast startup times. It is included in Eclipse Adoptium distributions and is used in various cloud and enterprise Java environments.

Third, GraalVM. Developed and maintained by Oracle Labs, GraalVM is a high-performance polyglot virtual machine that supports multiple programming languages, including Java, JavaScript, Python, Ruby, and others. It includes the GraalVM Native Image technology, which enables ahead-of-time compilation of Java applications into native executables for improved startup time and reduced memory overhead.

Fourth, Azul Zulu JVM. This is developed and maintained by Azul Systems. Zulu is a certified, fully compatible, and open-source JVM implementation based on the OpenJDK project. It is available for various platforms, including Linux, Windows, macOS, and Docker, and is commonly used in enterprise environments.


Amazon Corretto JVM

Amazon Corretto is a Java Virtual Machine developed and maintained by Amazon Web Services. It is a free, multiplatform, production-ready distribution of OpenJDK. Corretto is designed to provide long-term support, regular security updates, and performance enhancements for Java applications. It is suitable for both AWS cloud services and on-premises environments.

SAP JVM

SAP JVM is a Java Virtual Machine developed and maintained by SAP. It is a high-performance, highly optimized implementation intended for enterprise-grade Java applications. SAP JVM includes advanced garbage collection algorithms, memory management optimizations, and is tailored to support SAP’s application platforms.

Key features and processes

The Java Virtual Machine, or JVM, is responsible for executing Java bytecode. This bytecode is an intermediate form of Java code, produced by compiling source files. Here’s an overview of the main steps involved in running Java code on the JVM.

First, Java source code files, which have the extension dot java, are compiled into Java bytecode files, which have the extension dot class. This is done using the Java compiler, known as javac. The compiler translates the human-readable Java source code into platform-independent bytecode instructions, which are then stored in class files.

Next, the JVM loads these class files into memory as needed during program execution. The class loading process has three main steps: loading, linking, and initialization. During loading, the class loader reads the bytecode from the class file and creates an in-memory representation of the class. Linking involves verification, preparation, and resolution. Verification checks the correctness of the bytecode, preparation allocates memory for static fields, and resolution resolves references to other classes. Finally, during initialization, the JVM executes static initializers and initializes static fields.

Before any bytecode is executed, the JVM performs bytecode verification. This step ensures that the bytecode follows certain safety constraints and does not violate Java language rules. The verification process checks for type safety, stack integrity, and proper control flow.

The JVM uses a Just-In-Time, or JIT, compiler to improve performance. When a method is called frequently or identified as a hot spot, the JIT compiler translates its bytecode into optimized native machine code at runtime. This native code is then cached and executed directly by the CPU, bypassing the need to interpret the bytecode. The goal of JIT compilation is to dynamically optimize code paths that are executed often.

During execution, the JVM either interprets bytecode or runs the compiled native machine code, depending on whether JIT compilation has occurred for a particular method.

Memory management is handled automatically by the JVM using garbage collection. The garbage collector identifies and reclaims memory that is no longer in use, preventing memory leaks and ensuring efficient memory usage.

Let’s walk through a simple example of how the Java Virtual Machine processes code, from source to machine code.

First, consider a Java source file that defines a class called Calculator. This class has a static method named sum, which takes two integers and returns their sum.

Next, the source file is compiled using the Java compiler. The resulting class file contains the bytecode for the Calculator class. Tools like javap can be used to inspect the bytecode instructions.

The bytecode for the sum method consists of instructions to load the two integer arguments, add them, and return the result.

After JIT compilation, the bytecode instructions for the sum method are translated into native machine code. In this example, the native code is represented using x86 assembly language. The instructions load the values of the arguments, add them, and return the result. These operations correspond closely to the original bytecode, but are specific to the underlying hardware architecture.

Memory management and control

Now, let’s discuss some common concepts about memory management in Java and other garbage-collected languages.

What is Garbage Collection in Java?

Garbage collection in Java is an automatic memory management process. The JVM automatically reclaims memory occupied by objects that are no longer in use or reachable by the program. This helps developers by eliminating the need to manually free memory and reduces the risk of memory leaks.

How does Java’s Garbage Collector work?

Java’s garbage collector periodically identifies and reclaims memory used by objects that are no longer reachable. It uses algorithms such as Mark-Sweep, Copying, and Generational collection to manage memory efficiently. The process involves marking objects that are still in use, reclaiming memory from unreachable objects, and compacting memory to reduce fragmentation.

What are the different types of garbage collectors in Java?

Java provides several garbage collection algorithms to suit different application needs. These include the Serial collector, the Parallel collector, the Concurrent Mark-Sweep, or CMS, collector, the Garbage-First, or G1, collector, and the Z Garbage Collector, or ZGC. Each algorithm has its own characteristics, such as throughput, latency, and suitability for different scenarios.

What is the difference between System dot gc and Runtime dot getRuntime dot gc?

Both System dot gc and Runtime dot getRuntime dot gc are used to suggest garbage collection to the JVM. System dot gc is a static method, while Runtime dot getRuntime dot gc is an instance method that first provides a reference to the runtime object before suggesting garbage collection.

How do you prevent memory leaks in Java?

To prevent memory leaks in Java, follow best practices such as releasing resources promptly, closing streams properly using try-with-resources, being cautious with static variables, avoiding excessive object creation, and using memory profiling tools to identify potential leaks.

Explain the concept of memory leak in Java.

A memory leak occurs when objects are no longer needed by the application but are still referenced, preventing them from being garbage collected. This leads to a gradual increase in memory usage over time, which can cause out-of-memory errors and degrade performance.

What is the purpose of the finalize method in Java?

The finalize method is called by the garbage collector before reclaiming an object’s memory. Its purpose is to perform any necessary cleanup or resource release operations. However, relying on finalize for resource cleanup is generally discouraged due to its unpredictable nature and potential performance issues.

How can you monitor and tune garbage collection in Java applications?

Garbage collection can be monitored and tuned using tools such as VisualVM, JConsole, and Mission Control. These tools provide insights into garbage collection activity, heap usage, and performance metrics. Tuning may involve adjusting JVM parameters like heap size, garbage collector type, and specific tuning flags based on application requirements and performance goals.

What is the impact of garbage collection on application performance?

Garbage collection can significantly affect application performance, influencing CPU overhead, pause times, and throughput. Proper tuning of garbage collection is essential to balance these factors and optimize application responsiveness and scalability.


Let’s begin by discussing the different types of reference objects in Java and their purposes.

WeakReference, SoftReference, and PhantomReference are specialized reference types that allow developers to manage object lifecycles and memory usage more precisely.

A WeakReference allows an object to be garbage collected when it is no longer referenced by any strong references. This is useful for situations like caches, where you want to allow the garbage collector to reclaim memory if needed.

A SoftReference is similar, but the object it refers to will only be collected when the system is running low on memory. This makes SoftReferences ideal for implementing memory-sensitive caches, where you want to keep objects around as long as possible, but still allow them to be collected if memory becomes scarce.

A PhantomReference provides even more control. It does not prevent its referent from being collected, and it is used to schedule post-mortem cleanup actions after the object has been finalized but before its memory is reclaimed. PhantomReferences are particularly useful for managing native resources or performing cleanup that must occur after an object is no longer accessible.

Now, let’s move on to garbage collection algorithms, starting with Mark and Sweep.

The Mark and Sweep algorithm works in two main phases. In the mark phase, the garbage collector traverses all reachable objects starting from the roots, such as global variables, local variables, and active threads. Each reachable object is marked as in use or reachable. This phase identifies all objects that are still actively being used by the program.

In the sweep phase, the garbage collector scans the entire heap memory. Any memory regions not marked as in use are considered garbage and are eligible for reclamation. The garbage collector then reclaims the memory occupied by these unreachable objects, freeing it up for future allocations.

The advantages of Mark and Sweep are its straightforward implementation and the fact that it does not require moving objects around in memory. This can simplify memory management in certain scenarios. Additionally, it can handle cycles in object references without extra complexity.

However, Mark and Sweep has some disadvantages. It can cause fragmentation in memory, since reclaimed memory may not be contiguous. It also typically involves stop-the-world pauses during the mark and sweep phases, which can lead to application pauses and reduced responsiveness, especially in interactive applications. Furthermore, it does not perform memory compaction, so it may not efficiently utilize available memory space, particularly in long-running applications.

Next, let’s discuss some common garbage collection strategies in Java.

The Serial Garbage Collector, also known as the Serial Collector, is the simplest garbage collector. It is best suited for single-threaded or small-scale applications with small heaps. The Serial Collector is known for its simplicity and low overhead, but it can cause noticeable pauses during garbage collection, as it stops all application threads during the collection process. It uses a mark-and-sweep algorithm.

The Parallel Garbage Collector, also called the Throughput Collector, is designed for multi-threaded applications and is the default garbage collector for the Java HotSpot virtual machine. It uses multiple threads to perform garbage collection, which helps reduce pause times experienced by applications. This collector is suitable for applications where maximizing throughput and performance is more important than minimizing pause times. It also uses a mark-and-sweep algorithm.

The Garbage-First, or G1, Garbage Collector is designed to provide both low-latency pauses and high throughput. It divides the heap into regions and performs garbage collection on these regions independently. This allows it to collect only the regions with the most garbage first. G1 aims to meet garbage collection pause time goals with predictable and consistent pause times. It is suitable for large heap applications and applications that require low-latency garbage collection.

The Z Garbage Collector, or ZGC, is a scalable garbage collector designed to provide low-latency performance for large heaps, including multi-terabyte heaps. It is intended for applications requiring very low pause times, typically less than ten milliseconds, even on very large heaps. ZGC uses concurrent algorithms for all major phases of garbage collection, including marking, reference processing, relocation, and evacuation. It is suitable for applications with stringent latency requirements, such as financial trading systems, gaming platforms, and real-time analytics.

Now, let’s move on to some trick questions that often come up in Java interviews or assessments.

First, consider a scenario involving autoboxing and null values. If you assign null to an Integer object and then try to unbox it to an int, Java will throw a NullPointerException. This happens because autoboxing attempts to convert a null reference to a primitive type, which is not allowed.

Next, let’s look at modifying a list while iterating over it. If you create a list, add some elements, and then try to remove elements from the list inside a for-each loop, Java will throw a ConcurrentModificationException. This is because you are modifying the list structure while iterating over it, without using the iterator’s remove method.

For arithmetic operations, dividing an integer by zero will throw an ArithmeticException. Division by zero is undefined in Java, and the runtime will signal this error.

Accessing an array with an invalid index, such as trying to access the sixth element in an array of length five, will throw an IndexOutOfBoundsException. Java arrays are zero-based, so valid indices range from zero to one less than the array’s length.

Casting between generic types can also cause issues. If you have a list of strings and try to cast it to a list of objects, the code will compile, but at runtime, it will throw a ClassCastException. This is due to type erasure, which removes generic type information at runtime.

Comparing a null string using the equals method will throw a NullPointerException. If you try to call equals on a null reference, Java will signal this error.

Parsing a non-numeric string as an integer will throw a NumberFormatException. For example, trying to parse the string “abc” as an integer will result in this exception.

Attempting to add an element to an unmodifiable collection, such as the list returned by Collections.emptyList, will throw an UnsupportedOperationException. This is because the list is immutable.

Infinite recursion without an exit condition will cause a StackOverflowError. If a method calls itself repeatedly without a base case, the call stack will eventually overflow.

Using Enum.valueOf with a string that does not match any of the enum constants will throw an IllegalArgumentException. For example, trying to get a color named “YELLOW” from an enum that only defines red, green, and blue will result in this exception.

Popping an element from an empty stack will throw an EmptyStackException. If you call pop on a stack with no elements, Java will signal this error.

Incrementing the maximum integer value in Java will cause integer overflow. The value will wrap around from Integer.MAX_VALUE to Integer.MIN_VALUE.

When comparing string literals using the double equals operator, Java will return true if both references point to the same object in the string pool. For example, two string literals with the same value will refer to the same object, so the comparison will return true.

Adding floating-point numbers can result in precision errors. For example, adding zero point one and zero point two as doubles will not yield exactly zero point three, but a close approximation, due to limitations in binary floating-point representation.

Finally, comparing a string to a StringBuilder using the equals method will return false. The equals method in the String class checks for both value and type, so a String and a StringBuilder with the same content are not considered equal.

This concludes the overview of Java reference types, garbage collection algorithms and strategies, and a series of common trick questions and pitfalls in Java programming.


The equals method in Java

The equals method in Java is used to compare the content of objects. For example, if you have one variable as a String and another as a StringBuilder, even if both contain the same characters, the equals method will return false. This is because they are different types of objects.

Casting and Arithmetic Operations

Consider a scenario where you have two byte variables, both set to one hundred twenty-seven. If you try to add them together and assign the result to another byte variable, you will encounter a problem. In Java, when you add two bytes, the result is automatically promoted to an integer. Assigning this integer result back to a byte without explicit casting will cause a compilation error.

Object Comparison

Now, let's look at object comparison. Suppose you create two Integer objects, both initialized with the value one hundred. If you compare these two objects using the double equals operator, you are checking for reference equality, not value equality. Since these are two separate objects in memory, the comparison will return false, even though their values are the same.


