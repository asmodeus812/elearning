<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>7-trees-and-graphs</title>
  <style>
    html {
      font-size: 12pt;
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      overflow-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 12px;
      }
      h1 {
        font-size: 1.8em;
      }
    }
    @media print {
      html {
        background-color: white;
      }
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, Consolas, 'Lucida Console', monospace;
      font-size: 85%;
      margin: 0;
      hyphens: manual;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
      overflow-wrap: normal;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      background-color: #1a1a1a;
      border: none;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC ul {
      padding-left: 1.3em;
    }
    #TOC > ul {
      padding-left: 0;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
    /* CSS for syntax highlighting */
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    .sourceCode { overflow: visible; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {   }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ff0000; font-weight: bold; } /* Alert */
    code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #7d9029; } /* Attribute */
    code span.bn { color: #40a070; } /* BaseN */
    code span.bu { color: #008000; } /* BuiltIn */
    code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4070a0; } /* Char */
    code span.cn { color: #880000; } /* Constant */
    code span.co { color: #60a0b0; font-style: italic; } /* Comment */
    code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #ba2121; font-style: italic; } /* Documentation */
    code span.dt { color: #902000; } /* DataType */
    code span.dv { color: #40a070; } /* DecVal */
    code span.er { color: #ff0000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #40a070; } /* Float */
    code span.fu { color: #06287e; } /* Function */
    code span.im { color: #008000; font-weight: bold; } /* Import */
    code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #007020; font-weight: bold; } /* Keyword */
    code span.op { color: #666666; } /* Operator */
    code span.ot { color: #007020; } /* Other */
    code span.pp { color: #bc7a00; } /* Preprocessor */
    code span.sc { color: #4070a0; } /* SpecialChar */
    code span.ss { color: #bb6688; } /* SpecialString */
    code span.st { color: #4070a0; } /* String */
    code span.va { color: #19177c; } /* Variable */
    code span.vs { color: #4070a0; } /* VerbatimString */
    code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  \usepackage{listings}
  \usepackage{xcolor}

  \lstset{
      basicstyle=\ttfamily,
      backgroundcolor=\color{black!10},
      showspaces=false,
      showstringspaces=false,
      showtabs=false,
      tabsize=2,
      captionpos=b,
      breaklines=true,
      breakautoindent=true,
      linewidth=\textwidth
  }
</head>
<body>
<nav id="TOC" role="doc-toc">
<ul>
<li><a href="#introduction" id="toc-introduction">Introduction</a></li>
<li><a href="#trees" id="toc-trees">Trees</a>
<ul>
<li><a href="#types" id="toc-types">Types</a></li>
<li><a href="#creating" id="toc-creating">Creating</a></li>
<li><a href="#traversal" id="toc-traversal">Traversal</a>
<ul>
<li><a href="#height" id="toc-height">Height</a></li>
<li><a href="#containment" id="toc-containment">Containment</a></li>
<li><a href="#ancestor" id="toc-ancestor">Ancestor</a></li>
<li><a href="#comparison" id="toc-comparison">Comparison</a></li>
<li><a href="#subtrees" id="toc-subtrees">Subtrees</a></li>
<li><a href="#size" id="toc-size">Size</a></li>
<li><a href="#random" id="toc-random">Random</a></li>
<li><a href="#binary-search-trees" id="toc-binary-search-trees">Binary
search trees</a></li>
<li><a href="#binary-heaps" id="toc-binary-heaps">Binary heaps</a></li>
<li><a href="#tries" id="toc-tries">Tries</a></li>
<li><a href="#b-trees" id="toc-b-trees">B-Trees</a></li>
</ul></li>
<li><a href="#workeriterator-approach"
id="toc-workeriterator-approach">Worker&amp;Iterator approach</a></li>
</ul></li>
<li><a href="#graphs" id="toc-graphs">Graphs</a>
<ul>
<li><a href="#representations"
id="toc-representations">Representations</a>
<ul>
<li><a href="#class-nodes" id="toc-class-nodes">Class &amp;
Nodes</a></li>
<li><a href="#adjacency-matrices" id="toc-adjacency-matrices">Adjacency
Matrices</a></li>
<li><a href="#d-flags-array" id="toc-d-flags-array">2D Flags
Array</a></li>
</ul></li>
<li><a href="#creation" id="toc-creation">Creation</a></li>
<li><a href="#traversing" id="toc-traversing">Traversing</a>
<ul>
<li><a href="#bfs" id="toc-bfs">BFS</a></li>
<li><a href="#dfs" id="toc-dfs">DFS</a></li>
<li><a href="#dijkstra" id="toc-dijkstra">Dijkstra</a></li>
<li><a href="#a-star" id="toc-a-star">A-star</a></li>
</ul></li>
</ul></li>
<li><a href="#sorting" id="toc-sorting">Sorting</a>
<ul>
<li><a href="#topological-sort" id="toc-topological-sort">Topological
sort</a></li>
</ul></li>
</ul>
</nav>
<h1 id="introduction">Introduction</h1>
<h1 id="trees">Trees</h1>
<p>They are a recursive structure, which can be defined by having a node
with n-children. Each of those children can also have n-children and so
on. Nodes might have a link to their parent but that is strictly
implementation dependent and is not required. Important to note:</p>
<ul>
<li>trees have no loops within them, otherwise they would be graphs</li>
<li>each tree has a root node, which has no ancestors</li>
<li>each node in the tree including the root might have 0 or more
children</li>
<li>a tree with a max of n-number of children is called n-ary tree, a
node with 2 children, for example would be 2-ary tree, or binary tree,
with 10, 10-ary tree</li>
<li>a node without children is called a leaf node, the root can be both
a leaf node, and a root in a tree</li>
<li>referencing the node’s parent while iterating through the tree is
usually implemented using recursion</li>
</ul>
<p>A sample representation of a tree node might look like this, note
that a tree class is rarely needed, it does not really add any
significant value, since passing the root Node around, to represent the
tree is simply enough, a Tree class might be useful to attach an
interface to the tree, actions, which might be done on a tree, but that
is usually just it.</p>
<p>An N-ary tree node could look like this</p>
<div class="sourceCode" id="cb1"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>    <span class="kw">class</span> <span class="bu">Node</span> <span class="op">{</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>        <span class="bu">Integer</span> value<span class="op">;</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>        <span class="bu">Node</span><span class="op">[]</span> children<span class="op">;</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<p>A binary tree node could look like this</p>
<div class="sourceCode" id="cb2"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>    <span class="kw">class</span> <span class="bu">Node</span> <span class="op">{</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>        <span class="bu">Integer</span> value<span class="op">;</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>        <span class="bu">Node</span> left<span class="op">;</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>        <span class="bu">Node</span> right<span class="op">;</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<h2 id="types">Types</h2>
<p>Several common types of trees exist, and it is important to be able
to distinguish them, since each have different properties and
assumptions that can be made.</p>
<p>Before solving a problem be sure to understand what type of tree is
the problem or solution requiring so it can be solved, each tree type
has different properties</p>
<ul>
<li><p>tries - those are type of n-ary trees, which come up very often,
and are usually used to find word prefixes, tries are sometimes used to
store the entire English language, each node in the tree has at most 26
children, 1 for each letter of the alphabet. Each path of nodes which
forms a valid word, is terminated with special terminating node which
denotes that.</p>
<div class="sourceCode" id="cb3"><pre
class="sourceCode txt"><code class="sourceCode default"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>          root</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>        /      \</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>       M        L</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>    /     \    /  \</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>   A       Y  I    O</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a> /           /      \</span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>N           E        W</span></code></pre></div></li>
<li><p>binary trees - these are just trees where each node has at most
two children, meaning it can have 0, 1 or 2. Nodes are not arranged or
ordered in any meaningful or special way</p></li>
<li><p>binary search trees - these are binary trees which are
constructed in a very special way, where the tree nodes are ordered,
each node on the left is usually less than or equal to it’s parent, each
node to the right is strictly bigger than its parent. This condition
must be met for all sub-children of a given node, recursively, not just
the immediate children of a given node. See in the example below how 10
is not just bigger than 5, but also than 5’s children too, 3 and 6</p>
<div class="sourceCode" id="cb4"><pre
class="sourceCode txt"><code class="sourceCode default"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>           10</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>        /      \</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>       5       20</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>    /     \   /  \</span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>   3      6  15  25</span></code></pre></div></li>
<li><p>balanced binary search trees - these are trees where the height
of the left and right sub tree do not differ with more than 1 level.
Balanced trees might be binary, but any n-ary tree could be really.
Example of balanced trees are red black trees, or AVL trees, these are
examples of balanced binary search trees. See below, how the height of
the left sub tree of the root is 3 and the right is 2, the difference is
no more than 1</p>
<div class="sourceCode" id="cb5"><pre
class="sourceCode txt"><code class="sourceCode default"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>           10</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>        /      \</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>       5       20</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>     /   \</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>    3     6</span></code></pre></div></li>
<li><p>binary heaps - these are special type of binary trees, similarly
to the search trees, but the order of elements is such that either the
min element or the max, depending on the type of the tree, is at the top
of the tree, in the root node, elements below each node are all bigger
(min) or smaller (max) than the root, this is true for each node
recursively. See how no matter which child you take below the root, they
are all bigger (in this example, for min heap).</p>
<div class="sourceCode" id="cb6"><pre
class="sourceCode txt"><code class="sourceCode default"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>            1</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>        /      \</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>       5       20</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>    /     \   /  \</span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>   8      9  25  35</span></code></pre></div></li>
<li><p>complete binary trees - are these trees which where each level of
the tree is completely filled, except maybe the last level.</p>
<div class="sourceCode" id="cb7"><pre
class="sourceCode txt"><code class="sourceCode default"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>           10</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>        /      \</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>       5       20</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>    /     \  /</span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>   3      7 15</span></code></pre></div></li>
<li><p>full binary trees - are these trees which where each node has
either 0 or 2 children, and nothing in between</p>
<div class="sourceCode" id="cb8"><pre
class="sourceCode txt"><code class="sourceCode default"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>           10</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>        /      \</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>       5       20</span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>    /     \</span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>   3      7</span></code></pre></div></li>
<li><p>perfect binary trees - are these where all interior nodes, have
children, the only nodes that have no children are the leaf nodes</p>
<div class="sourceCode" id="cb9"><pre
class="sourceCode txt"><code class="sourceCode default"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>           10</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>        /      \</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>       5       20</span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>    /     \  /    \</span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>   3      7 15    23</span></code></pre></div></li>
</ul>
<h2 id="creating">Creating</h2>
<p>A fast way to create a binary tree from a list of items, is to just
use the heap approach. What we do is simply start off from the first
index, and calculate which elements are children of that index, get that
from the array and create a node child subtree, and keep recursing. Keep
a base case check for the index, must not exceed the list size.</p>
<ul>
<li>left child is (index * 2) + 1</li>
<li>right child is (index * 2) + 2</li>
</ul>
<div class="sourceCode" id="cb10"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>    <span class="bu">Node</span> <span class="fu">create</span><span class="op">(</span><span class="bu">Node</span> root<span class="op">,</span> <span class="dt">int</span> index<span class="op">,</span> <span class="bu">List</span> elements<span class="op">)</span> <span class="op">{</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>index <span class="op">&gt;=</span> elements<span class="op">.</span><span class="fu">size</span><span class="op">())</span> <span class="op">{</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="kw">null</span><span class="op">;</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a>        root<span class="op">.</span><span class="fu">value</span> <span class="op">=</span> elements<span class="op">.</span><span class="fu">get</span><span class="op">(</span>index<span class="op">);</span></span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>root<span class="op">.</span><span class="fu">value</span> <span class="op">==</span> <span class="kw">null</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="kw">null</span><span class="op">;</span></span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a>        root<span class="op">.</span><span class="fu">left</span> <span class="op">=</span> <span class="fu">create</span><span class="op">(</span><span class="kw">new</span> <span class="bu">Node</span><span class="op">(),</span> <span class="op">(</span>index <span class="op">*</span> <span class="dv">2</span><span class="op">)</span> <span class="op">+</span> <span class="dv">1</span><span class="op">,</span> elements<span class="op">);</span></span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a>        root<span class="op">.</span><span class="fu">right</span> <span class="op">=</span> <span class="fu">create</span><span class="op">(</span><span class="kw">new</span> <span class="bu">Node</span><span class="op">(),</span> <span class="op">(</span>index <span class="op">*</span> <span class="dv">2</span><span class="op">)</span> <span class="op">+</span> <span class="dv">2</span><span class="op">,</span> elements<span class="op">);</span></span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> root<span class="op">;</span></span>
<span id="cb10-13"><a href="#cb10-13" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb10-14"><a href="#cb10-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-15"><a href="#cb10-15" aria-hidden="true" tabindex="-1"></a>    <span class="bu">Node</span> <span class="fu">create</span><span class="op">(</span><span class="bu">List</span> elements<span class="op">)</span> <span class="op">{</span></span>
<span id="cb10-16"><a href="#cb10-16" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="fu">create</span><span class="op">(</span><span class="kw">new</span> <span class="bu">Node</span><span class="op">(),</span> <span class="dv">0</span><span class="op">,</span> elements<span class="op">);</span></span>
<span id="cb10-17"><a href="#cb10-17" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<h2 id="traversal">Traversal</h2>
<p>There are a few ways to traverse a binary tree, or n-ary tree,
usually that involves different visiting permutations of the nodes. For
example for a binary tree we can visit the 3 nodes, in 6 different ways,
in total</p>
<ul>
<li>root, left, right</li>
<li>root, right, left</li>
<li>left, root, right</li>
<li>left, right, root</li>
<li>right, left, root</li>
<li>right, root, left</li>
</ul>
<p>Some of the above have names, since they come in very often, for a
binary search tree, we have post, pre and in order traversal</p>
<ul>
<li><p>left, root, right - in order traversal, because the tree nodes
would be visited in ascending order.</p>
<div class="sourceCode" id="cb11"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> <span class="fu">order</span><span class="op">(</span><span class="bu">Node</span> node<span class="op">)</span> <span class="op">{</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>node <span class="op">==</span> <span class="kw">null</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span><span class="op">;</span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>        <span class="fu">order</span><span class="op">(</span>node<span class="op">.</span><span class="fu">left</span><span class="op">);</span></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a>        <span class="fu">visit</span><span class="op">(</span>node<span class="op">.</span><span class="fu">root</span><span class="op">);</span></span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a>        <span class="fu">order</span><span class="op">(</span>node<span class="op">.</span><span class="fu">right</span><span class="op">);</span></span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div></li>
<li><p>root, left, right - pre order traversal, where root is first
then, ordered are visited only the children</p>
<div class="sourceCode" id="cb12"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> <span class="fu">order</span><span class="op">(</span><span class="bu">Node</span> node<span class="op">)</span> <span class="op">{</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>node <span class="op">==</span> <span class="kw">null</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span><span class="op">;</span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>        <span class="fu">visit</span><span class="op">(</span>node<span class="op">.</span><span class="fu">root</span><span class="op">);</span></span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a>        <span class="fu">order</span><span class="op">(</span>node<span class="op">.</span><span class="fu">left</span><span class="op">);</span></span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a>        <span class="fu">order</span><span class="op">(</span>node<span class="op">.</span><span class="fu">right</span><span class="op">);</span></span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div></li>
<li><p>left, right, root - post order traversal, where children are
ordered, then lastly the root is visited</p>
<div class="sourceCode" id="cb13"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> <span class="fu">order</span><span class="op">(</span><span class="bu">Node</span> node<span class="op">)</span> <span class="op">{</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>node <span class="op">==</span> <span class="kw">null</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span><span class="op">;</span></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a>        <span class="fu">order</span><span class="op">(</span>node<span class="op">.</span><span class="fu">left</span><span class="op">);</span></span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a>        <span class="fu">order</span><span class="op">(</span>node<span class="op">.</span><span class="fu">right</span><span class="op">);</span></span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a>        <span class="fu">visit</span><span class="op">(</span>node<span class="op">.</span><span class="fu">root</span><span class="op">);</span></span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div></li>
</ul>
<h3 id="height">Height</h3>
<div class="sourceCode" id="cb14"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> <span class="fu">height</span><span class="op">(</span><span class="bu">Node</span> root<span class="op">)</span> <span class="op">{</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>root <span class="op">==</span> <span class="kw">null</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>            <span class="co">// when the node is invalid there is no meaningful height value to return for it, but zero</span></span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>root<span class="op">.</span><span class="fu">left</span> <span class="op">==</span> <span class="kw">null</span> <span class="op">&amp;&amp;</span> root<span class="op">.</span><span class="fu">right</span> <span class="op">==</span> <span class="kw">null</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a>            <span class="co">// when the node is a leaf, the height could be only one, the height is the node node itself</span></span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb14-9"><a href="#cb14-9" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb14-10"><a href="#cb14-10" aria-hidden="true" tabindex="-1"></a>        <span class="co">// when the node has children, the height is the current height, one, plus the max height between the left or right subtrees of</span></span>
<span id="cb14-11"><a href="#cb14-11" aria-hidden="true" tabindex="-1"></a>        <span class="co">// the current node</span></span>
<span id="cb14-12"><a href="#cb14-12" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="dv">1</span> <span class="op">+</span> <span class="bu">Math</span><span class="op">.</span><span class="fu">max</span><span class="op">(</span><span class="fu">height</span><span class="op">(</span>root<span class="op">.</span><span class="fu">left</span><span class="op">),</span> <span class="fu">height</span><span class="op">(</span>root<span class="op">.</span><span class="fu">right</span><span class="op">));</span></span>
<span id="cb14-13"><a href="#cb14-13" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<h3 id="containment">Containment</h3>
<p>To check if a given node reference, not by value, is contained in a
tree, we have to go through all nodes and compare each to the target
reference we have. The premise is simple compare by reference, either
the left or the right subtrees could contain that node. If we reach a
nil node, we can return false, if both paths
<code>check(left) and check(right)</code> return false, therefore we
have not found the node, at least one should return true.</p>
<div class="sourceCode" id="cb15"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a>    <span class="dt">boolean</span> <span class="fu">contains</span><span class="op">(</span><span class="bu">Node</span> root<span class="op">,</span> <span class="bu">Node</span> node<span class="op">)</span> <span class="op">{</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>root <span class="op">==</span> <span class="kw">null</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>            <span class="co">// the root does not contain the given node</span></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="kw">false</span><span class="op">;</span></span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a>        <span class="co">// the root and the node are the same, yes the initial root contained the node</span></span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>root <span class="op">==</span> node<span class="op">)</span> <span class="op">{</span></span>
<span id="cb15-9"><a href="#cb15-9" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="kw">true</span><span class="op">;</span></span>
<span id="cb15-10"><a href="#cb15-10" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb15-11"><a href="#cb15-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-12"><a href="#cb15-12" aria-hidden="true" tabindex="-1"></a>        <span class="co">// try go to the left and right of the current root looking for the target node</span></span>
<span id="cb15-13"><a href="#cb15-13" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="fu">contains</span><span class="op">(</span>root<span class="op">.</span><span class="fu">left</span><span class="op">,</span> node<span class="op">)</span> <span class="op">||</span> <span class="fu">contains</span><span class="op">(</span>root<span class="op">.</span><span class="fu">right</span><span class="op">,</span> node<span class="op">);</span></span>
<span id="cb15-14"><a href="#cb15-14" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<h3 id="ancestor">Ancestor</h3>
<p>This is a tricky, but very useful problem to solve, find the first
common ancestor of two nodes. Given two nodes at any depth in a tree. To
do this we have to realize we have two conditions / states only. The
nodes could be in</p>
<ul>
<li>both nodes are on the left or right subtree of a given node</li>
<li>one node is on the right the other on the left or vice versa</li>
</ul>
<p>We know that if one node is on the right the other on the left, of a
given parent node, or vice versa, that this parent node is the common
ancestor, otherwise if they are on the same side, we have to go down
that side, until they split, and are no longer on the same side</p>
<div class="sourceCode" id="cb16"><pre
class="sourceCode txt"><code class="sourceCode default"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a>       10</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>      /  \</span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>     3   15</span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a>   /  \</span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a>  1    4</span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a> /</span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true" tabindex="-1"></a>0</span></code></pre></div>
<p>If we take a look at the example above, the nodes 0 and 4 have an
immediate common ancestor, the node 3. We can see how this is the first
node where both 0 and 4 are on both sides of 3, while if we take a look
at node 10, 0 an 4 are on the same side of 10 (the left subtree)</p>
<p>What we need to do is simply verify that the given nodes do not lie
in the same subtree at the same time of a given node, then we know that
node is the common ancestor, note that this works for example if we had
the nodes 3 and 0, where the common ancestor would be 10, (not 3)</p>
<div class="sourceCode" id="cb17"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a>    <span class="bu">Node</span> <span class="fu">ancestor</span><span class="op">(</span><span class="bu">Node</span> root<span class="op">,</span> <span class="bu">Node</span> first<span class="op">,</span> <span class="bu">Node</span> second<span class="op">)</span> <span class="op">{</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>root <span class="op">==</span> <span class="kw">null</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>            <span class="co">// invalid root no common ancestors</span></span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="kw">null</span><span class="op">;</span></span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true" tabindex="-1"></a>        <span class="co">// check if the first node is on the left of the root</span></span>
<span id="cb17-8"><a href="#cb17-8" aria-hidden="true" tabindex="-1"></a>        <span class="dt">boolean</span> firstOnLeft <span class="op">=</span> <span class="fu">contains</span><span class="op">(</span>root<span class="op">.</span><span class="fu">left</span><span class="op">,</span> first<span class="op">);</span></span>
<span id="cb17-9"><a href="#cb17-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-10"><a href="#cb17-10" aria-hidden="true" tabindex="-1"></a>        <span class="co">// check if the second node is on the right of the root</span></span>
<span id="cb17-11"><a href="#cb17-11" aria-hidden="true" tabindex="-1"></a>        <span class="dt">boolean</span> secondOnRight <span class="op">=</span> <span class="fu">contains</span><span class="op">(</span>root<span class="op">.</span><span class="fu">right</span><span class="op">,</span> second<span class="op">);</span></span>
<span id="cb17-12"><a href="#cb17-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-13"><a href="#cb17-13" aria-hidden="true" tabindex="-1"></a>        <span class="co">// we know that if both of those variables are equal, then the current root is the common ancestor, why ? if we take any two</span></span>
<span id="cb17-14"><a href="#cb17-14" aria-hidden="true" tabindex="-1"></a>        <span class="co">// nodes in a binary tree, there exists only one single node, for which the two nodes are located on the left and the right,</span></span>
<span id="cb17-15"><a href="#cb17-15" aria-hidden="true" tabindex="-1"></a>        <span class="co">// at the same time, and that node is the common ancestor. Note that it does not matter if we flip the first and second, so the</span></span>
<span id="cb17-16"><a href="#cb17-16" aria-hidden="true" tabindex="-1"></a>        <span class="co">// checks above would return false for both instead, if the check above both return false, that simply means the nodes are on</span></span>
<span id="cb17-17"><a href="#cb17-17" aria-hidden="true" tabindex="-1"></a>        <span class="co">// the opposite site of what we were checking, but they are on the left and right of root still, as long as firstOnLeft ==</span></span>
<span id="cb17-18"><a href="#cb17-18" aria-hidden="true" tabindex="-1"></a>        <span class="co">// secondOnRight, the nodes are on the left and right of current root, which (of the nodes first/second) is on which does not</span></span>
<span id="cb17-19"><a href="#cb17-19" aria-hidden="true" tabindex="-1"></a>        <span class="co">// matter</span></span>
<span id="cb17-20"><a href="#cb17-20" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>firstOnLeft <span class="op">==</span> secondOnRight<span class="op">)</span> <span class="op">{</span></span>
<span id="cb17-21"><a href="#cb17-21" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> root<span class="op">;</span></span>
<span id="cb17-22"><a href="#cb17-22" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb17-23"><a href="#cb17-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-24"><a href="#cb17-24" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>firstOnLeft<span class="op">)</span> <span class="op">{</span></span>
<span id="cb17-25"><a href="#cb17-25" aria-hidden="true" tabindex="-1"></a>            <span class="co">// in the case where the first node was on the left, and the condition above did not meet, that means first node is on the</span></span>
<span id="cb17-26"><a href="#cb17-26" aria-hidden="true" tabindex="-1"></a>            <span class="co">// left but the second one is also on the left, not on the right (secondOnRight would be false), so we go to the left</span></span>
<span id="cb17-27"><a href="#cb17-27" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="fu">ancestor</span><span class="op">(</span>root<span class="op">.</span><span class="fu">left</span><span class="op">,</span> first<span class="op">,</span> second<span class="op">);</span></span>
<span id="cb17-28"><a href="#cb17-28" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb17-29"><a href="#cb17-29" aria-hidden="true" tabindex="-1"></a>            <span class="co">// the same as above but inversed, if firstOnLeft was false, that would automatically mean that secondOnRight was true,</span></span>
<span id="cb17-30"><a href="#cb17-30" aria-hidden="true" tabindex="-1"></a>            <span class="co">// therefore the first node is on the right so is the second, go to the right subtree</span></span>
<span id="cb17-31"><a href="#cb17-31" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="fu">ancestor</span><span class="op">(</span>root<span class="op">.</span><span class="fu">right</span><span class="op">,</span> first<span class="op">,</span> second<span class="op">);</span></span>
<span id="cb17-32"><a href="#cb17-32" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb17-33"><a href="#cb17-33" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<h3 id="comparison">Comparison</h3>
<p>There is another problem that comes very often, namely comparing two
subtrees, to check if they are equal / the same. To do that we have to
traverse both trees at the same time going from the root to the subtrees
depth-first or breath-first, does not matter, in either case we have to
go through both at the same rate, and keep comparing the nodes, if all
nodes are exactly matching and at the same spot in both trees, we can
deduce they are equal</p>
<div class="sourceCode" id="cb18"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a>    <span class="dt">boolean</span> <span class="fu">compare</span><span class="op">(</span><span class="bu">Node</span> first<span class="op">,</span> <span class="bu">Node</span> second<span class="op">)</span> <span class="op">{</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>first <span class="op">==</span> <span class="kw">null</span> <span class="op">&amp;&amp;</span> second <span class="op">==</span> <span class="kw">null</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a>            <span class="co">// when the two subtrees are null, they are considered equal, this base case will also be fulfilled when we reach the bottom</span></span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a>            <span class="co">// of the two trees we compare at the same rate / time / steps, knowing we have finished both trees at the same time</span></span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="kw">true</span><span class="op">;</span></span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-8"><a href="#cb18-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>first <span class="op">==</span> <span class="kw">null</span> <span class="op">&amp;&amp;</span> second <span class="op">!=</span> <span class="kw">null</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb18-9"><a href="#cb18-9" aria-hidden="true" tabindex="-1"></a>            <span class="co">// we have reached the bottom of the first tree, but the second did not, meaning that moving at the same pace, the first</span></span>
<span id="cb18-10"><a href="#cb18-10" aria-hidden="true" tabindex="-1"></a>            <span class="co">// tree was shorter / smaller than the second one</span></span>
<span id="cb18-11"><a href="#cb18-11" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="kw">false</span><span class="op">;</span></span>
<span id="cb18-12"><a href="#cb18-12" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb18-13"><a href="#cb18-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-14"><a href="#cb18-14" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>second <span class="op">==</span> <span class="kw">null</span> <span class="op">&amp;&amp;</span> first <span class="op">!=</span> <span class="kw">null</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb18-15"><a href="#cb18-15" aria-hidden="true" tabindex="-1"></a>            <span class="co">// we have reached the bottom of the second tree, but the first did not, meaning that moving at the same pace, the second</span></span>
<span id="cb18-16"><a href="#cb18-16" aria-hidden="true" tabindex="-1"></a>            <span class="co">// tree was shorter / smaller than the first one</span></span>
<span id="cb18-17"><a href="#cb18-17" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="kw">false</span><span class="op">;</span></span>
<span id="cb18-18"><a href="#cb18-18" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb18-19"><a href="#cb18-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-20"><a href="#cb18-20" aria-hidden="true" tabindex="-1"></a>        <span class="co">// compare the values of the roots</span></span>
<span id="cb18-21"><a href="#cb18-21" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>first<span class="op">.</span><span class="fu">value</span><span class="op">.</span><span class="fu">equals</span><span class="op">(</span>second<span class="op">.</span><span class="fu">value</span><span class="op">))</span> <span class="op">{</span></span>
<span id="cb18-22"><a href="#cb18-22" aria-hidden="true" tabindex="-1"></a>            <span class="co">// compare the roots, only if the roots have the same value, can we then continue down, with the same rate/steps into both</span></span>
<span id="cb18-23"><a href="#cb18-23" aria-hidden="true" tabindex="-1"></a>            <span class="co">// subtrees, what we do here is just drill down equally deep and on the same side for both input trees, if all roots match</span></span>
<span id="cb18-24"><a href="#cb18-24" aria-hidden="true" tabindex="-1"></a>            <span class="co">// up on each side then we can assume they are equal, imagine it as if we had compared two strings, we compare current char,</span></span>
<span id="cb18-25"><a href="#cb18-25" aria-hidden="true" tabindex="-1"></a>            <span class="co">// then move right one character, until the string ends</span></span>
<span id="cb18-26"><a href="#cb18-26" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="fu">compare</span><span class="op">(</span>first<span class="op">.</span><span class="fu">left</span><span class="op">,</span> second<span class="op">.</span><span class="fu">left</span><span class="op">)</span> <span class="op">&amp;&amp;</span> <span class="fu">compare</span><span class="op">(</span>first<span class="op">.</span><span class="fu">right</span><span class="op">,</span> second<span class="op">.</span><span class="fu">right</span><span class="op">);</span></span>
<span id="cb18-27"><a href="#cb18-27" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb18-28"><a href="#cb18-28" aria-hidden="true" tabindex="-1"></a>        <span class="co">// the root value did not match, meaning we can terminate, they are not equal here, even though there still might be more</span></span>
<span id="cb18-29"><a href="#cb18-29" aria-hidden="true" tabindex="-1"></a>        <span class="co">// children to look at</span></span>
<span id="cb18-30"><a href="#cb18-30" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="kw">false</span><span class="op">;</span></span>
<span id="cb18-31"><a href="#cb18-31" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<h3 id="subtrees">Subtrees</h3>
<p>Another common problem is to find if a subtree exists in a given
tree, usually the subtree is much smaller than the main tree itself.
This is done by leveraging <code>compare</code>, the check function
first drills down to the bottom of the main tree, and then starts to run
<code>compare</code> while unwinding the recursion. Going to the bottom
first approach or top first does not matter, all that matters is that we
traverse the entire tree, and we find the subtree in either the left or
right sub branches. Note the condition which is
<code>check(left) || check(right) || compare(main, sub)</code>.</p>
<div class="sourceCode" id="cb19"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a>    <span class="dt">boolean</span> <span class="fu">check</span><span class="op">(</span><span class="bu">Node</span> main<span class="op">,</span> <span class="bu">Node</span> subtree<span class="op">)</span> <span class="op">{</span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>subtree <span class="op">==</span> <span class="kw">null</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a>            <span class="co">// a null subtree, means that it is always a part of the main subtree, the main subtree contains many null subtrees, think</span></span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a>            <span class="co">// of the leaves which have &#39;null&#39; subtrees or in other words the children of the leaves</span></span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="kw">true</span><span class="op">;</span></span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb19-7"><a href="#cb19-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>main <span class="op">==</span> <span class="kw">null</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb19-8"><a href="#cb19-8" aria-hidden="true" tabindex="-1"></a>            <span class="co">// the main subtree must not be null, otherwise there is nothing to check against, and the comparison is invalid</span></span>
<span id="cb19-9"><a href="#cb19-9" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="kw">false</span><span class="op">;</span></span>
<span id="cb19-10"><a href="#cb19-10" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb19-11"><a href="#cb19-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-12"><a href="#cb19-12" aria-hidden="true" tabindex="-1"></a>        <span class="co">// we first drill down the left and right branches, then the post recursive call will compare from the bottom - up approach,</span></span>
<span id="cb19-13"><a href="#cb19-13" aria-hidden="true" tabindex="-1"></a>        <span class="co">// either bottom-up or down will work, we have selected to use bottom-up in this example solution</span></span>
<span id="cb19-14"><a href="#cb19-14" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="fu">check</span><span class="op">(</span>main<span class="op">.</span><span class="fu">left</span><span class="op">,</span> subtree<span class="op">)</span> <span class="op">||</span> <span class="fu">check</span><span class="op">(</span>main<span class="op">.</span><span class="fu">right</span><span class="op">,</span> subtree<span class="op">)</span> <span class="op">||</span> <span class="fu">compare</span><span class="op">(</span>main<span class="op">,</span> subtree<span class="op">);</span></span>
<span id="cb19-15"><a href="#cb19-15" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<h3 id="size">Size</h3>
<p>To dynamically calculate the size, or in other words the number of
nodes a given tree, and to avoid storing that into the node itself as
additional information we have to care about and update we can leverage
the following approach</p>
<div class="sourceCode" id="cb20"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> <span class="fu">size</span><span class="op">(</span>BinaryNode<span class="op">&lt;</span><span class="bu">Integer</span><span class="op">&gt;</span> root<span class="op">)</span> <span class="op">{</span></span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">// a null node has no size really, so we return 0 by default</span></span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>root <span class="op">==</span> <span class="kw">null</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb20-6"><a href="#cb20-6" aria-hidden="true" tabindex="-1"></a>    <span class="co">// each valid node, has at least a size of 1 + the size of the left or right</span></span>
<span id="cb20-7"><a href="#cb20-7" aria-hidden="true" tabindex="-1"></a>    <span class="co">// subchildren, whichever it has, if it has any at all</span></span>
<span id="cb20-8"><a href="#cb20-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">1</span> <span class="op">+</span> <span class="fu">size</span><span class="op">(</span>root<span class="op">.</span><span class="fu">left</span><span class="op">)</span> <span class="op">+</span> <span class="fu">size</span><span class="op">(</span>root<span class="op">.</span><span class="fu">right</span><span class="op">);</span></span>
<span id="cb20-9"><a href="#cb20-9" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="random">Random</h3>
<p>A common problem, is selecting a random node from a binary tree,
where the each node in the tree has an equal chance to be selected. What
we have to consider is how to proportionally select a random element,
from a tree, which might be imbalanced.</p>
<p>What we need to know is how many nodes, each of our subtrees for the
current root has. Let us take the example below, the tree has a total of
7 elements, however the left sub tree is quite a bit heavier in
comparison to the right one. To be able to select a random node with
equal probability, we have to take this into account</p>
<div class="sourceCode" id="cb21"><pre
class="sourceCode txt"><code class="sourceCode default"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a>       10</span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a>      /  \</span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a>     3   15</span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a>   /  \</span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true" tabindex="-1"></a>  1    4</span>
<span id="cb21-6"><a href="#cb21-6" aria-hidden="true" tabindex="-1"></a> / \</span>
<span id="cb21-7"><a href="#cb21-7" aria-hidden="true" tabindex="-1"></a>0   2</span></code></pre></div>
<p>We start off with a random number (say 1, that is index 1, elements
run from 0 to 6, for total of 7 elements). We can check the size (num of
nodes in that subtree) of our left subtree, starting from 10, our left
subtree size is 5, the right subtree is 1, the index we have picked is
less than the size of the left subtree size, therefore we go to the
left, for root 10 element indices span from left[0-4] root[5]
right[6-6]</p>
<p>Next is the root 3, its left size is 4, its right size is 1, the
index is still less, indices for root 3 span from left[0-2] root[3]
right[4-4].</p>
<p>We will keep going down, to the left, to 1, where the size of the
left is 1, the right is 1, the indices of the elements for root 1 span
from left[0-0] root[1] right[2,2], now here our input random index is
equal to the ‘index’ of our root.</p>
<p>Eventually if the random index is not greater than the total number
of elements in the tree - 1 (which is a must) then the function will
fall down into this sole base case i.e. where
<code>index == root_index</code></p>
<div class="sourceCode" id="cb22"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a>    <span class="bu">Node</span> <span class="fu">random</span><span class="op">(</span><span class="bu">Node</span> root<span class="op">,</span> <span class="dt">int</span> index<span class="op">)</span> <span class="op">{</span></span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a>        <span class="co">// this is not a valid case we can simply return nil</span></span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>root <span class="op">==</span> <span class="kw">null</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="kw">null</span><span class="op">;</span></span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb22-6"><a href="#cb22-6" aria-hidden="true" tabindex="-1"></a>        <span class="co">// this must always be true, for each invocation otherwise the index is not within the correct boundaries, this is a sanity</span></span>
<span id="cb22-7"><a href="#cb22-7" aria-hidden="true" tabindex="-1"></a>        <span class="co">// check, but is actually deduceable, if we know we are given a valid index always, the index will always be less than the total</span></span>
<span id="cb22-8"><a href="#cb22-8" aria-hidden="true" tabindex="-1"></a>        <span class="co">// number of elements / size of the current subtree and always greater or equal to 0</span></span>
<span id="cb22-9"><a href="#cb22-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">assert</span> <span class="op">(</span>index <span class="op">&gt;=</span> <span class="dv">0</span> <span class="op">&amp;&amp;</span> index <span class="op">&lt;</span> <span class="fu">size</span><span class="op">(</span>root<span class="op">));</span></span>
<span id="cb22-10"><a href="#cb22-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-11"><a href="#cb22-11" aria-hidden="true" tabindex="-1"></a>        <span class="co">// find how many elements there are in the left subtree, if we know how many elements we have on the left, and we know that the</span></span>
<span id="cb22-12"><a href="#cb22-12" aria-hidden="true" tabindex="-1"></a>        <span class="co">// input index will never exceed the total number of elements for the current index (which we guarantee below by clamping the</span></span>
<span id="cb22-13"><a href="#cb22-13" aria-hidden="true" tabindex="-1"></a>        <span class="co">// index when going to the right) we can know with certainty in which direction we have to go, when the index value is within</span></span>
<span id="cb22-14"><a href="#cb22-14" aria-hidden="true" tabindex="-1"></a>        <span class="co">// these 3 ranges below</span></span>
<span id="cb22-15"><a href="#cb22-15" aria-hidden="true" tabindex="-1"></a>        <span class="co">// - [0 - (leftSize - 1)] - go to the left</span></span>
<span id="cb22-16"><a href="#cb22-16" aria-hidden="true" tabindex="-1"></a>        <span class="co">// - [leftSize - leftSize] - exactly at the root</span></span>
<span id="cb22-17"><a href="#cb22-17" aria-hidden="true" tabindex="-1"></a>        <span class="co">// - [(leftSize + 1) - (total subtree size)] - go to the right</span></span>
<span id="cb22-18"><a href="#cb22-18" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> leftSize <span class="op">=</span> <span class="fu">size</span><span class="op">(</span>root<span class="op">.</span><span class="fu">left</span><span class="op">);</span></span>
<span id="cb22-19"><a href="#cb22-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-20"><a href="#cb22-20" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>index <span class="op">&lt;</span> leftSize<span class="op">)</span> <span class="op">{</span></span>
<span id="cb22-21"><a href="#cb22-21" aria-hidden="true" tabindex="-1"></a>            <span class="co">// if the index is within the number of elements in the left subtree go down the left subtree path, the index does not need</span></span>
<span id="cb22-22"><a href="#cb22-22" aria-hidden="true" tabindex="-1"></a>            <span class="co">// to be touched for the current left subtree, since the range of the index falls exactly in elements within the current</span></span>
<span id="cb22-23"><a href="#cb22-23" aria-hidden="true" tabindex="-1"></a>            <span class="co">// left sub tree, we adjust the index only when we have to go to the right, and we go to the right only when the index is</span></span>
<span id="cb22-24"><a href="#cb22-24" aria-hidden="true" tabindex="-1"></a>            <span class="co">// outside the boundaries of left and root i.e between [(leftSize + 1) and (total subtree size)]</span></span>
<span id="cb22-25"><a href="#cb22-25" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="fu">random</span><span class="op">(</span>root<span class="op">.</span><span class="fu">left</span><span class="op">,</span> index<span class="op">);</span></span>
<span id="cb22-26"><a href="#cb22-26" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span> <span class="cf">else</span> <span class="cf">if</span> <span class="op">(</span>index <span class="op">==</span> leftSize<span class="op">)</span> <span class="op">{</span></span>
<span id="cb22-27"><a href="#cb22-27" aria-hidden="true" tabindex="-1"></a>            <span class="co">// if the index is exactly the left size, that means this is the root item exactly, left indexed items are only from [0 and</span></span>
<span id="cb22-28"><a href="#cb22-28" aria-hidden="true" tabindex="-1"></a>            <span class="co">// leftSize - 1], index equaling leftSize means we have to pick the root, at some point at some level this is the base case</span></span>
<span id="cb22-29"><a href="#cb22-29" aria-hidden="true" tabindex="-1"></a>            <span class="co">// which we will hit for sure, while going down, the index will become equal to the root &#39;index&#39; and we stop and return</span></span>
<span id="cb22-30"><a href="#cb22-30" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> root<span class="op">;</span></span>
<span id="cb22-31"><a href="#cb22-31" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb22-32"><a href="#cb22-32" aria-hidden="true" tabindex="-1"></a>            <span class="co">// if the index falls in the right subtree, before going down the right subtree, we have to normalize the index, while the</span></span>
<span id="cb22-33"><a href="#cb22-33" aria-hidden="true" tabindex="-1"></a>            <span class="co">// current index is valid for the current tree, when we go down the right one, we have to clamp the index to be valid for the</span></span>
<span id="cb22-34"><a href="#cb22-34" aria-hidden="true" tabindex="-1"></a>            <span class="co">// right sub tree, to do that we have to calculate what the current index corresponds to in terms of the right sub tree, this</span></span>
<span id="cb22-35"><a href="#cb22-35" aria-hidden="true" tabindex="-1"></a>            <span class="co">// we can deduce by knowning that (lefSize + 1) is the lower bound index for the right sub-tree, therefore we can subtract that</span></span>
<span id="cb22-36"><a href="#cb22-36" aria-hidden="true" tabindex="-1"></a>            <span class="co">// from the current index. This will give us an index which is in the index space of the right subtree for the current root, then</span></span>
<span id="cb22-37"><a href="#cb22-37" aria-hidden="true" tabindex="-1"></a>            <span class="co">// we can call the function with the new index and the rigth subtree as the new root.</span></span>
<span id="cb22-38"><a href="#cb22-38" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-39"><a href="#cb22-39" aria-hidden="true" tabindex="-1"></a>            <span class="co">// For example if the tree at this moment has 10 elements, and the target index was 9, the left size was 6, and we account</span></span>
<span id="cb22-40"><a href="#cb22-40" aria-hidden="true" tabindex="-1"></a>            <span class="co">// for the 1 element being the current root, then we can deduce that the right subtree has 3 elements, therefore the new</span></span>
<span id="cb22-41"><a href="#cb22-41" aria-hidden="true" tabindex="-1"></a>            <span class="co">// index must be in range [0-2], and it will be, indeed : 9 - (6 + 1) = 2</span></span>
<span id="cb22-42"><a href="#cb22-42" aria-hidden="true" tabindex="-1"></a>            index <span class="op">=</span> index <span class="op">-</span> <span class="op">(</span>leftSize <span class="op">+</span> <span class="dv">1</span><span class="op">);</span></span>
<span id="cb22-43"><a href="#cb22-43" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="fu">random</span><span class="op">(</span>root<span class="op">.</span><span class="fu">right</span><span class="op">,</span> index<span class="op">);</span></span>
<span id="cb22-44"><a href="#cb22-44" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb22-45"><a href="#cb22-45" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb22-46"><a href="#cb22-46" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-47"><a href="#cb22-47" aria-hidden="true" tabindex="-1"></a>    <span class="co">// initial invocation, note index is between [0, size - 1]</span></span>
<span id="cb22-48"><a href="#cb22-48" aria-hidden="true" tabindex="-1"></a>    <span class="fu">random</span><span class="op">(</span><span class="fu">create</span><span class="op">(</span>elements<span class="op">),</span> <span class="fu">random</span><span class="op">(</span><span class="dv">0</span><span class="op">,</span> elements<span class="op">.</span><span class="fu">size</span><span class="op">()</span> <span class="op">-</span> <span class="dv">1</span><span class="op">))</span></span></code></pre></div>
<h3 id="binary-search-trees">Binary search trees</h3>
<p>The most simple implementation of a binary search tree, is one that
simply conform to the rule, and does not try to keep the tree balanced,
which in some cases can lead to linear search time complexity, since the
tree can get malformed into a linked list, which can very often happen,
when the tree is not kept balanced.</p>
<p>For example, adding a new element which is always bigger or always
smaller than the previous added one, would form a linked list of nodes,
making only one side of the tree have nodes</p>
<p>Here first 10 was inserted, then 5, then 3, and if we keep adding
smaller and smaller elements, 2, 1, 0 etc, the tree would keep forming a
linked list of nodes. These elements can be re-structured (called
balancing) to make the structure more like a tree, which would have a
search of O(log(n)), instead of the O(n) which is what it is going to be
if the tree looks like a list.</p>
<div class="sourceCode" id="cb23"><pre
class="sourceCode txt"><code class="sourceCode default"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a>          10</span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a>        /</span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a>      5</span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true" tabindex="-1"></a>    /</span>
<span id="cb23-5"><a href="#cb23-5" aria-hidden="true" tabindex="-1"></a>   3</span></code></pre></div>
<h4 id="creating-1">Creating</h4>
<p>One way to quickly create a binary search tree given a sorted array
of elements, is to simply binary partition the array. What we do is
partition the tree in half. What is important to note here is how we
control start and end. They are based off of the root index.</p>
<ul>
<li>the left subtree is created from the left half of the array, i.e all
elements from start to just before the current root’s index in the
array</li>
<li>the right subtree is create from the right half of the array, i.e
all elements from the current root’s index + 1, to the end of the
array</li>
</ul>
<div class="sourceCode" id="cb24"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a>    <span class="bu">Node</span> <span class="fu">create</span><span class="op">(</span><span class="bu">List</span> elements<span class="op">,</span> <span class="dt">int</span> start<span class="op">,</span> <span class="dt">int</span> end<span class="op">)</span> <span class="op">{</span></span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a>        <span class="co">// calculate the diff between start and end, note that start is index, and end is a size, therefore the only valid difference</span></span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a>        <span class="co">// between them can be at most 1, for example when start = 0 and end = 1, that means the sub-array we have to look at has</span></span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true" tabindex="-1"></a>        <span class="co">// only one element, the one at index 0, end tells us the number of items in the sub-array, the start is the starting index</span></span>
<span id="cb24-5"><a href="#cb24-5" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> diff <span class="op">=</span> end <span class="op">-</span> start<span class="op">;</span></span>
<span id="cb24-6"><a href="#cb24-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-7"><a href="#cb24-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>diff <span class="op">&lt;=</span> <span class="dv">0</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb24-8"><a href="#cb24-8" aria-hidden="true" tabindex="-1"></a>            <span class="co">// if the diff is invalid just return here and stop recursion, this would imply that the start (index) overlaps with end</span></span>
<span id="cb24-9"><a href="#cb24-9" aria-hidden="true" tabindex="-1"></a>            <span class="co">// (size), which is not a valid state, meaning we can stop, nothing more to subdivide</span></span>
<span id="cb24-10"><a href="#cb24-10" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="kw">null</span><span class="op">;</span></span>
<span id="cb24-11"><a href="#cb24-11" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb24-12"><a href="#cb24-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-13"><a href="#cb24-13" aria-hidden="true" tabindex="-1"></a>        <span class="co">// the current midpoint index is the diff divided by two, offset with the start index. The diff / 2 would give us the relative</span></span>
<span id="cb24-14"><a href="#cb24-14" aria-hidden="true" tabindex="-1"></a>        <span class="co">// mid point element, for the current subdivided sub-array, but to make it absolute in the context of the source input array we</span></span>
<span id="cb24-15"><a href="#cb24-15" aria-hidden="true" tabindex="-1"></a>        <span class="co">// have to add the current start index to that.</span></span>
<span id="cb24-16"><a href="#cb24-16" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> index <span class="op">=</span> start <span class="op">+</span> <span class="op">(</span>diff <span class="op">/</span> <span class="dv">2</span><span class="op">);</span></span>
<span id="cb24-17"><a href="#cb24-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-18"><a href="#cb24-18" aria-hidden="true" tabindex="-1"></a>        <span class="co">// create the new root node, the value for that new root node would be the one at &#39;index&#39;, or in other words the midpoint</span></span>
<span id="cb24-19"><a href="#cb24-19" aria-hidden="true" tabindex="-1"></a>        <span class="co">// element in the array, for the current range of start and end</span></span>
<span id="cb24-20"><a href="#cb24-20" aria-hidden="true" tabindex="-1"></a>        <span class="bu">Node</span> node <span class="op">=</span> <span class="kw">new</span> <span class="bu">Node</span><span class="op">();</span></span>
<span id="cb24-21"><a href="#cb24-21" aria-hidden="true" tabindex="-1"></a>        node<span class="op">.</span><span class="fu">value</span> <span class="op">=</span> array<span class="op">[</span>index<span class="op">];</span></span>
<span id="cb24-22"><a href="#cb24-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-23"><a href="#cb24-23" aria-hidden="true" tabindex="-1"></a>        <span class="co">// the left subtree for the root node start from start up until, but not including the current node i.e start -&gt; index, remember</span></span>
<span id="cb24-24"><a href="#cb24-24" aria-hidden="true" tabindex="-1"></a>        <span class="co">// the end argument to this function is not an index, it is a size, so the range of elements for the left subtree would be</span></span>
<span id="cb24-25"><a href="#cb24-25" aria-hidden="true" tabindex="-1"></a>        <span class="co">// the inclusive range [start:index-1]</span></span>
<span id="cb24-26"><a href="#cb24-26" aria-hidden="true" tabindex="-1"></a>        node<span class="op">.</span><span class="fu">left</span> <span class="op">=</span> <span class="fu">create</span><span class="op">(</span>array<span class="op">,</span> start<span class="op">,</span> index<span class="op">);</span></span>
<span id="cb24-27"><a href="#cb24-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-28"><a href="#cb24-28" aria-hidden="true" tabindex="-1"></a>        <span class="co">// the right subtree for the root node start from start up until, but not including the current node i.e index + 1 -&gt; end,</span></span>
<span id="cb24-29"><a href="#cb24-29" aria-hidden="true" tabindex="-1"></a>        <span class="co">// remember the end argument to this function is not an index, it is a size, so the range of elements for the right subtree</span></span>
<span id="cb24-30"><a href="#cb24-30" aria-hidden="true" tabindex="-1"></a>        <span class="co">// would be the inclusive range [index+1:end-1]</span></span>
<span id="cb24-31"><a href="#cb24-31" aria-hidden="true" tabindex="-1"></a>        node<span class="op">.</span><span class="fu">right</span> <span class="op">=</span> <span class="fu">create</span><span class="op">(</span>array<span class="op">,</span> index <span class="op">+</span> <span class="dv">1</span><span class="op">,</span> end<span class="op">);</span></span>
<span id="cb24-32"><a href="#cb24-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-33"><a href="#cb24-33" aria-hidden="true" tabindex="-1"></a>        <span class="co">// return the node</span></span>
<span id="cb24-34"><a href="#cb24-34" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> node<span class="op">;</span></span>
<span id="cb24-35"><a href="#cb24-35" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb24-36"><a href="#cb24-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-37"><a href="#cb24-37" aria-hidden="true" tabindex="-1"></a>    <span class="fu">create</span><span class="op">(</span>elements<span class="op">,</span> <span class="dv">0</span><span class="op">,</span> elements<span class="op">.</span><span class="fu">size</span><span class="op">());</span></span></code></pre></div>
<h4 id="validating">Validating</h4>
<p>To validate a tree is a binary search tree, to do this we use an
approach where with each path we take to the left or the right we narrow
down the starting min and max rnages. Initially they start off as nil,
at the very root of the tree.</p>
<p>When we go to the left, we know that all elements to the left must be
smaller than our root, therefore we set the max to be the current root,
when we go to the right we set the min to be the current root, as
elements to the right cannot be smaller than the current root.</p>
<p>Going down left and right the min and max represent the path we came
from, the values of the roots we came from, and if all of those child
nodes in the left AND right subtrees up until the very leaves do match
the condition
<code>root.value &gt; min &amp;&amp; root.value &lt; max</code>, we know
that the BST property is met.</p>
<div class="sourceCode" id="cb25"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a>    <span class="dt">boolean</span> <span class="fu">check</span><span class="op">(</span>BinaryNode<span class="op">&lt;</span><span class="bu">Integer</span><span class="op">&gt;</span> root<span class="op">,</span> <span class="bu">Integer</span> min<span class="op">,</span> <span class="bu">Integer</span> max<span class="op">)</span> <span class="op">{</span></span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>root <span class="op">==</span> <span class="kw">null</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a>            <span class="co">// this is a weird base case, but if we reach this point it means we have traversed the entire tree and it has kept the bst</span></span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true" tabindex="-1"></a>            <span class="co">// property up until the very bottom</span></span>
<span id="cb25-5"><a href="#cb25-5" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="kw">true</span><span class="op">;</span></span>
<span id="cb25-6"><a href="#cb25-6" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb25-7"><a href="#cb25-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-8"><a href="#cb25-8" aria-hidden="true" tabindex="-1"></a>        <span class="co">// we know that the current root value must not be smaller than min and not bigger than max range, if it is either, then the</span></span>
<span id="cb25-9"><a href="#cb25-9" aria-hidden="true" tabindex="-1"></a>        <span class="co">// tree does not meet the bst rules, we return false</span></span>
<span id="cb25-10"><a href="#cb25-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">((</span>min <span class="op">!=</span> <span class="kw">null</span> <span class="op">&amp;&amp;</span> root<span class="op">.</span><span class="fu">value</span> <span class="op">&lt;</span> min<span class="op">)</span> <span class="op">||</span> <span class="op">(</span>max <span class="op">!=</span> <span class="kw">null</span> <span class="op">&amp;&amp;</span> root<span class="op">.</span><span class="fu">value</span> <span class="op">&gt;</span> max<span class="op">))</span> <span class="op">{</span></span>
<span id="cb25-11"><a href="#cb25-11" aria-hidden="true" tabindex="-1"></a>            <span class="co">// the current root value was not within the max or min ranges, therefore it does not meet the rules of a bst, return false,</span></span>
<span id="cb25-12"><a href="#cb25-12" aria-hidden="true" tabindex="-1"></a>            <span class="co">// the and (&amp;&amp;) condition below would guarantee that for this tree as a whole the check for bst would return false</span></span>
<span id="cb25-13"><a href="#cb25-13" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="kw">false</span><span class="op">;</span></span>
<span id="cb25-14"><a href="#cb25-14" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb25-15"><a href="#cb25-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-16"><a href="#cb25-16" aria-hidden="true" tabindex="-1"></a>        <span class="co">// the trick here is to see how we gradually restrict the max/min values while we go down. When we start going left/right down</span></span>
<span id="cb25-17"><a href="#cb25-17" aria-hidden="true" tabindex="-1"></a>        <span class="co">// the tree, the min/max ranges would keep narrowing down, note that both subtrees must evalute to true, i.e must conform to the</span></span>
<span id="cb25-18"><a href="#cb25-18" aria-hidden="true" tabindex="-1"></a>        <span class="co">// rules of bst, therefore note the and (&amp;&amp;) sign below</span></span>
<span id="cb25-19"><a href="#cb25-19" aria-hidden="true" tabindex="-1"></a>        <span class="co">// - the left sub-tree we know that values there can not be bigger than root.value, therefore we set max to be root.value</span></span>
<span id="cb25-20"><a href="#cb25-20" aria-hidden="true" tabindex="-1"></a>        <span class="co">// - the right sub-tree we know that values there can not be smaller than root.value, therefore we set min to be root.value</span></span>
<span id="cb25-21"><a href="#cb25-21" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="fu">check</span><span class="op">(</span>root<span class="op">.</span><span class="fu">left</span><span class="op">,</span> min<span class="op">,</span> root<span class="op">.</span><span class="fu">value</span><span class="op">)</span> <span class="op">&amp;&amp;</span> <span class="fu">check</span><span class="op">(</span>root<span class="op">.</span><span class="fu">right</span><span class="op">,</span> root<span class="op">.</span><span class="fu">value</span><span class="op">,</span> max<span class="op">);</span></span>
<span id="cb25-22"><a href="#cb25-22" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb25-23"><a href="#cb25-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-24"><a href="#cb25-24" aria-hidden="true" tabindex="-1"></a>    <span class="fu">check</span><span class="op">(</span>root<span class="op">,</span> <span class="kw">null</span><span class="op">,</span> <span class="kw">null</span><span class="op">);</span></span></code></pre></div>
<h4 id="max">Max</h4>
<p>Finding the max element in a BST is simply following all right
subtrees from the root of the tree, the max element would be contained
in the right most child / leaf node starting from the root</p>
<div class="sourceCode" id="cb26"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a>    <span class="bu">Node</span> <span class="fu">max</span><span class="op">(</span><span class="bu">Node</span> root<span class="op">)</span> <span class="op">{</span></span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a>        <span class="co">// to find the max node, simply drill down the right subtree of the current node, until there is no more right nodes left</span></span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span> <span class="op">(</span>root <span class="op">!=</span> <span class="kw">null</span> <span class="op">&amp;&amp;</span> root<span class="op">.</span><span class="fu">right</span> <span class="op">!=</span> <span class="kw">null</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true" tabindex="-1"></a>            root <span class="op">=</span> root<span class="op">.</span><span class="fu">right</span><span class="op">;</span></span>
<span id="cb26-5"><a href="#cb26-5" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb26-6"><a href="#cb26-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> root<span class="op">;</span></span>
<span id="cb26-7"><a href="#cb26-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<h4 id="min">Min</h4>
<p>Finding the min element in a BST is simply following all left
subtrees from the root of the tree, the min element would be contained
in the left most child/leaf node starting from the root</p>
<div class="sourceCode" id="cb27"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a>    <span class="bu">Node</span> <span class="fu">min</span><span class="op">(</span><span class="bu">Node</span> root<span class="op">)</span> <span class="op">{</span></span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a>        <span class="co">// to find the min node, simply drill down the left subtree of the current node, until there is no more left nodes left</span></span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span> <span class="op">(</span>root <span class="op">!=</span> <span class="kw">null</span> <span class="op">&amp;&amp;</span> root<span class="op">.</span><span class="fu">left</span> <span class="op">!=</span> <span class="kw">null</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb27-4"><a href="#cb27-4" aria-hidden="true" tabindex="-1"></a>            root <span class="op">=</span> root<span class="op">.</span><span class="fu">left</span><span class="op">;</span></span>
<span id="cb27-5"><a href="#cb27-5" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb27-6"><a href="#cb27-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> root<span class="op">;</span></span>
<span id="cb27-7"><a href="#cb27-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<h4 id="insertion">Insertion</h4>
<p>This process is very similar to searching a node with a value, we go
down down 3 paths, either the value is bigger, smaller or equal to the
current root’s value,</p>
<ul>
<li>if bigger - go to the right</li>
<li>if smaller - go to the left</li>
<li>if equal - terminate, duplicates are not allowed</li>
</ul>
<p>If we never find an equal element, the recursion will eventually
terminate with root == null, meaning we have drilled down the tree into
a spot which conforms to the rule of BST, and is empty, create a node,
return it up the call stack.</p>
<p>The return is crucial, it would correctly attach the new node to it’s
immediate parent, since we recursed down, and now return back the same
way, due to the call stack unwinding.</p>
<div class="sourceCode" id="cb28"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a>    <span class="bu">Node</span> <span class="fu">insert</span><span class="op">(</span><span class="bu">Node</span> root<span class="op">,</span> <span class="dt">int</span> value<span class="op">)</span> <span class="op">{</span></span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>root <span class="op">==</span> <span class="kw">null</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true" tabindex="-1"></a>            <span class="co">// if we drill down till this point it means that the correct spot for the new element was found, and we create the node and</span></span>
<span id="cb28-4"><a href="#cb28-4" aria-hidden="true" tabindex="-1"></a>            <span class="co">// return it, in the assignments below that node will be assigned correctly to it&#39;s parent node, in other words, the</span></span>
<span id="cb28-5"><a href="#cb28-5" aria-hidden="true" tabindex="-1"></a>            <span class="co">// recursive calls below took right/left paths such that they lead us to a null child, which is the spot at which this new</span></span>
<span id="cb28-6"><a href="#cb28-6" aria-hidden="true" tabindex="-1"></a>            <span class="co">// node must be linked, returning it here, and assignment below will ensure that linkage is made to the parent of this new</span></span>
<span id="cb28-7"><a href="#cb28-7" aria-hidden="true" tabindex="-1"></a>            <span class="co">// node, to either the right or the left child.</span></span>
<span id="cb28-8"><a href="#cb28-8" aria-hidden="true" tabindex="-1"></a>            <span class="bu">Node</span> node <span class="op">=</span> <span class="kw">new</span> <span class="bu">Node</span><span class="op">();</span></span>
<span id="cb28-9"><a href="#cb28-9" aria-hidden="true" tabindex="-1"></a>            node<span class="op">.</span><span class="fu">value</span> <span class="op">=</span> value<span class="op">;</span></span>
<span id="cb28-10"><a href="#cb28-10" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> node<span class="op">;</span></span>
<span id="cb28-11"><a href="#cb28-11" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb28-12"><a href="#cb28-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-13"><a href="#cb28-13" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>value <span class="op">&gt;</span> root<span class="op">.</span><span class="fu">value</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb28-14"><a href="#cb28-14" aria-hidden="true" tabindex="-1"></a>            <span class="co">// we have to go down to the right, this recursive call will either return the same node, if the value is equal to</span></span>
<span id="cb28-15"><a href="#cb28-15" aria-hidden="true" tabindex="-1"></a>            <span class="co">// root.right, or will drill down until there is not root.right anymore, at which point the node will be created with the</span></span>
<span id="cb28-16"><a href="#cb28-16" aria-hidden="true" tabindex="-1"></a>            <span class="co">// new element and returned back</span></span>
<span id="cb28-17"><a href="#cb28-17" aria-hidden="true" tabindex="-1"></a>            root<span class="op">.</span><span class="fu">right</span> <span class="op">=</span> <span class="fu">insert</span><span class="op">(</span>root<span class="op">.</span><span class="fu">right</span><span class="op">,</span> value<span class="op">);</span></span>
<span id="cb28-18"><a href="#cb28-18" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span> <span class="cf">else</span> <span class="cf">if</span> <span class="op">(</span>value <span class="op">&lt;</span> root<span class="op">.</span><span class="fu">value</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb28-19"><a href="#cb28-19" aria-hidden="true" tabindex="-1"></a>            <span class="co">// we have to go down to the left, this recursive call will either return the same node, if the value is equal to</span></span>
<span id="cb28-20"><a href="#cb28-20" aria-hidden="true" tabindex="-1"></a>            <span class="co">// root.left, or will drill down until there is not root.left anymore, at which point the node will be created with the</span></span>
<span id="cb28-21"><a href="#cb28-21" aria-hidden="true" tabindex="-1"></a>            <span class="co">// new element and returned back</span></span>
<span id="cb28-22"><a href="#cb28-22" aria-hidden="true" tabindex="-1"></a>            root<span class="op">.</span><span class="fu">left</span> <span class="op">=</span> <span class="fu">insert</span><span class="op">(</span>root<span class="op">.</span><span class="fu">left</span><span class="op">,</span> value<span class="op">);</span></span>
<span id="cb28-23"><a href="#cb28-23" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb28-24"><a href="#cb28-24" aria-hidden="true" tabindex="-1"></a>        <span class="co">// return the node always, we only recurse inside the if/else, this case here also handlers equals, but in all 3 cases we want to return</span></span>
<span id="cb28-25"><a href="#cb28-25" aria-hidden="true" tabindex="-1"></a>        <span class="co">// the original node anyway</span></span>
<span id="cb28-26"><a href="#cb28-26" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> root<span class="op">;</span></span>
<span id="cb28-27"><a href="#cb28-27" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<h4 id="delete">Delete</h4>
<p>Deletion is a bit more convoluted, but can still be split into a few
base cases. However first the element to be deleted has to be located in
the tree, only if it exists can we proceed to try to delete it.</p>
<ul>
<li><p>if deleting a node without children, simply return null</p></li>
<li><p>if deleting a node with only a left subtree, return that left
subtree</p></li>
<li><p>if deleting a node with only a right subtree, return that right
subtree</p></li>
<li><p>if deleting a node with both subtrees existing, two different
options</p>
<ul>
<li><p>drill down the left subtree and find the max element of
root.left</p></li>
<li><p>drill down the right subtree and find the min element of
root.right</p></li>
<li><p>found element will either be the root.left (max case) or
root.right (min case), when they have no right (max case) or left (min
case) child nodes, or the most right leaf node (max case), or the most
left leaf node (min case).</p></li>
<li><p>the found element’s value we swap with the root, the links of the
found element have to be maintained, and not lost, we have one of two
cases</p>
<ul>
<li>in the max case the found element would not have any right subtrees,
only left ones,</li>
<li>in the min case the found element would not have any left subtrees
only right ones</li>
</ul></li>
<li><p>attach the left/right of the found to the parent of the found
element</p></li>
</ul></li>
</ul>
<p>Deleting the node with value 5, we have to first find the node we
want to delete, in this case let’s assume we have done that. (This
example does not cover all cases, it is just a small showpiece)</p>
<div class="sourceCode" id="cb29"><pre
class="sourceCode txt"><code class="sourceCode default"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a>           10</span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a>        /      \</span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true" tabindex="-1"></a>       5       20</span>
<span id="cb29-4"><a href="#cb29-4" aria-hidden="true" tabindex="-1"></a>      / \     /</span>
<span id="cb29-5"><a href="#cb29-5" aria-hidden="true" tabindex="-1"></a>     3   7   15</span>
<span id="cb29-6"><a href="#cb29-6" aria-hidden="true" tabindex="-1"></a>    /</span>
<span id="cb29-7"><a href="#cb29-7" aria-hidden="true" tabindex="-1"></a>   1</span></code></pre></div>
<p>It has two children, we choose to find the max node from the left
subtree of the node to delete (5), which is the node with value 3. It is
the max since it has no right children, if it had we would have gone
down to the right</p>
<div class="sourceCode" id="cb30"><pre
class="sourceCode txt"><code class="sourceCode default"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a>           10</span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a>        /      \</span>
<span id="cb30-3"><a href="#cb30-3" aria-hidden="true" tabindex="-1"></a>       5       20</span>
<span id="cb30-4"><a href="#cb30-4" aria-hidden="true" tabindex="-1"></a>      / \     /</span>
<span id="cb30-5"><a href="#cb30-5" aria-hidden="true" tabindex="-1"></a>     3   7   15</span>
<span id="cb30-6"><a href="#cb30-6" aria-hidden="true" tabindex="-1"></a>    /</span>
<span id="cb30-7"><a href="#cb30-7" aria-hidden="true" tabindex="-1"></a>   1</span></code></pre></div>
<p>The found node is immediate child of the node to delete (5). Now we
have to detach the found node (3) from the tree, therefore node (5).left
= (3).left (Since we went with max case, we know that there could be
nothing to the right of node 3, otherwise we would have gone down that
route, but there might be to the left)</p>
<div class="sourceCode" id="cb31"><pre
class="sourceCode txt"><code class="sourceCode default"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a>           10</span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true" tabindex="-1"></a>        /      \</span>
<span id="cb31-3"><a href="#cb31-3" aria-hidden="true" tabindex="-1"></a>       5       20</span>
<span id="cb31-4"><a href="#cb31-4" aria-hidden="true" tabindex="-1"></a>      / \     /</span>
<span id="cb31-5"><a href="#cb31-5" aria-hidden="true" tabindex="-1"></a>     /   7   15</span>
<span id="cb31-6"><a href="#cb31-6" aria-hidden="true" tabindex="-1"></a>    /</span>
<span id="cb31-7"><a href="#cb31-7" aria-hidden="true" tabindex="-1"></a>   1</span></code></pre></div>
<p>Finally we set the value of the found node (3) to the value of the
node we want to “delete”, notice how we did not delete the node which
held the value 5, but exchanged the values, and deleted the child of the
node we want to delete (5). The BST property is maintained</p>
<div class="sourceCode" id="cb32"><pre
class="sourceCode txt"><code class="sourceCode default"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a>           10</span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true" tabindex="-1"></a>        /      \</span>
<span id="cb32-3"><a href="#cb32-3" aria-hidden="true" tabindex="-1"></a>       3       20</span>
<span id="cb32-4"><a href="#cb32-4" aria-hidden="true" tabindex="-1"></a>      / \     /</span>
<span id="cb32-5"><a href="#cb32-5" aria-hidden="true" tabindex="-1"></a>     /   7   15</span>
<span id="cb32-6"><a href="#cb32-6" aria-hidden="true" tabindex="-1"></a>    /</span>
<span id="cb32-7"><a href="#cb32-7" aria-hidden="true" tabindex="-1"></a>   1</span></code></pre></div>
<div class="sourceCode" id="cb33"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a>    <span class="bu">Node</span> <span class="fu">delete</span><span class="op">(</span><span class="bu">Node</span> root<span class="op">,</span> T value<span class="op">)</span> <span class="op">{</span></span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>root <span class="op">==</span> <span class="kw">null</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb33-3"><a href="#cb33-3" aria-hidden="true" tabindex="-1"></a>            <span class="co">// drilling down did not find the element, simply abort the deletion, at this point we have reached the end of the possible</span></span>
<span id="cb33-4"><a href="#cb33-4" aria-hidden="true" tabindex="-1"></a>            <span class="co">// path in the tree and the element was not present, the recursion will unwind the call stack till the top, returning</span></span>
<span id="cb33-5"><a href="#cb33-5" aria-hidden="true" tabindex="-1"></a>            <span class="co">// the nodes unmodified</span></span>
<span id="cb33-6"><a href="#cb33-6" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="kw">null</span><span class="op">;</span></span>
<span id="cb33-7"><a href="#cb33-7" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb33-8"><a href="#cb33-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-9"><a href="#cb33-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>value <span class="op">&gt;</span> root<span class="op">.</span><span class="fu">value</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb33-10"><a href="#cb33-10" aria-hidden="true" tabindex="-1"></a>            <span class="co">// drill down the right subtree until we find equal element, note the assignment, this allows us to propagate changes to</span></span>
<span id="cb33-11"><a href="#cb33-11" aria-hidden="true" tabindex="-1"></a>            <span class="co">// the correct subtree, allowing us to re-link a non-immediate child node with the current root, sub recursive calls can</span></span>
<span id="cb33-12"><a href="#cb33-12" aria-hidden="true" tabindex="-1"></a>            <span class="co">// return child nodes deep in the tree, and assign them to the current node, making linking very easy, without having to</span></span>
<span id="cb33-13"><a href="#cb33-13" aria-hidden="true" tabindex="-1"></a>            <span class="co">// keep track of parent nodes.</span></span>
<span id="cb33-14"><a href="#cb33-14" aria-hidden="true" tabindex="-1"></a>            root<span class="op">.</span><span class="fu">right</span> <span class="op">=</span> <span class="fu">delete</span><span class="op">(</span>root<span class="op">.</span><span class="fu">right</span><span class="op">,</span> value<span class="op">);</span></span>
<span id="cb33-15"><a href="#cb33-15" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span> <span class="cf">else</span> <span class="cf">if</span> <span class="op">(</span>value <span class="op">&lt;</span> root<span class="op">.</span><span class="fu">value</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb33-16"><a href="#cb33-16" aria-hidden="true" tabindex="-1"></a>            <span class="co">// drill down the left subtree until we find equal element, note the assignment, this allows us to propagate changes to</span></span>
<span id="cb33-17"><a href="#cb33-17" aria-hidden="true" tabindex="-1"></a>            <span class="co">// the correct subtree, allowing us to re-link a non-immediate child node with the current root, sub recursive calls can</span></span>
<span id="cb33-18"><a href="#cb33-18" aria-hidden="true" tabindex="-1"></a>            <span class="co">// return child nodes deep in the tree, and assign them to the current node, making linking very easy, without having to</span></span>
<span id="cb33-19"><a href="#cb33-19" aria-hidden="true" tabindex="-1"></a>            <span class="co">// keep track of parent nodes.</span></span>
<span id="cb33-20"><a href="#cb33-20" aria-hidden="true" tabindex="-1"></a>            root<span class="op">.</span><span class="fu">left</span> <span class="op">=</span> <span class="fu">delete</span><span class="op">(</span>root<span class="op">.</span><span class="fu">left</span><span class="op">,</span> value<span class="op">);</span></span>
<span id="cb33-21"><a href="#cb33-21" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb33-22"><a href="#cb33-22" aria-hidden="true" tabindex="-1"></a>            <span class="co">// at this point the root would point at an element with value which must be equal to the target value, why ?, we will be</span></span>
<span id="cb33-23"><a href="#cb33-23" aria-hidden="true" tabindex="-1"></a>            <span class="co">// here only if the value is equal to the root, any other case will either exit, if node == null, we have drilled down to</span></span>
<span id="cb33-24"><a href="#cb33-24" aria-hidden="true" tabindex="-1"></a>            <span class="co">// the bottom of the path, if value &gt; root.value or value &lt; root.value then we will keep recursing, therefore we reach this</span></span>
<span id="cb33-25"><a href="#cb33-25" aria-hidden="true" tabindex="-1"></a>            <span class="co">// point only when value equals root.value</span></span>
<span id="cb33-26"><a href="#cb33-26" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>root<span class="op">.</span><span class="fu">left</span> <span class="op">==</span> <span class="kw">null</span> <span class="op">&amp;&amp;</span> root<span class="op">.</span><span class="fu">right</span> <span class="op">==</span> <span class="kw">null</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb33-27"><a href="#cb33-27" aria-hidden="true" tabindex="-1"></a>                <span class="co">// the root with the value has no children, therefore, we return null, this return is very crucial, it will return to</span></span>
<span id="cb33-28"><a href="#cb33-28" aria-hidden="true" tabindex="-1"></a>                <span class="co">// the previous recursive call where the root will reference the parent of the current root node, therefore without</span></span>
<span id="cb33-29"><a href="#cb33-29" aria-hidden="true" tabindex="-1"></a>                <span class="co">// using any parent pointers in the tree, we will correctly assign to the left or right of the parent of this root,</span></span>
<span id="cb33-30"><a href="#cb33-30" aria-hidden="true" tabindex="-1"></a>                <span class="co">// null, detaching the current node that was found to equal the value</span></span>
<span id="cb33-31"><a href="#cb33-31" aria-hidden="true" tabindex="-1"></a>                <span class="cf">return</span> <span class="kw">null</span><span class="op">;</span></span>
<span id="cb33-32"><a href="#cb33-32" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span> <span class="cf">else</span> <span class="cf">if</span> <span class="op">(</span>root<span class="op">.</span><span class="fu">left</span> <span class="op">!=</span> <span class="kw">null</span> <span class="op">&amp;&amp;</span> root<span class="op">.</span><span class="fu">right</span> <span class="op">==</span> <span class="kw">null</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb33-33"><a href="#cb33-33" aria-hidden="true" tabindex="-1"></a>                <span class="co">// the same as above, but instead, we know that we have only left subtree, therefore we link the left subtree of the</span></span>
<span id="cb33-34"><a href="#cb33-34" aria-hidden="true" tabindex="-1"></a>                <span class="co">// current root, which equals the target value, to the parent of the current root, this will essentially attach the</span></span>
<span id="cb33-35"><a href="#cb33-35" aria-hidden="true" tabindex="-1"></a>                <span class="co">// current root&#39;s left subtree to the left or right subtree, based on off of where we came, to the parent of the current</span></span>
<span id="cb33-36"><a href="#cb33-36" aria-hidden="true" tabindex="-1"></a>                <span class="co">// root / node</span></span>
<span id="cb33-37"><a href="#cb33-37" aria-hidden="true" tabindex="-1"></a>                <span class="cf">return</span> root<span class="op">.</span><span class="fu">left</span><span class="op">;</span></span>
<span id="cb33-38"><a href="#cb33-38" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span> <span class="cf">else</span> <span class="cf">if</span> <span class="op">(</span>root<span class="op">.</span><span class="fu">right</span> <span class="op">!=</span> <span class="kw">null</span> <span class="op">&amp;&amp;</span> root<span class="op">.</span><span class="fu">left</span> <span class="op">==</span> <span class="kw">null</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb33-39"><a href="#cb33-39" aria-hidden="true" tabindex="-1"></a>                <span class="co">// the same as above, but instead, we know that we have only right subtree, therefore we link the right subtree of the</span></span>
<span id="cb33-40"><a href="#cb33-40" aria-hidden="true" tabindex="-1"></a>                <span class="co">// current root, which equals the target value, to the parent of the current root, this will essentially attach the</span></span>
<span id="cb33-41"><a href="#cb33-41" aria-hidden="true" tabindex="-1"></a>                <span class="co">// current root&#39;s right subtree to the right or right subtree, based on off of where we came, to the parent of the</span></span>
<span id="cb33-42"><a href="#cb33-42" aria-hidden="true" tabindex="-1"></a>                <span class="co">// current root / node</span></span>
<span id="cb33-43"><a href="#cb33-43" aria-hidden="true" tabindex="-1"></a>                <span class="cf">return</span> root<span class="op">.</span><span class="fu">right</span><span class="op">;</span></span>
<span id="cb33-44"><a href="#cb33-44" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb33-45"><a href="#cb33-45" aria-hidden="true" tabindex="-1"></a>                <span class="co">// we have both left and right subtrees for the current root for which the value is found to be equal, what we do here,</span></span>
<span id="cb33-46"><a href="#cb33-46" aria-hidden="true" tabindex="-1"></a>                <span class="co">// two options are available, in that scenario, both equal, and either one is fine</span></span>
<span id="cb33-47"><a href="#cb33-47" aria-hidden="true" tabindex="-1"></a>                <span class="co">// - find the min element from the left subtree</span></span>
<span id="cb33-48"><a href="#cb33-48" aria-hidden="true" tabindex="-1"></a>                <span class="co">// - find the max eleemnt from the right subtree</span></span>
<span id="cb33-49"><a href="#cb33-49" aria-hidden="true" tabindex="-1"></a>                <span class="bu">Node</span> curr <span class="op">=</span> root<span class="op">.</span><span class="fu">left</span><span class="op">;</span></span>
<span id="cb33-50"><a href="#cb33-50" aria-hidden="true" tabindex="-1"></a>                <span class="bu">Node</span> prev <span class="op">=</span> root<span class="op">;</span></span>
<span id="cb33-51"><a href="#cb33-51" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-52"><a href="#cb33-52" aria-hidden="true" tabindex="-1"></a>                <span class="co">// we choose to find the max element from the left subtree, that is done by starting off from the root.left, and</span></span>
<span id="cb33-53"><a href="#cb33-53" aria-hidden="true" tabindex="-1"></a>                <span class="co">// drilling down to the right, we can choose the other option find the min element in the right subtree it does not</span></span>
<span id="cb33-54"><a href="#cb33-54" aria-hidden="true" tabindex="-1"></a>                <span class="co">// matter, it has some effect on how we do the checks inside the ifs below though if we go that route, but they are</span></span>
<span id="cb33-55"><a href="#cb33-55" aria-hidden="true" tabindex="-1"></a>                <span class="co">// symmetric</span></span>
<span id="cb33-56"><a href="#cb33-56" aria-hidden="true" tabindex="-1"></a>                <span class="cf">while</span> <span class="op">(</span>curr <span class="op">!=</span> <span class="kw">null</span> <span class="op">&amp;&amp;</span> curr<span class="op">.</span><span class="fu">right</span> <span class="op">!=</span> <span class="kw">null</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb33-57"><a href="#cb33-57" aria-hidden="true" tabindex="-1"></a>                    <span class="co">// prev will always move one step behind curr, and prev.right will always point at curr at any point inside or</span></span>
<span id="cb33-58"><a href="#cb33-58" aria-hidden="true" tabindex="-1"></a>                    <span class="co">// outside this loop, we need to know prev, to detach curr from it, and attach the curr&#39;s children to prev instead</span></span>
<span id="cb33-59"><a href="#cb33-59" aria-hidden="true" tabindex="-1"></a>                    prev <span class="op">=</span> curr<span class="op">;</span></span>
<span id="cb33-60"><a href="#cb33-60" aria-hidden="true" tabindex="-1"></a>                    curr <span class="op">=</span> curr<span class="op">.</span><span class="fu">right</span><span class="op">;</span></span>
<span id="cb33-61"><a href="#cb33-61" aria-hidden="true" tabindex="-1"></a>                <span class="op">}</span></span>
<span id="cb33-62"><a href="#cb33-62" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-63"><a href="#cb33-63" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> <span class="op">(</span>prev <span class="op">==</span> root<span class="op">)</span> <span class="op">{</span></span>
<span id="cb33-64"><a href="#cb33-64" aria-hidden="true" tabindex="-1"></a>                    <span class="co">// we have not moved at all, the while did not loop, meaning that there is no right nodes to the left or root,</span></span>
<span id="cb33-65"><a href="#cb33-65" aria-hidden="true" tabindex="-1"></a>                    <span class="co">// meaning that the prev will point to root, (what it was initially set to), therefore we can safely detach curr</span></span>
<span id="cb33-66"><a href="#cb33-66" aria-hidden="true" tabindex="-1"></a>                    <span class="co">// node, by assigning it&#39;s left subtree to the prev (which still points at root) left subtree, effectively detaching</span></span>
<span id="cb33-67"><a href="#cb33-67" aria-hidden="true" tabindex="-1"></a>                    <span class="co">// it from prev, because root.left == prev.left == curr, so far, no longer after we link root.left == prev.left to</span></span>
<span id="cb33-68"><a href="#cb33-68" aria-hidden="true" tabindex="-1"></a>                    <span class="co">// curr.left</span></span>
<span id="cb33-69"><a href="#cb33-69" aria-hidden="true" tabindex="-1"></a>                    prev<span class="op">.</span><span class="fu">left</span> <span class="op">=</span> curr<span class="op">.</span><span class="fu">left</span><span class="op">;</span></span>
<span id="cb33-70"><a href="#cb33-70" aria-hidden="true" tabindex="-1"></a>                <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb33-71"><a href="#cb33-71" aria-hidden="true" tabindex="-1"></a>                    <span class="co">// we have drilled down to the right, meaning that curr must be the max node, that node can possibly have a left</span></span>
<span id="cb33-72"><a href="#cb33-72" aria-hidden="true" tabindex="-1"></a>                    <span class="co">// subtree (with nodes smaller than it), what we do to detach it ? assign to it&#39;s parent/previous node&#39;s right</span></span>
<span id="cb33-73"><a href="#cb33-73" aria-hidden="true" tabindex="-1"></a>                    <span class="co">// subtree the left subtree of the current&#39;s left subtree (this will detach curr itself, without loosing curr&#39;s</span></span>
<span id="cb33-74"><a href="#cb33-74" aria-hidden="true" tabindex="-1"></a>                    <span class="co">// links to it&#39;s child nodes, because prev.right == curr) if it has any it will be correctly re-linked (but it has</span></span>
<span id="cb33-75"><a href="#cb33-75" aria-hidden="true" tabindex="-1"></a>                    <span class="co">// no right one that is for sure, since we drill down to that condition, see while loop above)</span></span>
<span id="cb33-76"><a href="#cb33-76" aria-hidden="true" tabindex="-1"></a>                    prev<span class="op">.</span><span class="fu">right</span> <span class="op">=</span> curr<span class="op">.</span><span class="fu">left</span><span class="op">;</span></span>
<span id="cb33-77"><a href="#cb33-77" aria-hidden="true" tabindex="-1"></a>                <span class="op">}</span></span>
<span id="cb33-78"><a href="#cb33-78" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-79"><a href="#cb33-79" aria-hidden="true" tabindex="-1"></a>                <span class="co">// copy the value of the curr node over to the root, the curr node will be the one which replaces the root&#39;s value,</span></span>
<span id="cb33-80"><a href="#cb33-80" aria-hidden="true" tabindex="-1"></a>                <span class="co">// since the root&#39;s value is the one we want to delete in the first place, but it had to be replaced with a correct</span></span>
<span id="cb33-81"><a href="#cb33-81" aria-hidden="true" tabindex="-1"></a>                <span class="co">// value computed from it&#39;s children first. The curr.value will maintain the bst property, since we found the max value</span></span>
<span id="cb33-82"><a href="#cb33-82" aria-hidden="true" tabindex="-1"></a>                <span class="co">// from the root.left subtree, and replaced the root.value with it, therefore the property for the subtrees of root, and</span></span>
<span id="cb33-83"><a href="#cb33-83" aria-hidden="true" tabindex="-1"></a>                <span class="co">// their values are maintained</span></span>
<span id="cb33-84"><a href="#cb33-84" aria-hidden="true" tabindex="-1"></a>                root<span class="op">.</span><span class="fu">value</span> <span class="op">=</span> curr<span class="op">.</span><span class="fu">value</span><span class="op">;</span></span>
<span id="cb33-85"><a href="#cb33-85" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb33-86"><a href="#cb33-86" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb33-87"><a href="#cb33-87" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> root<span class="op">;</span></span>
<span id="cb33-88"><a href="#cb33-88" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<h4 id="searching">Searching</h4>
<p>This is in any case a case which is covered in the delete and insert
operations, when inserting the found case means we can not insert in the
tree, in delete operation the found case means we found the node to
delete. In the search case the found case would simply return the node
it had found</p>
<p>Use iterative method, simply because it is simpler to return a value,
from it, in this case we only drill down one single path, without doing
any tree modifications or complex operations.</p>
<div class="sourceCode" id="cb34"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a><span class="bu">Node</span> <span class="fu">search</span><span class="op">(</span><span class="bu">Node</span> root<span class="op">,</span> <span class="bu">Integer</span> value<span class="op">)</span> <span class="op">{</span></span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">// drill down until either a node with a value equaling value is found, or</span></span>
<span id="cb34-3"><a href="#cb34-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">// there is no more nodes to look at, while conforming to the BST rules</span></span>
<span id="cb34-4"><a href="#cb34-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span><span class="op">(</span>root <span class="op">!=</span> <span class="kw">null</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb34-5"><a href="#cb34-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>value <span class="op">&gt;</span> root<span class="op">.</span><span class="fu">value</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb34-6"><a href="#cb34-6" aria-hidden="true" tabindex="-1"></a>            <span class="co">// drill down the left subtree when the value is bigger than the root</span></span>
<span id="cb34-7"><a href="#cb34-7" aria-hidden="true" tabindex="-1"></a>            root <span class="op">=</span> root<span class="op">.</span><span class="fu">left</span><span class="op">;</span></span>
<span id="cb34-8"><a href="#cb34-8" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span> <span class="cf">else</span> <span class="cf">if</span> <span class="op">(</span>value <span class="op">&lt;</span> root<span class="op">.</span><span class="fu">value</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb34-9"><a href="#cb34-9" aria-hidden="true" tabindex="-1"></a>            <span class="co">// drill down the right subtree when the value is smaller than the root</span></span>
<span id="cb34-10"><a href="#cb34-10" aria-hidden="true" tabindex="-1"></a>            root <span class="op">=</span> root<span class="op">.</span><span class="fu">right</span><span class="op">;</span></span>
<span id="cb34-11"><a href="#cb34-11" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb34-12"><a href="#cb34-12" aria-hidden="true" tabindex="-1"></a>            <span class="co">// there was a root node found that equals the target value we search for</span></span>
<span id="cb34-13"><a href="#cb34-13" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> root<span class="op">;</span></span>
<span id="cb34-14"><a href="#cb34-14" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb34-15"><a href="#cb34-15" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb34-16"><a href="#cb34-16" aria-hidden="true" tabindex="-1"></a>    <span class="co">// at this point no node equaling the target value was found, therefore it</span></span>
<span id="cb34-17"><a href="#cb34-17" aria-hidden="true" tabindex="-1"></a>    <span class="co">// was not currently in the tree, if the tree is a complete BST.</span></span>
<span id="cb34-18"><a href="#cb34-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="kw">null</span><span class="op">;</span></span>
<span id="cb34-19"><a href="#cb34-19" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h4 id="balancing">Balancing</h4>
<p>As we know there are ways to make a BST tree imbalanced, when
inserting elements in specific order, that can be malformed into linked
list like structure. A balancing technique we will look at is called
subtree rotation used in AVL trees, which are special type of very well
balanced trees, unlike Red Black trees, AVL trees always have a height
difference at each subtree by no more than 1 level</p>
<p>There are two major rotations that can be done on a branch with a
root, left and right. We do the counter rotation when the tree is heavy
on one side</p>
<ul>
<li>left rotation - when branch is heavy on the right - i.e
left(root)</li>
<li>right rotation - when branch is heavy on the left - i.e
right(root)</li>
</ul>
<p>There are two other ones, which can be done combining the two major
ones, in two separate steps,</p>
<ul>
<li>left-right - combination of the two major rotations, first left,
then right - i.e root.left = left(root.left); right(root)</li>
<li>right-left- combination of the two major rotations, first right,
then left - i.e root.right = right(root.right); left(root)</li>
</ul>
<ol type="1">
<li>Right-Right rotation - we can see that at the level of node 10, the
height of the left subtree is 3, the left one is 1, the balance factor
is 2 == (3 - 1). We rotate around the node 10, in this case, where the
imbalance is found
<ul>
<li>the root will become the node 3 (by reference)</li>
<li>the old right of node 3 becomes the new left of node 10</li>
<li>the new right of node 3 becomes the old root 10 node</li>
</ul></li>
</ol>
<div class="sourceCode" id="cb35"><pre
class="sourceCode txt"><code class="sourceCode default"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a>       10                 3</span>
<span id="cb35-2"><a href="#cb35-2" aria-hidden="true" tabindex="-1"></a>      /  \              /   \</span>
<span id="cb35-3"><a href="#cb35-3" aria-hidden="true" tabindex="-1"></a>     3   15    -&gt;     1      10</span>
<span id="cb35-4"><a href="#cb35-4" aria-hidden="true" tabindex="-1"></a>   /  \              /      /  \</span>
<span id="cb35-5"><a href="#cb35-5" aria-hidden="true" tabindex="-1"></a>  1    4            0      4    15</span>
<span id="cb35-6"><a href="#cb35-6" aria-hidden="true" tabindex="-1"></a> /</span>
<span id="cb35-7"><a href="#cb35-7" aria-hidden="true" tabindex="-1"></a>0</span></code></pre></div>
<ol start="2" type="1">
<li>Left-Left rotation - we can see that at the level of node 10, the
height of the left subtree is 1, the right one is 3, the balance factor
is -2 == (1 - 3). We rotate around the node 10, in this case, where the
imbalance is found
<ul>
<li>the root will become the node 15 (by reference)</li>
<li>the old left of node 15 becomes the new right of node 10</li>
<li>the new left of node 15 becomes the old root 10 node</li>
</ul></li>
</ol>
<div class="sourceCode" id="cb36"><pre
class="sourceCode txt"><code class="sourceCode default"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a>       10                 15</span>
<span id="cb36-2"><a href="#cb36-2" aria-hidden="true" tabindex="-1"></a>      /  \              /   \</span>
<span id="cb36-3"><a href="#cb36-3" aria-hidden="true" tabindex="-1"></a>     3   15    -&gt;     10    20</span>
<span id="cb36-4"><a href="#cb36-4" aria-hidden="true" tabindex="-1"></a>        /   \        /  \     \</span>
<span id="cb36-5"><a href="#cb36-5" aria-hidden="true" tabindex="-1"></a>       13   20      3   13    25</span>
<span id="cb36-6"><a href="#cb36-6" aria-hidden="true" tabindex="-1"></a>             \</span>
<span id="cb36-7"><a href="#cb36-7" aria-hidden="true" tabindex="-1"></a>             25</span></code></pre></div>
<ol start="3" type="1">
<li>Left-right rotation - here we first perform left rotation around
node 3, then around the main node 10, where the actual imbalance is. It
is again 2 == (3 - 1).
<ul>
<li>First a left rotation around the node 3,
<ul>
<li>the root will become the node 4 (by reference)</li>
<li>the old left of node 4 becomes the new right of node 3</li>
<li>the new left of node 4 becomes the old root 3 node</li>
</ul></li>
<li>Second a right rotation around the node 10
<ul>
<li>the root will become the node 4 (by reference)</li>
<li>the old right of node 4 becomes the new left of node 10</li>
<li>the new right of node 4 becomes the old root 10 node</li>
</ul></li>
</ul></li>
</ol>
<div class="sourceCode" id="cb37"><pre
class="sourceCode txt"><code class="sourceCode default"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a>       10                 10                  4</span>
<span id="cb37-2"><a href="#cb37-2" aria-hidden="true" tabindex="-1"></a>      /  \              /   \               /   \</span>
<span id="cb37-3"><a href="#cb37-3" aria-hidden="true" tabindex="-1"></a>     3   15    -&gt;     4      15    -&gt;      3     10</span>
<span id="cb37-4"><a href="#cb37-4" aria-hidden="true" tabindex="-1"></a>   /  \              / \                  /      /  \</span>
<span id="cb37-5"><a href="#cb37-5" aria-hidden="true" tabindex="-1"></a>  1    4            3   5                1      5   15</span>
<span id="cb37-6"><a href="#cb37-6" aria-hidden="true" tabindex="-1"></a>        \         /</span>
<span id="cb37-7"><a href="#cb37-7" aria-hidden="true" tabindex="-1"></a>         5       1</span></code></pre></div>
<ol start="4" type="1">
<li>Right-left rotation - here we first perform right rotation around
node 15, then around the main node 10, where the actual imbalance is. It
is again -2 == (1 - 3)
<ul>
<li>First a right rotation around the node 13
<ul>
<li>the root will become the node 13 (by reference)</li>
<li>the old right of node 13 becomes the new left of node 15</li>
<li>the new right of node 13 becomes the old root 15 node</li>
</ul></li>
<li>Second a left rotation around the node 10
<ul>
<li>the root will become the node 13 (by reference)</li>
<li>the old left of node 13 becomes the new right of node 10</li>
<li>the new left of node 13 becomes the old root 10 node</li>
</ul></li>
</ul></li>
</ol>
<div class="sourceCode" id="cb38"><pre
class="sourceCode txt"><code class="sourceCode default"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a>      10               10                  13</span>
<span id="cb38-2"><a href="#cb38-2" aria-hidden="true" tabindex="-1"></a>    /   \             /  \                /  \</span>
<span id="cb38-3"><a href="#cb38-3" aria-hidden="true" tabindex="-1"></a>   3    15    -&gt;     3   13      -&gt;      10   15</span>
<span id="cb38-4"><a href="#cb38-4" aria-hidden="true" tabindex="-1"></a>       /  \             /  \            /  \   \</span>
<span id="cb38-5"><a href="#cb38-5" aria-hidden="true" tabindex="-1"></a>      13  20           11  15          3   11  20</span>
<span id="cb38-6"><a href="#cb38-6" aria-hidden="true" tabindex="-1"></a>     /                       \</span>
<span id="cb38-7"><a href="#cb38-7" aria-hidden="true" tabindex="-1"></a>    11                       20</span></code></pre></div>
<p>Below is represented the general interface used to balance a tree, we
have the rotations, and the height method, along with the balance
calculation and the re-balance action itself.</p>
<div class="sourceCode" id="cb39"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> <span class="fu">height</span><span class="op">(</span><span class="bu">Node</span> root<span class="op">)</span> <span class="op">{</span></span>
<span id="cb39-2"><a href="#cb39-2" aria-hidden="true" tabindex="-1"></a>        <span class="co">// height is 0 if the node does not exist</span></span>
<span id="cb39-3"><a href="#cb39-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>root <span class="op">==</span> <span class="kw">null</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb39-4"><a href="#cb39-4" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb39-5"><a href="#cb39-5" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb39-6"><a href="#cb39-6" aria-hidden="true" tabindex="-1"></a>        <span class="co">// return the stored height, for the node</span></span>
<span id="cb39-7"><a href="#cb39-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> root<span class="op">.</span><span class="fu">height</span><span class="op">;</span></span>
<span id="cb39-8"><a href="#cb39-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb39-9"><a href="#cb39-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-10"><a href="#cb39-10" aria-hidden="true" tabindex="-1"></a>    <span class="bu">Node</span> <span class="fu">right</span><span class="op">(</span><span class="bu">Node</span> root<span class="op">)</span> <span class="op">{</span></span>
<span id="cb39-11"><a href="#cb39-11" aria-hidden="true" tabindex="-1"></a>        <span class="co">// right rotation is done to offset left heavy tree branches, right rotation means that left subtree would &quot;move&quot; or &quot;shift&quot; to</span></span>
<span id="cb39-12"><a href="#cb39-12" aria-hidden="true" tabindex="-1"></a>        <span class="co">// the right, or in other words the root.left would become the new root, and the old root would become the right, of the new</span></span>
<span id="cb39-13"><a href="#cb39-13" aria-hidden="true" tabindex="-1"></a>        <span class="co">// root. This way the subtrees of the new node would be balanced</span></span>
<span id="cb39-14"><a href="#cb39-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-15"><a href="#cb39-15" aria-hidden="true" tabindex="-1"></a>        <span class="co">// remember the left node, it will become our new root at the end of the function the new root is returned</span></span>
<span id="cb39-16"><a href="#cb39-16" aria-hidden="true" tabindex="-1"></a>        <span class="bu">Node</span> left <span class="op">=</span> root<span class="op">.</span><span class="fu">left</span><span class="op">;</span></span>
<span id="cb39-17"><a href="#cb39-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-18"><a href="#cb39-18" aria-hidden="true" tabindex="-1"></a>        <span class="co">// the left of the current root would become the right subtree of the new root i.e left.right node</span></span>
<span id="cb39-19"><a href="#cb39-19" aria-hidden="true" tabindex="-1"></a>        root<span class="op">.</span><span class="fu">left</span> <span class="op">=</span> left<span class="op">.</span><span class="fu">right</span><span class="op">;</span></span>
<span id="cb39-20"><a href="#cb39-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-21"><a href="#cb39-21" aria-hidden="true" tabindex="-1"></a>        <span class="co">// the new root&#39;s right subtree now is assigned the old root</span></span>
<span id="cb39-22"><a href="#cb39-22" aria-hidden="true" tabindex="-1"></a>        left<span class="op">.</span><span class="fu">right</span> <span class="op">=</span> root<span class="op">;</span></span>
<span id="cb39-23"><a href="#cb39-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-24"><a href="#cb39-24" aria-hidden="true" tabindex="-1"></a>        <span class="co">// since root&#39;s subtrees were modified above, left was assigned a new subtree, calculate the height again</span></span>
<span id="cb39-25"><a href="#cb39-25" aria-hidden="true" tabindex="-1"></a>        root<span class="op">.</span><span class="fu">height</span> <span class="op">=</span> <span class="dv">1</span> <span class="op">+</span> <span class="bu">Math</span><span class="op">.</span><span class="fu">max</span><span class="op">(</span><span class="fu">height</span><span class="op">(</span>root<span class="op">.</span><span class="fu">right</span><span class="op">),</span> <span class="fu">height</span><span class="op">(</span>root<span class="op">.</span><span class="fu">left</span><span class="op">));</span></span>
<span id="cb39-26"><a href="#cb39-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-27"><a href="#cb39-27" aria-hidden="true" tabindex="-1"></a>        <span class="co">// since left&#39;s subtrees were modified above, right was assigned a new subtree, calculate the height again</span></span>
<span id="cb39-28"><a href="#cb39-28" aria-hidden="true" tabindex="-1"></a>        left<span class="op">.</span><span class="fu">height</span> <span class="op">=</span> <span class="dv">1</span> <span class="op">+</span> <span class="bu">Math</span><span class="op">.</span><span class="fu">max</span><span class="op">(</span><span class="fu">height</span><span class="op">(</span>left<span class="op">.</span><span class="fu">right</span><span class="op">),</span> <span class="fu">height</span><span class="op">(</span>left<span class="op">.</span><span class="fu">left</span><span class="op">));</span></span>
<span id="cb39-29"><a href="#cb39-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-30"><a href="#cb39-30" aria-hidden="true" tabindex="-1"></a>        <span class="co">// this is the new root, after the rotation was done, i.e the old .left subtree of root</span></span>
<span id="cb39-31"><a href="#cb39-31" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> left<span class="op">;</span></span>
<span id="cb39-32"><a href="#cb39-32" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb39-33"><a href="#cb39-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-34"><a href="#cb39-34" aria-hidden="true" tabindex="-1"></a>    <span class="bu">Node</span> <span class="fu">left</span><span class="op">(</span><span class="bu">Node</span> root<span class="op">)</span> <span class="op">{</span></span>
<span id="cb39-35"><a href="#cb39-35" aria-hidden="true" tabindex="-1"></a>        <span class="co">// left rotation is done to offset right heavy tree branches, left rotation means that right subtree would &quot;move&quot; or &quot;shift&quot; to</span></span>
<span id="cb39-36"><a href="#cb39-36" aria-hidden="true" tabindex="-1"></a>        <span class="co">// the left, or in other words the root.right would become the new root, and the old root would become the left of the new</span></span>
<span id="cb39-37"><a href="#cb39-37" aria-hidden="true" tabindex="-1"></a>        <span class="co">// root. This way the subtrees of the new node would be balanced</span></span>
<span id="cb39-38"><a href="#cb39-38" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-39"><a href="#cb39-39" aria-hidden="true" tabindex="-1"></a>        <span class="co">// remember the right node, it will become our new root at the end of the function the new root is returned</span></span>
<span id="cb39-40"><a href="#cb39-40" aria-hidden="true" tabindex="-1"></a>        <span class="bu">Node</span> right <span class="op">=</span> root<span class="op">.</span><span class="fu">right</span><span class="op">;</span></span>
<span id="cb39-41"><a href="#cb39-41" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-42"><a href="#cb39-42" aria-hidden="true" tabindex="-1"></a>        <span class="co">// the right of the current root would become the left subtree of the new root i.e right.left node</span></span>
<span id="cb39-43"><a href="#cb39-43" aria-hidden="true" tabindex="-1"></a>        root<span class="op">.</span><span class="fu">right</span> <span class="op">=</span> right<span class="op">.</span><span class="fu">left</span><span class="op">;</span></span>
<span id="cb39-44"><a href="#cb39-44" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-45"><a href="#cb39-45" aria-hidden="true" tabindex="-1"></a>        <span class="co">// the new root&#39;s left subtree now is assigned the old root</span></span>
<span id="cb39-46"><a href="#cb39-46" aria-hidden="true" tabindex="-1"></a>        right<span class="op">.</span><span class="fu">left</span> <span class="op">=</span> root<span class="op">;</span></span>
<span id="cb39-47"><a href="#cb39-47" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-48"><a href="#cb39-48" aria-hidden="true" tabindex="-1"></a>        <span class="co">// since root&#39;s subtrees were modified above, right was assigned a new subtree, calculate the height again</span></span>
<span id="cb39-49"><a href="#cb39-49" aria-hidden="true" tabindex="-1"></a>        root<span class="op">.</span><span class="fu">height</span> <span class="op">=</span> <span class="dv">1</span> <span class="op">+</span> <span class="bu">Math</span><span class="op">.</span><span class="fu">max</span><span class="op">(</span><span class="fu">height</span><span class="op">(</span>root<span class="op">.</span><span class="fu">right</span><span class="op">),</span> <span class="fu">height</span><span class="op">(</span>root<span class="op">.</span><span class="fu">left</span><span class="op">));</span></span>
<span id="cb39-50"><a href="#cb39-50" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-51"><a href="#cb39-51" aria-hidden="true" tabindex="-1"></a>        <span class="co">// since right&#39;s subtrees were modified above, left was assigned a new subtree, calculate the height again</span></span>
<span id="cb39-52"><a href="#cb39-52" aria-hidden="true" tabindex="-1"></a>        right<span class="op">.</span><span class="fu">height</span> <span class="op">=</span> <span class="dv">1</span> <span class="op">+</span> <span class="bu">Math</span><span class="op">.</span><span class="fu">max</span><span class="op">(</span><span class="fu">height</span><span class="op">(</span>right<span class="op">.</span><span class="fu">right</span><span class="op">),</span> <span class="fu">height</span><span class="op">(</span>right<span class="op">.</span><span class="fu">left</span><span class="op">));</span></span>
<span id="cb39-53"><a href="#cb39-53" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-54"><a href="#cb39-54" aria-hidden="true" tabindex="-1"></a>        <span class="co">// this is the new root, after the rotation was done, i.e the old .right subtree of root</span></span>
<span id="cb39-55"><a href="#cb39-55" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> right<span class="op">;</span></span>
<span id="cb39-56"><a href="#cb39-56" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<div class="sourceCode" id="cb40"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> <span class="fu">balance</span><span class="op">(</span><span class="bu">Node</span> right<span class="op">,</span> <span class="bu">Node</span> left<span class="op">)</span> <span class="op">{</span></span>
<span id="cb40-2"><a href="#cb40-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">// the balance calculated as signed integer from left to right, when a tree is imbalanced, it would tend to malform into a</span></span>
<span id="cb40-3"><a href="#cb40-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">// structure very similar to a linked list, it is quite obvious when either the left or right subtrees have a chain of links,</span></span>
<span id="cb40-4"><a href="#cb40-4" aria-hidden="true" tabindex="-1"></a>    <span class="co">// - node-&gt;left-&gt;left-&gt;left....etc, with no right links, along the path, left heavy, positive balance value</span></span>
<span id="cb40-5"><a href="#cb40-5" aria-hidden="true" tabindex="-1"></a>    <span class="co">// - node-&gt;right-&gt;right-&gt;right..etc, with no left links, along the path, right heavy, negative balance value</span></span>
<span id="cb40-6"><a href="#cb40-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="fu">height</span><span class="op">(</span>left<span class="op">)</span> <span class="op">-</span> <span class="fu">height</span><span class="op">(</span>right<span class="op">);</span></span>
<span id="cb40-7"><a href="#cb40-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<div class="sourceCode" id="cb41"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb41-1"><a href="#cb41-1" aria-hidden="true" tabindex="-1"></a>    <span class="bu">Node</span> <span class="fu">rebalance</span><span class="op">(</span><span class="bu">Node</span> root<span class="op">,</span> T value<span class="op">)</span> <span class="op">{</span></span>
<span id="cb41-2"><a href="#cb41-2" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>root <span class="op">==</span> <span class="kw">null</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb41-3"><a href="#cb41-3" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> root<span class="op">;</span></span>
<span id="cb41-4"><a href="#cb41-4" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb41-5"><a href="#cb41-5" aria-hidden="true" tabindex="-1"></a>        <span class="co">// first make sure the current height is up to date, if re-balance was called, caller must expect that the height of the root</span></span>
<span id="cb41-6"><a href="#cb41-6" aria-hidden="true" tabindex="-1"></a>        <span class="co">// might have changed, during a tree action, insert or delete</span></span>
<span id="cb41-7"><a href="#cb41-7" aria-hidden="true" tabindex="-1"></a>        root<span class="op">.</span><span class="fu">height</span> <span class="op">=</span> <span class="dv">1</span> <span class="op">+</span> <span class="bu">Math</span><span class="op">.</span><span class="fu">max</span><span class="op">(</span><span class="fu">height</span><span class="op">(</span>root<span class="op">.</span><span class="fu">right</span><span class="op">),</span> <span class="fu">height</span><span class="op">(</span>root<span class="op">.</span><span class="fu">left</span><span class="op">));</span></span>
<span id="cb41-8"><a href="#cb41-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-9"><a href="#cb41-9" aria-hidden="true" tabindex="-1"></a>        <span class="co">// after the update of the height we check what is the current balance, between the current level&#39;s subtrees, for the current</span></span>
<span id="cb41-10"><a href="#cb41-10" aria-hidden="true" tabindex="-1"></a>        <span class="co">// level, i.e if the balance value is abs(balance) &gt; 1, the tree needs to be rebalanced around the current root / level</span></span>
<span id="cb41-11"><a href="#cb41-11" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> balance <span class="op">=</span> <span class="fu">balance</span><span class="op">(</span>root<span class="op">.</span><span class="fu">right</span><span class="op">,</span> root<span class="op">.</span><span class="fu">left</span><span class="op">);</span></span>
<span id="cb41-12"><a href="#cb41-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-13"><a href="#cb41-13" aria-hidden="true" tabindex="-1"></a>        <span class="co">// check if there is imbalance in the tree, it must be a value strictly greater, (not equal or greater) than one, does not</span></span>
<span id="cb41-14"><a href="#cb41-14" aria-hidden="true" tabindex="-1"></a>        <span class="co">// matter which subtree (left or right) is heavier. This post recursive action will find the very first level in the tree which</span></span>
<span id="cb41-15"><a href="#cb41-15" aria-hidden="true" tabindex="-1"></a>        <span class="co">// is imbalanced, from bottom to top.</span></span>
<span id="cb41-16"><a href="#cb41-16" aria-hidden="true" tabindex="-1"></a>        <span class="co">// - balance will be positive if the left side is heavier than the right</span></span>
<span id="cb41-17"><a href="#cb41-17" aria-hidden="true" tabindex="-1"></a>        <span class="co">// - balance will be negative if the right side is heavier than the left</span></span>
<span id="cb41-18"><a href="#cb41-18" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>balance <span class="op">&gt;</span> <span class="dv">1</span> <span class="op">||</span> balance <span class="op">&lt;</span> <span class="op">-</span><span class="dv">1</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb41-19"><a href="#cb41-19" aria-hidden="true" tabindex="-1"></a>            <span class="co">// the checks blelow are very neat and cool, why ?, well having the value to insert and the property of the binary search</span></span>
<span id="cb41-20"><a href="#cb41-20" aria-hidden="true" tabindex="-1"></a>            <span class="co">// tree, we can know in which direction the new node was inserted, combined with the sign of the balance we can tell in</span></span>
<span id="cb41-21"><a href="#cb41-21" aria-hidden="true" tabindex="-1"></a>            <span class="co">// which direction the new node imbalanced the tree, i.e which subtree became more heavy / imbalanced, this helps us to find</span></span>
<span id="cb41-22"><a href="#cb41-22" aria-hidden="true" tabindex="-1"></a>            <span class="co">// which of the 4 rotations have to be applied around the current root</span></span>
<span id="cb41-23"><a href="#cb41-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-24"><a href="#cb41-24" aria-hidden="true" tabindex="-1"></a>            <span class="co">// left heavy &amp;&amp; value &lt; root.left.value - left-left</span></span>
<span id="cb41-25"><a href="#cb41-25" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>balance <span class="op">&gt;</span> <span class="dv">1</span> <span class="op">&amp;&amp;</span> value <span class="op">&lt;</span> root<span class="op">.</span><span class="fu">left</span><span class="op">.</span><span class="fu">value</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb41-26"><a href="#cb41-26" aria-hidden="true" tabindex="-1"></a>                <span class="co">// first start off from the balance value, if it is positive, then the imbalance is in root.left, then we check if the</span></span>
<span id="cb41-27"><a href="#cb41-27" aria-hidden="true" tabindex="-1"></a>                <span class="co">// inserted value is smaller than the left node&#39;s value, if yes, then the new node was inserted to the left of the left</span></span>
<span id="cb41-28"><a href="#cb41-28" aria-hidden="true" tabindex="-1"></a>                <span class="co">// subtree. meaning the tree is left-left heavy, therefore we do the (opposite rotation) right rotation</span></span>
<span id="cb41-29"><a href="#cb41-29" aria-hidden="true" tabindex="-1"></a>                <span class="cf">return</span> <span class="fu">right</span><span class="op">(</span>root<span class="op">);</span></span>
<span id="cb41-30"><a href="#cb41-30" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb41-31"><a href="#cb41-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-32"><a href="#cb41-32" aria-hidden="true" tabindex="-1"></a>            <span class="co">// right heavy &amp;&amp; value &gt; root.right.value - right-right</span></span>
<span id="cb41-33"><a href="#cb41-33" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>balance <span class="op">&lt;</span> <span class="op">-</span><span class="dv">1</span> <span class="op">&amp;&amp;</span> value <span class="op">&gt;</span> root<span class="op">.</span><span class="fu">right</span><span class="op">.</span><span class="fu">value</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb41-34"><a href="#cb41-34" aria-hidden="true" tabindex="-1"></a>                <span class="co">// first start off from the balance value, if it is negative, then the imbalance is in root.right, then we check if the</span></span>
<span id="cb41-35"><a href="#cb41-35" aria-hidden="true" tabindex="-1"></a>                <span class="co">// inserted value is bigger than the right node&#39;s value, if yes, then the new node was inserted to the right of the</span></span>
<span id="cb41-36"><a href="#cb41-36" aria-hidden="true" tabindex="-1"></a>                <span class="co">// right subtree. meaning the tree is right-right heavy, therefore we do the (opposite rotation) left rotation</span></span>
<span id="cb41-37"><a href="#cb41-37" aria-hidden="true" tabindex="-1"></a>                <span class="cf">return</span> <span class="fu">left</span><span class="op">(</span>root<span class="op">);</span></span>
<span id="cb41-38"><a href="#cb41-38" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb41-39"><a href="#cb41-39" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-40"><a href="#cb41-40" aria-hidden="true" tabindex="-1"></a>            <span class="co">// left heavy &amp;&amp; value &gt; root.left.value - left-right</span></span>
<span id="cb41-41"><a href="#cb41-41" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>balance <span class="op">&gt;</span> <span class="dv">1</span> <span class="op">&amp;&amp;</span> value <span class="op">&gt;</span> root<span class="op">.</span><span class="fu">left</span><span class="op">.</span><span class="fu">value</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb41-42"><a href="#cb41-42" aria-hidden="true" tabindex="-1"></a>                <span class="co">// first start off from the balance value, if it is positive, then the imbalance is in root.left, then we check if the</span></span>
<span id="cb41-43"><a href="#cb41-43" aria-hidden="true" tabindex="-1"></a>                <span class="co">// inserted value is bigger than the left node&#39;s value, if yes, then the new node was inserted to the right of the left</span></span>
<span id="cb41-44"><a href="#cb41-44" aria-hidden="true" tabindex="-1"></a>                <span class="co">// subtree. meaning the tree is left-right heavy, therefore first we left rotate, which will morph root.left case into a</span></span>
<span id="cb41-45"><a href="#cb41-45" aria-hidden="true" tabindex="-1"></a>                <span class="co">// left-left, after than we do a right rotate (same as left-left case above)</span></span>
<span id="cb41-46"><a href="#cb41-46" aria-hidden="true" tabindex="-1"></a>                root<span class="op">.</span><span class="fu">left</span> <span class="op">=</span> <span class="fu">left</span><span class="op">(</span>root<span class="op">.</span><span class="fu">left</span><span class="op">);</span></span>
<span id="cb41-47"><a href="#cb41-47" aria-hidden="true" tabindex="-1"></a>                <span class="cf">return</span> <span class="fu">right</span><span class="op">(</span>root<span class="op">);</span></span>
<span id="cb41-48"><a href="#cb41-48" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb41-49"><a href="#cb41-49" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-50"><a href="#cb41-50" aria-hidden="true" tabindex="-1"></a>            <span class="co">// right heavy &amp;&amp; value &lt; root.right.value - right-left</span></span>
<span id="cb41-51"><a href="#cb41-51" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>balance <span class="op">&lt;</span> <span class="op">-</span><span class="dv">1</span> <span class="op">&amp;&amp;</span> value <span class="op">&lt;</span> root<span class="op">.</span><span class="fu">right</span><span class="op">.</span><span class="fu">value</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb41-52"><a href="#cb41-52" aria-hidden="true" tabindex="-1"></a>                <span class="co">// first start off from the balance value, if it is negative, then the imbalance is in root.right, then we check if the</span></span>
<span id="cb41-53"><a href="#cb41-53" aria-hidden="true" tabindex="-1"></a>                <span class="co">// inserted value is smaller than the right node&#39;s value, if yes, then the new node was inserted to the left of the</span></span>
<span id="cb41-54"><a href="#cb41-54" aria-hidden="true" tabindex="-1"></a>                <span class="co">// right subtree. meaning the tree is right-left heavy, therefore first we right rotate, which will morph root.right</span></span>
<span id="cb41-55"><a href="#cb41-55" aria-hidden="true" tabindex="-1"></a>                <span class="co">// case into a right-right, after than we do a left rotate (same as right-right case above)</span></span>
<span id="cb41-56"><a href="#cb41-56" aria-hidden="true" tabindex="-1"></a>                root<span class="op">.</span><span class="fu">right</span> <span class="op">=</span> <span class="fu">right</span><span class="op">(</span>root<span class="op">.</span><span class="fu">right</span><span class="op">);</span></span>
<span id="cb41-57"><a href="#cb41-57" aria-hidden="true" tabindex="-1"></a>                <span class="cf">return</span> <span class="fu">left</span><span class="op">(</span>root<span class="op">);</span></span>
<span id="cb41-58"><a href="#cb41-58" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb41-59"><a href="#cb41-59" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb41-60"><a href="#cb41-60" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> root<span class="op">;</span></span>
<span id="cb41-61"><a href="#cb41-61" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<p>Insertion and deletion also need slight modification to include the
re balancing of the tree after the operation, all parents up to the
root, have to be visited, and update their heights at the very least,
also check for imbalance</p>
<div class="sourceCode" id="cb42"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb42-1"><a href="#cb42-1" aria-hidden="true" tabindex="-1"></a>    <span class="bu">Node</span> <span class="fu">insert</span><span class="op">(</span><span class="bu">Node</span> root<span class="op">,</span> <span class="dt">int</span> value<span class="op">)</span> <span class="op">{</span></span>
<span id="cb42-2"><a href="#cb42-2" aria-hidden="true" tabindex="-1"></a>        <span class="co">// generic insert logic for bst</span></span>
<span id="cb42-3"><a href="#cb42-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>root <span class="op">==</span> <span class="kw">null</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb42-4"><a href="#cb42-4" aria-hidden="true" tabindex="-1"></a>            <span class="bu">Node</span> node <span class="op">=</span> <span class="kw">new</span> <span class="bu">Node</span><span class="op">();</span></span>
<span id="cb42-5"><a href="#cb42-5" aria-hidden="true" tabindex="-1"></a>            node<span class="op">.</span><span class="fu">value</span> <span class="op">=</span> value<span class="op">;</span></span>
<span id="cb42-6"><a href="#cb42-6" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> node<span class="op">;</span></span>
<span id="cb42-7"><a href="#cb42-7" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb42-8"><a href="#cb42-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-9"><a href="#cb42-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>value <span class="op">&gt;</span> root<span class="op">.</span><span class="fu">value</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb42-10"><a href="#cb42-10" aria-hidden="true" tabindex="-1"></a>            root<span class="op">.</span><span class="fu">right</span> <span class="op">=</span> <span class="fu">insert</span><span class="op">(</span>root<span class="op">.</span><span class="fu">right</span><span class="op">,</span> value<span class="op">);</span></span>
<span id="cb42-11"><a href="#cb42-11" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span> <span class="cf">else</span> <span class="cf">if</span> <span class="op">(</span>value <span class="op">&lt;</span> root<span class="op">.</span><span class="fu">value</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb42-12"><a href="#cb42-12" aria-hidden="true" tabindex="-1"></a>            root<span class="op">.</span><span class="fu">left</span> <span class="op">=</span> <span class="fu">insert</span><span class="op">(</span>root<span class="op">.</span><span class="fu">left</span><span class="op">,</span> value<span class="op">);</span></span>
<span id="cb42-13"><a href="#cb42-13" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb42-14"><a href="#cb42-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-15"><a href="#cb42-15" aria-hidden="true" tabindex="-1"></a>        <span class="co">// reaching at this point, we have very likely inserted an element, therefore we need to re-balance the tree, the return of</span></span>
<span id="cb42-16"><a href="#cb42-16" aria-hidden="true" tabindex="-1"></a>        <span class="co">// re-balance might be the same root, if no re-balance is required, or one of it&#39;s left or right children depending on what</span></span>
<span id="cb42-17"><a href="#cb42-17" aria-hidden="true" tabindex="-1"></a>        <span class="co">// rotation was done during balancing</span></span>
<span id="cb42-18"><a href="#cb42-18" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="fu">rebalance</span><span class="op">(</span>root<span class="op">,</span> value<span class="op">);</span></span>
<span id="cb42-19"><a href="#cb42-19" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<div class="sourceCode" id="cb43"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb43-1"><a href="#cb43-1" aria-hidden="true" tabindex="-1"></a>    <span class="bu">Node</span> <span class="fu">delete</span><span class="op">(</span><span class="bu">Node</span> root<span class="op">,</span> T value<span class="op">)</span> <span class="op">{</span></span>
<span id="cb43-2"><a href="#cb43-2" aria-hidden="true" tabindex="-1"></a>        <span class="co">// generic delete and logic for bst</span></span>
<span id="cb43-3"><a href="#cb43-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>root <span class="op">==</span> <span class="kw">null</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb43-4"><a href="#cb43-4" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="kw">null</span><span class="op">;</span></span>
<span id="cb43-5"><a href="#cb43-5" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb43-6"><a href="#cb43-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-7"><a href="#cb43-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>value <span class="op">&gt;</span> root<span class="op">.</span><span class="fu">value</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb43-8"><a href="#cb43-8" aria-hidden="true" tabindex="-1"></a>            root<span class="op">.</span><span class="fu">right</span> <span class="op">=</span> <span class="fu">delete</span><span class="op">(</span>root<span class="op">.</span><span class="fu">right</span><span class="op">,</span> value<span class="op">);</span></span>
<span id="cb43-9"><a href="#cb43-9" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span> <span class="cf">else</span> <span class="cf">if</span> <span class="op">(</span>value <span class="op">&lt;</span> root<span class="op">.</span><span class="fu">value</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb43-10"><a href="#cb43-10" aria-hidden="true" tabindex="-1"></a>            root<span class="op">.</span><span class="fu">left</span> <span class="op">=</span> <span class="fu">delete</span><span class="op">(</span>root<span class="op">.</span><span class="fu">left</span><span class="op">,</span> value<span class="op">);</span></span>
<span id="cb43-11"><a href="#cb43-11" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb43-12"><a href="#cb43-12" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>root<span class="op">.</span><span class="fu">left</span> <span class="op">==</span> <span class="kw">null</span> <span class="op">&amp;&amp;</span> root<span class="op">.</span><span class="fu">right</span> <span class="op">==</span> <span class="kw">null</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb43-13"><a href="#cb43-13" aria-hidden="true" tabindex="-1"></a>                root <span class="op">=</span> <span class="kw">null</span><span class="op">;</span></span>
<span id="cb43-14"><a href="#cb43-14" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span> <span class="cf">else</span> <span class="cf">if</span> <span class="op">(</span>root<span class="op">.</span><span class="fu">left</span> <span class="op">!=</span> <span class="kw">null</span> <span class="op">&amp;&amp;</span> root<span class="op">.</span><span class="fu">right</span> <span class="op">==</span> <span class="kw">null</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb43-15"><a href="#cb43-15" aria-hidden="true" tabindex="-1"></a>                root <span class="op">=</span> root<span class="op">.</span><span class="fu">left</span><span class="op">;</span></span>
<span id="cb43-16"><a href="#cb43-16" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span> <span class="cf">else</span> <span class="cf">if</span> <span class="op">(</span>root<span class="op">.</span><span class="fu">right</span> <span class="op">!=</span> <span class="kw">null</span> <span class="op">&amp;&amp;</span> root<span class="op">.</span><span class="fu">left</span> <span class="op">==</span> <span class="kw">null</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb43-17"><a href="#cb43-17" aria-hidden="true" tabindex="-1"></a>                root <span class="op">=</span> root<span class="op">.</span><span class="fu">right</span><span class="op">;</span></span>
<span id="cb43-18"><a href="#cb43-18" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb43-19"><a href="#cb43-19" aria-hidden="true" tabindex="-1"></a>                <span class="bu">Node</span> curr <span class="op">=</span> root<span class="op">.</span><span class="fu">left</span><span class="op">;</span></span>
<span id="cb43-20"><a href="#cb43-20" aria-hidden="true" tabindex="-1"></a>                <span class="bu">Node</span> prev <span class="op">=</span> root<span class="op">;</span></span>
<span id="cb43-21"><a href="#cb43-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-22"><a href="#cb43-22" aria-hidden="true" tabindex="-1"></a>                <span class="cf">while</span> <span class="op">(</span>curr <span class="op">!=</span> <span class="kw">null</span> <span class="op">&amp;&amp;</span> curr<span class="op">.</span><span class="fu">right</span> <span class="op">!=</span> <span class="kw">null</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb43-23"><a href="#cb43-23" aria-hidden="true" tabindex="-1"></a>                    prev <span class="op">=</span> curr<span class="op">;</span></span>
<span id="cb43-24"><a href="#cb43-24" aria-hidden="true" tabindex="-1"></a>                    curr <span class="op">=</span> curr<span class="op">.</span><span class="fu">right</span><span class="op">;</span></span>
<span id="cb43-25"><a href="#cb43-25" aria-hidden="true" tabindex="-1"></a>                <span class="op">}</span></span>
<span id="cb43-26"><a href="#cb43-26" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> <span class="op">(</span>prev <span class="op">==</span> root<span class="op">)</span> <span class="op">{</span></span>
<span id="cb43-27"><a href="#cb43-27" aria-hidden="true" tabindex="-1"></a>                    prev<span class="op">.</span><span class="fu">left</span> <span class="op">=</span> curr<span class="op">.</span><span class="fu">left</span><span class="op">;</span></span>
<span id="cb43-28"><a href="#cb43-28" aria-hidden="true" tabindex="-1"></a>                <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb43-29"><a href="#cb43-29" aria-hidden="true" tabindex="-1"></a>                    prev<span class="op">.</span><span class="fu">right</span> <span class="op">=</span> curr<span class="op">.</span><span class="fu">left</span><span class="op">;</span></span>
<span id="cb43-30"><a href="#cb43-30" aria-hidden="true" tabindex="-1"></a>                <span class="op">}</span></span>
<span id="cb43-31"><a href="#cb43-31" aria-hidden="true" tabindex="-1"></a>                root<span class="op">.</span><span class="fu">value</span> <span class="op">=</span> curr<span class="op">.</span><span class="fu">value</span><span class="op">;</span></span>
<span id="cb43-32"><a href="#cb43-32" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb43-33"><a href="#cb43-33" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb43-34"><a href="#cb43-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-35"><a href="#cb43-35" aria-hidden="true" tabindex="-1"></a>        <span class="co">// try to check if re-balance is required, all the way, to the root, this is outside the else, because we have to post recurse, to</span></span>
<span id="cb43-36"><a href="#cb43-36" aria-hidden="true" tabindex="-1"></a>        <span class="co">// the root, to at the very least update the heights of each parent along the way, if a deletion has occurred, and also check if</span></span>
<span id="cb43-37"><a href="#cb43-37" aria-hidden="true" tabindex="-1"></a>        <span class="co">// the balance is okay.</span></span>
<span id="cb43-38"><a href="#cb43-38" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="fu">rebalance</span><span class="op">(</span>root<span class="op">,</span> value<span class="op">);</span></span>
<span id="cb43-39"><a href="#cb43-39" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<h3 id="binary-heaps">Binary heaps</h3>
<p>Binary heap tree can be one of two types, a max or a min binary heap
tree. Those are special types of binary trees, where the structure of
the tree is such that the Min or the Max element in the tree is always
at the top, and all elements below it are strictly smaller (max) or
bigger (min) heap tree type.</p>
<p>They are usually represent in a dynamic array, but can be done in the
usual left/right pointer style nodes, that regular trees use. The reason
to use a standard array is due to the operations such as insert and
delete, which usually start off from the last element in the tree, and
in arrays we have a very fast way to find, which one is the last element
i.e. simply <code>array[array.len - 1]</code></p>
<p>A Min heap might look like this.</p>
<div class="sourceCode" id="cb44"><pre
class="sourceCode txt"><code class="sourceCode default"><span id="cb44-1"><a href="#cb44-1" aria-hidden="true" tabindex="-1"></a>         10</span>
<span id="cb44-2"><a href="#cb44-2" aria-hidden="true" tabindex="-1"></a>        /  \</span>
<span id="cb44-3"><a href="#cb44-3" aria-hidden="true" tabindex="-1"></a>      15   20</span>
<span id="cb44-4"><a href="#cb44-4" aria-hidden="true" tabindex="-1"></a>     /  \</span>
<span id="cb44-5"><a href="#cb44-5" aria-hidden="true" tabindex="-1"></a>    33  17</span></code></pre></div>
<p>A Max heap might look like this.</p>
<div class="sourceCode" id="cb45"><pre
class="sourceCode txt"><code class="sourceCode default"><span id="cb45-1"><a href="#cb45-1" aria-hidden="true" tabindex="-1"></a>         10</span>
<span id="cb45-2"><a href="#cb45-2" aria-hidden="true" tabindex="-1"></a>        /  \</span>
<span id="cb45-3"><a href="#cb45-3" aria-hidden="true" tabindex="-1"></a>       5    2</span>
<span id="cb45-4"><a href="#cb45-4" aria-hidden="true" tabindex="-1"></a>     /  \</span>
<span id="cb45-5"><a href="#cb45-5" aria-hidden="true" tabindex="-1"></a>    3    1</span></code></pre></div>
<div class="sourceCode" id="cb46"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb46-1"><a href="#cb46-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">// the type of the heap as simple enum, heap type can not change during heap</span></span>
<span id="cb46-2"><a href="#cb46-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">// operations, it remains constant for the lifetime of the heap</span></span>
<span id="cb46-3"><a href="#cb46-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="kw">enum</span> HeapType <span class="op">{</span></span>
<span id="cb46-4"><a href="#cb46-4" aria-hidden="true" tabindex="-1"></a>        MIN<span class="op">,</span> MAX</span>
<span id="cb46-5"><a href="#cb46-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb46-6"><a href="#cb46-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb46-7"><a href="#cb46-7" aria-hidden="true" tabindex="-1"></a>    <span class="co">// sample heap representation as a dynamic array, due to fast insert and</span></span>
<span id="cb46-8"><a href="#cb46-8" aria-hidden="true" tabindex="-1"></a>    <span class="co">// look up operations at desired indices, i.e. for child / parent elements</span></span>
<span id="cb46-9"><a href="#cb46-9" aria-hidden="true" tabindex="-1"></a>    <span class="bu">List</span> heap <span class="op">=</span> <span class="kw">new</span> <span class="bu">ArrayList</span><span class="op">&lt;&gt;();</span></span></code></pre></div>
<h4 id="indexing">Indexing</h4>
<p>We have to worry about 3 types of indexing in a heap, finding the
parent, the left or the right child of a given node.</p>
<ul>
<li>left - the left child of each heap element is always an odd number,
it is derived from <code>(2 \* i) + 1</code></li>
<li>right - the right child of each heap node is always an even number,
it is derived from <code>(2 \* i) + 2</code></li>
<li>parent - the parent, using the two equations above, can be derived,
by simply reversing them, check if the number is odd/even to know, the
child index you have, derived from
<code>(child - (child % 2 == 0 ? 2 : 1)) / 2</code></li>
<li>max/min - the very root of the heap, it’s index is simply 0, always,
we will find the max/min element to be the first element of the
heap</li>
</ul>
<div class="sourceCode" id="cb47"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb47-1"><a href="#cb47-1" aria-hidden="true" tabindex="-1"></a>    <span class="bu">Integer</span> <span class="fu">peek</span><span class="op">(</span><span class="bu">List</span> heap<span class="op">)</span> <span class="op">{</span></span>
<span id="cb47-2"><a href="#cb47-2" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>heap<span class="op">.</span><span class="fu">isEmpty</span><span class="op">())</span> <span class="op">{</span></span>
<span id="cb47-3"><a href="#cb47-3" aria-hidden="true" tabindex="-1"></a>            <span class="co">// an empty heap has nothing to peek at</span></span>
<span id="cb47-4"><a href="#cb47-4" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="kw">null</span><span class="op">;</span></span>
<span id="cb47-5"><a href="#cb47-5" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb47-6"><a href="#cb47-6" aria-hidden="true" tabindex="-1"></a>        <span class="co">// the element of a heap that can be looked at is always at the top, either the smallest, or the biggest in a heap</span></span>
<span id="cb47-7"><a href="#cb47-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> heap<span class="op">.</span><span class="fu">get</span><span class="op">(</span><span class="dv">0</span><span class="op">);</span></span>
<span id="cb47-8"><a href="#cb47-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb47-9"><a href="#cb47-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb47-10"><a href="#cb47-10" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> <span class="fu">parent</span><span class="op">(</span><span class="dt">int</span> child<span class="op">)</span> <span class="op">{</span></span>
<span id="cb47-11"><a href="#cb47-11" aria-hidden="true" tabindex="-1"></a>        <span class="co">// parent index of a heap element can be computed from either the left or the right child, we know that left child indices are</span></span>
<span id="cb47-12"><a href="#cb47-12" aria-hidden="true" tabindex="-1"></a>        <span class="co">// always not even, and right ones are always even, therefore, first check mod 2, and subtract 2, for right child, or 1 for a</span></span>
<span id="cb47-13"><a href="#cb47-13" aria-hidden="true" tabindex="-1"></a>        <span class="co">// left child</span></span>
<span id="cb47-14"><a href="#cb47-14" aria-hidden="true" tabindex="-1"></a>        child <span class="op">=</span> child <span class="op">%</span> <span class="dv">2</span> <span class="op">==</span> <span class="dv">0</span> <span class="op">?</span> child <span class="op">-</span> <span class="dv">2</span> <span class="op">:</span> child <span class="op">-</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb47-15"><a href="#cb47-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb47-16"><a href="#cb47-16" aria-hidden="true" tabindex="-1"></a>        <span class="co">// finally to get the parent divide by 2, this basically reverses the equation for finding a child from a parent index, see the</span></span>
<span id="cb47-17"><a href="#cb47-17" aria-hidden="true" tabindex="-1"></a>        <span class="co">// methods below</span></span>
<span id="cb47-18"><a href="#cb47-18" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> child <span class="op">/</span> <span class="dv">2</span><span class="op">;</span></span>
<span id="cb47-19"><a href="#cb47-19" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb47-20"><a href="#cb47-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb47-21"><a href="#cb47-21" aria-hidden="true" tabindex="-1"></a>    <span class="kw">private</span> <span class="dt">int</span> <span class="fu">left</span><span class="op">(</span><span class="dt">int</span> parent<span class="op">)</span> <span class="op">{</span></span>
<span id="cb47-22"><a href="#cb47-22" aria-hidden="true" tabindex="-1"></a>        <span class="co">// to get the left child, multiply the parent index by two, and add one, each number multiplied by two becomes an even, adding</span></span>
<span id="cb47-23"><a href="#cb47-23" aria-hidden="true" tabindex="-1"></a>        <span class="co">// one would make it odd, all right children are on odd indices</span></span>
<span id="cb47-24"><a href="#cb47-24" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="op">(</span><span class="dv">2</span> <span class="op">*</span> parent<span class="op">)</span> <span class="op">+</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb47-25"><a href="#cb47-25" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb47-26"><a href="#cb47-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb47-27"><a href="#cb47-27" aria-hidden="true" tabindex="-1"></a>    <span class="kw">private</span> <span class="dt">int</span> <span class="fu">right</span><span class="op">(</span><span class="dt">int</span> parent<span class="op">)</span> <span class="op">{</span></span>
<span id="cb47-28"><a href="#cb47-28" aria-hidden="true" tabindex="-1"></a>        <span class="co">// to get the right child, multiply the parent index by two, and add two, each number multiplied by two becomes an even, adding</span></span>
<span id="cb47-29"><a href="#cb47-29" aria-hidden="true" tabindex="-1"></a>        <span class="co">// two would keep it even, all left children are on even indices</span></span>
<span id="cb47-30"><a href="#cb47-30" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="op">(</span><span class="dv">2</span> <span class="op">*</span> parent<span class="op">)</span> <span class="op">+</span> <span class="dv">2</span><span class="op">;</span></span>
<span id="cb47-31"><a href="#cb47-31" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<h4 id="swapping">Swapping</h4>
<p>Since it is often used operation in a heap, it is good to show what
it does, simply put swap the two elements located at the input indices
in the heap.</p>
<div class="sourceCode" id="cb48"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb48-1"><a href="#cb48-1" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> <span class="fu">swap</span><span class="op">(</span><span class="bu">List</span><span class="op">&lt;</span>T<span class="op">&gt;</span> heap<span class="op">,</span> <span class="dt">int</span> l<span class="op">,</span> <span class="dt">int</span> r<span class="op">)</span> <span class="op">{</span></span>
<span id="cb48-2"><a href="#cb48-2" aria-hidden="true" tabindex="-1"></a>        <span class="co">// simple method to swap elements located on two indices</span></span>
<span id="cb48-3"><a href="#cb48-3" aria-hidden="true" tabindex="-1"></a>        T c <span class="op">=</span> heap<span class="op">.</span><span class="fu">get</span><span class="op">(</span>r<span class="op">);</span></span>
<span id="cb48-4"><a href="#cb48-4" aria-hidden="true" tabindex="-1"></a>        T p <span class="op">=</span> heap<span class="op">.</span><span class="fu">get</span><span class="op">(</span>l<span class="op">);</span></span>
<span id="cb48-5"><a href="#cb48-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb48-6"><a href="#cb48-6" aria-hidden="true" tabindex="-1"></a>        <span class="co">// exchange the elements at the two index locations in the heap array</span></span>
<span id="cb48-7"><a href="#cb48-7" aria-hidden="true" tabindex="-1"></a>        heap<span class="op">.</span><span class="fu">set</span><span class="op">(</span>r<span class="op">,</span> p<span class="op">);</span></span>
<span id="cb48-8"><a href="#cb48-8" aria-hidden="true" tabindex="-1"></a>        heap<span class="op">.</span><span class="fu">set</span><span class="op">(</span>l<span class="op">,</span> c<span class="op">);</span></span>
<span id="cb48-9"><a href="#cb48-9" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<h4 id="inserting">Inserting</h4>
<p>To insert in a binary heap tree we have to do two major things.</p>
<ul>
<li>the new element to insert goes to the end of the heap</li>
<li>the new element is bubbled up to the correct position</li>
</ul>
<p>The bubbling is based on the tree type, but briefly, we check the
current element with its parent, and swap if the conditions below are
met</p>
<ul>
<li>for min heaps = if smaller than the parent we swap them</li>
<li>for min heaps = it bigger than the parent we swap them</li>
</ul>
<div class="sourceCode" id="cb49"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb49-1"><a href="#cb49-1" aria-hidden="true" tabindex="-1"></a>    <span class="bu">Integer</span> <span class="fu">insert</span><span class="op">(</span><span class="bu">List</span> heap<span class="op">,</span> <span class="bu">Integer</span> value<span class="op">)</span> <span class="op">{</span></span>
<span id="cb49-2"><a href="#cb49-2" aria-hidden="true" tabindex="-1"></a>        <span class="co">// first off we start by putting the new item at the end of the array or heap, and getting that new index location of the last</span></span>
<span id="cb49-3"><a href="#cb49-3" aria-hidden="true" tabindex="-1"></a>        <span class="co">// element we have just inserted</span></span>
<span id="cb49-4"><a href="#cb49-4" aria-hidden="true" tabindex="-1"></a>        heap<span class="op">.</span><span class="fu">add</span><span class="op">(</span>value<span class="op">);</span></span>
<span id="cb49-5"><a href="#cb49-5" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> curr <span class="op">=</span> heap<span class="op">.</span><span class="fu">size</span><span class="op">()</span> <span class="op">-</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb49-6"><a href="#cb49-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb49-7"><a href="#cb49-7" aria-hidden="true" tabindex="-1"></a>        <span class="co">// what is going on here, is looping until the current element is not pointing at the root, or in other words at index 0,</span></span>
<span id="cb49-8"><a href="#cb49-8" aria-hidden="true" tabindex="-1"></a>        <span class="co">// current starts off from the insertion position, i.e the end of the heap, the very last element and bubbles up the new element</span></span>
<span id="cb49-9"><a href="#cb49-9" aria-hidden="true" tabindex="-1"></a>        <span class="co">// until the correct spot is found</span></span>
<span id="cb49-10"><a href="#cb49-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span> <span class="op">(</span>curr <span class="op">&gt;</span> <span class="dv">0</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb49-11"><a href="#cb49-11" aria-hidden="true" tabindex="-1"></a>            <span class="co">// calculate the parent of the current index, and extract the value of the parent</span></span>
<span id="cb49-12"><a href="#cb49-12" aria-hidden="true" tabindex="-1"></a>            <span class="dt">int</span> prev <span class="op">=</span> <span class="fu">parent</span><span class="op">(</span>curr<span class="op">);</span></span>
<span id="cb49-13"><a href="#cb49-13" aria-hidden="true" tabindex="-1"></a>            <span class="bu">Integer</span> parent <span class="op">=</span> heap<span class="op">.</span><span class="fu">get</span><span class="op">(</span>prev<span class="op">);</span></span>
<span id="cb49-14"><a href="#cb49-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb49-15"><a href="#cb49-15" aria-hidden="true" tabindex="-1"></a>            <span class="co">// find if the new element is bigger, smaller or equal to the parent</span></span>
<span id="cb49-16"><a href="#cb49-16" aria-hidden="true" tabindex="-1"></a>            <span class="dt">int</span> diff <span class="op">=</span> value <span class="op">-</span> parent<span class="op">;</span></span>
<span id="cb49-17"><a href="#cb49-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb49-18"><a href="#cb49-18" aria-hidden="true" tabindex="-1"></a>            <span class="co">// when equal to the parent, we can abort, duplicates are not swapped, for simplicity</span></span>
<span id="cb49-19"><a href="#cb49-19" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>diff <span class="op">==</span> <span class="dv">0</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb49-20"><a href="#cb49-20" aria-hidden="true" tabindex="-1"></a>                <span class="cf">break</span><span class="op">;</span></span>
<span id="cb49-21"><a href="#cb49-21" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb49-22"><a href="#cb49-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb49-23"><a href="#cb49-23" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>type <span class="op">==</span> HeapType<span class="op">.</span><span class="fu">MIN</span> <span class="op">&amp;&amp;</span> diff <span class="op">&lt;</span> <span class="dv">0</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb49-24"><a href="#cb49-24" aria-hidden="true" tabindex="-1"></a>                <span class="co">// when we are in a min heap, the swap is happening only if the new element is smaller than it&#39;s parent, this is because</span></span>
<span id="cb49-25"><a href="#cb49-25" aria-hidden="true" tabindex="-1"></a>                <span class="co">// the new element being smaller, has to be bubbled up, until it is no longer smaller than it&#39;s parent</span></span>
<span id="cb49-26"><a href="#cb49-26" aria-hidden="true" tabindex="-1"></a>                <span class="fu">swap</span><span class="op">(</span>heap<span class="op">,</span> curr<span class="op">,</span> prev<span class="op">);</span></span>
<span id="cb49-27"><a href="#cb49-27" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb49-28"><a href="#cb49-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb49-29"><a href="#cb49-29" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>type <span class="op">==</span> HeapType<span class="op">.</span><span class="fu">MAX</span> <span class="op">&amp;&amp;</span> diff <span class="op">&gt;</span> <span class="dv">0</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb49-30"><a href="#cb49-30" aria-hidden="true" tabindex="-1"></a>                <span class="co">// when we are in a max heap, the swap is happening only if the new element is bigger than it&#39;s parent, this is because</span></span>
<span id="cb49-31"><a href="#cb49-31" aria-hidden="true" tabindex="-1"></a>                <span class="co">// the new element being bigger, has to be bubbled up, until it is no longer bigger than it&#39;s parent</span></span>
<span id="cb49-32"><a href="#cb49-32" aria-hidden="true" tabindex="-1"></a>                <span class="fu">swap</span><span class="op">(</span>heap<span class="op">,</span> curr<span class="op">,</span> prev<span class="op">);</span></span>
<span id="cb49-33"><a href="#cb49-33" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb49-34"><a href="#cb49-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb49-35"><a href="#cb49-35" aria-hidden="true" tabindex="-1"></a>            <span class="co">// move up to the parent of the current element, eventually prev here would become 0, index 0, and the while loop will</span></span>
<span id="cb49-36"><a href="#cb49-36" aria-hidden="true" tabindex="-1"></a>            <span class="co">// finish, meaning that the element was bubbled to the top, for extra peformance one might just break after we find the</span></span>
<span id="cb49-37"><a href="#cb49-37" aria-hidden="true" tabindex="-1"></a>            <span class="co">// first element where diff does not perform a swap, meaning the element is already at the correct spot.</span></span>
<span id="cb49-38"><a href="#cb49-38" aria-hidden="true" tabindex="-1"></a>            curr <span class="op">=</span> prev<span class="op">;</span></span>
<span id="cb49-39"><a href="#cb49-39" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb49-40"><a href="#cb49-40" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> value<span class="op">;</span></span>
<span id="cb49-41"><a href="#cb49-41" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<h4 id="deleting">Deleting</h4>
<p>Deleting an element from the tree is a bit more convoluted, what we
do here is to take the last element from the heap, put it at the very
root / top of the heap and then gradually try to drop it down until a
correct spot for it is found. We can also remember the old root element
and return it (optional).</p>
<p>What is important here to take note of is how we decide to move down
the element. On each step the last element we choose would either go
down the tree or stop, if it stops then it has found the correct place.
To go down we can follow these rules for the two types of trees</p>
<ul>
<li><p>if we have min heap - for min heap we know that smaller elements
would be closer to the top than bigger ones, therefore we have to find
the smallest element between the root, left or right if the root happens
to be the smallest, it is at the correct place, otherwise swap the root
with the smaller one between left or right. The new root becomes the
index of the child with which we swapped</p></li>
<li><p>if we have max heap - for min heap we know that bigger elements
would be closer to the top than smaller ones, therefore we have to find
the biggest element between the root, left or right if the root happens
to be the biggest, it is at the correct place, otherwise swap the root
with the bigger one between left or right. The new root becomes the
index of the child with which we swapped</p></li>
</ul>
<pre class="jav"><code>    Integer delete(List heap) {
        // there is nothing to delete from an emtpy heap in the first place
        if (heap.isEmpty()) {
            return null;
        }

        // first get the last element from the heap and swap with with the root, the last element will then be bubbled down, and the
        // root returned from this function as result
        int last = heap.size() - 1;
        swap(heap, last, 0);

        // the head or root of the heap is now the last one, after the swap, just remember it, and remove it from the heap
        Integer head = heap.get(last);
        heap.remove(last);

        // we start off from the top or head of the heap, going down locating the left and right indices of the current element and
        // check if the root needs to stay in it&#39;s place, or go left or right
        int next = 0;
        while (next &lt; heap.size()) {
            // get the indices of the left and right children of the current element
            int left = left(next);
            int right = right(next);

            // start off by assuming the smallest / biggest (whichever heap type we have) element between the root and it&#39;s children is
            // the root, set the &#39;base&#39; index to point at the root initially, this base index will either change, or remain the same,
            // based on this we would know to continue or not to swap elements
            int base = next;

            if (type == HeapType.MIN) {
                // we first compare the value of the &#39;base&#39; index with it&#39;s left child, if the left child is smaller than the root, we
                // update the &#39;base&#39; index to point to the left child index
                if (left &lt; heap.size() &amp;&amp; heap.get(left) &lt; heap.get(base)) {
                    // left becomes the smaller between base and left
                    base = left;
                }

                // we first compare the value of the &#39;base&#39; index with it&#39;s right child, if the right child is smaller than the &#39;base&#39;,
                // we update the &#39;base&#39; index to point to the right child index
                if (right &lt; heap.size() &amp;&amp; heap.get(right) &lt; heap.get(base)) {
                    // right becomes the smaller between base and right
                    base = right;
                }
            } else if (type == HeapType.MAX) {
                // we first compare the value of the &#39;base&#39; index with it&#39;s left child, if the left child is bigger than the root, we
                // update the &#39;base&#39; index to point to the left child index
                if (left &lt; heap.size() &amp;&amp; heap.get(left) &gt; heap.get(base)) {
                    // left becomes the bigger between base and left
                    base = left;
                }

                // we first compare the value of the &#39;base&#39; index with it&#39;s right child, if the right child is bigger than the &#39;base&#39;,
                // we update the &#39;base&#39; index to point to the right child index
                if (right &lt; heap.size() &amp;&amp; heap.get(right) &gt; heap.get(base)) {
                    // right becomes the bigger between base and right
                    base = right;
                }
            }

            if (base != next) {
                // if the base index actually changed, then we can swap the base with next, meaning that either the left or right
                // children of the root were smaller / bigger (based on the heap type we have)
                swap(heap, base, next);
                // now we move to the next index with which we swapped, either the left or right, to continue to drop down
                // the element until it finds its place
                next = base;
            } else {
                // at this point the base did not change, meaning the root was the smallest / biggest of the 3 (root,left,right),
                // therefore the element is at the correct position, there is nowhere for it to go further, it conforms to the rules
                // of a heap
                break;
            }
        }
        return head;
    }</code></pre>
<h3 id="tries">Tries</h3>
<p>Also called prefix trees, the word trie comes from the word
Retrieval, they are used to store words, and look up if a word is
present in O(M) time, where M is the length of the word, unlike regular
trees that store each entire words in a each node, tries are more
efficient. Words are represented as with their prefixes</p>
<p>These are a type of n-ary trees, where the n in this case is the
number of characters in an alphabet, for the English one that would be
26. Each node BESIDES the very root of the Trie represents not only a
node with children, but a character as well, even though that is
implicitly done.</p>
<p>Each root will have up to the n-children, but not all children are
going to exist at the same time, see example below. However to denote a
word trie nodes usually have a boolean flag, which tells us if the path
to that node forms a word. (e.g. if we have the word bigger, but the
word big was not added, to the trie, the path big would exist but it
would not form the word big, until we insert explicitly the word
big)</p>
<p>A trie that represents a few words, might look like that, note how
the root contains a lot of nodes, but the children might just have
handful, it is not mandated that each level is fully filled (with in 26
nodes, for the English example)</p>
<div class="sourceCode" id="cb51"><pre
class="sourceCode txt"><code class="sourceCode default"><span id="cb51-1"><a href="#cb51-1" aria-hidden="true" tabindex="-1"></a>         *</span>
<span id="cb51-2"><a href="#cb51-2" aria-hidden="true" tabindex="-1"></a>       / | \ .......... \</span>
<span id="cb51-3"><a href="#cb51-3" aria-hidden="true" tabindex="-1"></a>      a  b  c           q</span>
<span id="cb51-4"><a href="#cb51-4" aria-hidden="true" tabindex="-1"></a>     /   |   \        /   \</span>
<span id="cb51-5"><a href="#cb51-5" aria-hidden="true" tabindex="-1"></a>    n    i    a      u     t</span>
<span id="cb51-6"><a href="#cb51-6" aria-hidden="true" tabindex="-1"></a>   /     g   / \    /      |</span>
<span id="cb51-7"><a href="#cb51-7" aria-hidden="true" tabindex="-1"></a>  t     / \  r t   o       i</span>
<span id="cb51-8"><a href="#cb51-8" aria-hidden="true" tabindex="-1"></a>   \   g   f       |       |</span>
<span id="cb51-9"><a href="#cb51-9" aria-hidden="true" tabindex="-1"></a>    o  \   |       t       e</span>
<span id="cb51-10"><a href="#cb51-10" aria-hidden="true" tabindex="-1"></a>     \  e  o       |</span>
<span id="cb51-11"><a href="#cb51-11" aria-hidden="true" tabindex="-1"></a>     n  |  |       e</span>
<span id="cb51-12"><a href="#cb51-12" aria-hidden="true" tabindex="-1"></a>        r  t</span></code></pre></div>
<p>This trie example might contain words such as (remember to denote a
word actually is part of the tree, not just a path to another word, it
has to have its terminating flag set to true, at the node, which
represents the end of the word, e.g. ‘big’ would have the terminating
flag in the g node set to true)</p>
<ul>
<li>an, ant, anton</li>
<li>big, bigger, bigfoot,</li>
<li>cat, car</li>
<li>quote, qtie</li>
</ul>
<div class="sourceCode" id="cb52"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb52-1"><a href="#cb52-1" aria-hidden="true" tabindex="-1"></a>    <span class="kw">class</span> TriePrefixNode <span class="op">{</span></span>
<span id="cb52-2"><a href="#cb52-2" aria-hidden="true" tabindex="-1"></a>        TriePrefixNode<span class="op">[]</span> children<span class="op">;</span></span>
<span id="cb52-3"><a href="#cb52-3" aria-hidden="true" tabindex="-1"></a>        <span class="dt">boolean</span> terminating <span class="op">=</span> <span class="kw">false</span><span class="op">;</span></span>
<span id="cb52-4"><a href="#cb52-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<h4 id="inserting-1">Inserting</h4>
<p>Inserting in a trie, is simply following the existing path, if one
does not exist create the new nodes, along those path using the
characters from the input word / string. At the end mark the final node
as terminating, as it would indicate that the specific unique path that
was followed/created terminates with a word that is part of the trie, it
has been inserted</p>
<div class="sourceCode" id="cb53"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb53-1"><a href="#cb53-1" aria-hidden="true" tabindex="-1"></a>    TriePrefixNode <span class="fu">insert</span><span class="op">(</span>TriePrefixNode root<span class="op">,</span> <span class="bu">String</span> string<span class="op">,</span> <span class="bu">Integer</span> value<span class="op">)</span> <span class="op">{</span></span>
<span id="cb53-2"><a href="#cb53-2" aria-hidden="true" tabindex="-1"></a>        <span class="co">// check if the input values first make any sense at all, the string can not be nil, and the value can not be nil either</span></span>
<span id="cb53-3"><a href="#cb53-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>string <span class="op">==</span> <span class="kw">null</span> <span class="op">||</span> value <span class="op">==</span> <span class="kw">null</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb53-4"><a href="#cb53-4" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="kw">null</span><span class="op">;</span></span>
<span id="cb53-5"><a href="#cb53-5" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb53-6"><a href="#cb53-6" aria-hidden="true" tabindex="-1"></a>        <span class="co">// for simplicity reasons normalize all strings to lower case, this is not really a part of an usual trie implementation but it</span></span>
<span id="cb53-7"><a href="#cb53-7" aria-hidden="true" tabindex="-1"></a>        <span class="co">// makes things easier to understand</span></span>
<span id="cb53-8"><a href="#cb53-8" aria-hidden="true" tabindex="-1"></a>        string <span class="op">=</span> string<span class="op">.</span><span class="fu">toLowerCase</span><span class="op">();</span></span>
<span id="cb53-9"><a href="#cb53-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb53-10"><a href="#cb53-10" aria-hidden="true" tabindex="-1"></a>        <span class="co">// either start off from the provided root, or make on if the insert was called without a valid root</span></span>
<span id="cb53-11"><a href="#cb53-11" aria-hidden="true" tabindex="-1"></a>        TriePrefixNode base <span class="op">=</span> root<span class="op">;</span></span>
<span id="cb53-12"><a href="#cb53-12" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>root <span class="op">==</span> <span class="kw">null</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb53-13"><a href="#cb53-13" aria-hidden="true" tabindex="-1"></a>            root <span class="op">=</span> <span class="kw">new</span> <span class="fu">TriePrefixNode</span><span class="op">();</span></span>
<span id="cb53-14"><a href="#cb53-14" aria-hidden="true" tabindex="-1"></a>            base <span class="op">=</span> root<span class="op">;</span></span>
<span id="cb53-15"><a href="#cb53-15" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb53-16"><a href="#cb53-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb53-17"><a href="#cb53-17" aria-hidden="true" tabindex="-1"></a>        <span class="co">// go over each character in the input string.</span></span>
<span id="cb53-18"><a href="#cb53-18" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> string<span class="op">.</span><span class="fu">length</span><span class="op">();</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb53-19"><a href="#cb53-19" aria-hidden="true" tabindex="-1"></a>            <span class="co">// fetch the character and convert it to a number, in the ascii table the english alphabet lower case letters start at 97,</span></span>
<span id="cb53-20"><a href="#cb53-20" aria-hidden="true" tabindex="-1"></a>            <span class="co">// up until 97 + 26. This is used to index the character in node in the children list of a trie node</span></span>
<span id="cb53-21"><a href="#cb53-21" aria-hidden="true" tabindex="-1"></a>            <span class="bu">Character</span> c <span class="op">=</span> string<span class="op">.</span><span class="fu">charAt</span><span class="op">(</span>i<span class="op">);</span></span>
<span id="cb53-22"><a href="#cb53-22" aria-hidden="true" tabindex="-1"></a>            <span class="dt">int</span> cval <span class="op">=</span> c<span class="op">.</span><span class="fu">charValue</span><span class="op">();</span></span>
<span id="cb53-23"><a href="#cb53-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb53-24"><a href="#cb53-24" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>root<span class="op">.</span><span class="fu">children</span> <span class="op">==</span> <span class="kw">null</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb53-25"><a href="#cb53-25" aria-hidden="true" tabindex="-1"></a>                <span class="co">// the current root has no children, therefore we have to create an array of 26 children first, this is needed,</span></span>
<span id="cb53-26"><a href="#cb53-26" aria-hidden="true" tabindex="-1"></a>                <span class="co">// to make an empty array of null pointers, which are going to be filled in with node instances</span></span>
<span id="cb53-27"><a href="#cb53-27" aria-hidden="true" tabindex="-1"></a>                root<span class="op">.</span><span class="fu">children</span> <span class="op">=</span> <span class="kw">new</span> TriePrefixNode<span class="op">[</span><span class="dv">26</span><span class="op">];</span></span>
<span id="cb53-28"><a href="#cb53-28" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb53-29"><a href="#cb53-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb53-30"><a href="#cb53-30" aria-hidden="true" tabindex="-1"></a>            <span class="co">// find which child index the current character corresponds to, it can either already exist, or not, if it exists we just</span></span>
<span id="cb53-31"><a href="#cb53-31" aria-hidden="true" tabindex="-1"></a>            <span class="co">// take that path, and continue down, setting the next root to the found node</span></span>
<span id="cb53-32"><a href="#cb53-32" aria-hidden="true" tabindex="-1"></a>            TriePrefixNode node <span class="op">=</span> root<span class="op">.</span><span class="fu">children</span><span class="op">[</span>cval <span class="op">-</span> <span class="ch">&#39;a&#39;</span><span class="op">];</span></span>
<span id="cb53-33"><a href="#cb53-33" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>node <span class="op">==</span> <span class="kw">null</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb53-34"><a href="#cb53-34" aria-hidden="true" tabindex="-1"></a>                <span class="co">// the node at that char position does not exist, create a new node instance, and assign it to that position in the</span></span>
<span id="cb53-35"><a href="#cb53-35" aria-hidden="true" tabindex="-1"></a>                <span class="co">// root&#39;s children</span></span>
<span id="cb53-36"><a href="#cb53-36" aria-hidden="true" tabindex="-1"></a>                node <span class="op">=</span> <span class="kw">new</span> <span class="fu">TriePrefixNode</span><span class="op">();</span></span>
<span id="cb53-37"><a href="#cb53-37" aria-hidden="true" tabindex="-1"></a>                root<span class="op">.</span><span class="fu">children</span><span class="op">[</span>cval <span class="op">-</span> <span class="ch">&#39;a&#39;</span><span class="op">]</span> <span class="op">=</span> node<span class="op">;</span></span>
<span id="cb53-38"><a href="#cb53-38" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb53-39"><a href="#cb53-39" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb53-40"><a href="#cb53-40" aria-hidden="true" tabindex="-1"></a>            <span class="co">// the next root would now be the last character node we inserted, continue until the string is completely looped over</span></span>
<span id="cb53-41"><a href="#cb53-41" aria-hidden="true" tabindex="-1"></a>            root <span class="op">=</span> node<span class="op">;</span></span>
<span id="cb53-42"><a href="#cb53-42" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb53-43"><a href="#cb53-43" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb53-44"><a href="#cb53-44" aria-hidden="true" tabindex="-1"></a>        <span class="co">// after the string has been looped over the root node here would point at the last character node, we mark it as terminating,</span></span>
<span id="cb53-45"><a href="#cb53-45" aria-hidden="true" tabindex="-1"></a>        <span class="co">// meaning that it represents an end of the path, or in other words one complete word, and we set a value mapping to it. The</span></span>
<span id="cb53-46"><a href="#cb53-46" aria-hidden="true" tabindex="-1"></a>        <span class="co">// value here is not a usual part of trie implementation, it is done to demonstrate how a value can be mapped to a word/string</span></span>
<span id="cb53-47"><a href="#cb53-47" aria-hidden="true" tabindex="-1"></a>        <span class="co">// in a trie, similarly to a hash-map</span></span>
<span id="cb53-48"><a href="#cb53-48" aria-hidden="true" tabindex="-1"></a>        root<span class="op">.</span><span class="fu">terminating</span> <span class="op">=</span> <span class="kw">true</span><span class="op">;</span></span>
<span id="cb53-49"><a href="#cb53-49" aria-hidden="true" tabindex="-1"></a>        root<span class="op">.</span><span class="fu">value</span> <span class="op">=</span> value<span class="op">;</span></span>
<span id="cb53-50"><a href="#cb53-50" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb53-51"><a href="#cb53-51" aria-hidden="true" tabindex="-1"></a>        <span class="co">// return the base root node, which represents the passed in or created root</span></span>
<span id="cb53-52"><a href="#cb53-52" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> base<span class="op">;</span></span>
<span id="cb53-53"><a href="#cb53-53" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<h4 id="searching-1">Searching</h4>
<p>Searching is very similar to inserting, but instead of creating
missing nodes, we strictly try follow existing paths, if one does not
exit, or the last node in the path is not
<code>terminating = true</code>, then we can deduce this particular word
being searched for is not part of the tree (the path might exist, but as
part of another bigger / longer word)</p>
<div class="sourceCode" id="cb54"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb54-1"><a href="#cb54-1" aria-hidden="true" tabindex="-1"></a>    <span class="dt">boolean</span> <span class="fu">search</span><span class="op">(</span>TriePrefixNode root<span class="op">,</span> <span class="bu">String</span> string<span class="op">)</span> <span class="op">{</span></span>
<span id="cb54-2"><a href="#cb54-2" aria-hidden="true" tabindex="-1"></a>        <span class="co">// make some validation on the input, nil strings are not valid, neither are non existent roots</span></span>
<span id="cb54-3"><a href="#cb54-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>string <span class="op">==</span> <span class="kw">null</span> <span class="op">||</span> root <span class="op">==</span> <span class="kw">null</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb54-4"><a href="#cb54-4" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="kw">false</span><span class="op">;</span></span>
<span id="cb54-5"><a href="#cb54-5" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb54-6"><a href="#cb54-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-7"><a href="#cb54-7" aria-hidden="true" tabindex="-1"></a>        <span class="co">// for simplicity reasons normalize all strings to lower case, this is not really a part of an usual trie implementation but it</span></span>
<span id="cb54-8"><a href="#cb54-8" aria-hidden="true" tabindex="-1"></a>        <span class="co">// makes things easier to understand</span></span>
<span id="cb54-9"><a href="#cb54-9" aria-hidden="true" tabindex="-1"></a>        string <span class="op">=</span> string<span class="op">.</span><span class="fu">toLowerCase</span><span class="op">();</span></span>
<span id="cb54-10"><a href="#cb54-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-11"><a href="#cb54-11" aria-hidden="true" tabindex="-1"></a>        <span class="co">// go over each character in the input string.</span></span>
<span id="cb54-12"><a href="#cb54-12" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> string<span class="op">.</span><span class="fu">length</span><span class="op">();</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb54-13"><a href="#cb54-13" aria-hidden="true" tabindex="-1"></a>            <span class="co">// fetch the character and convert it to a number, in the ascii table the english alphabet lower case letters start at 97,</span></span>
<span id="cb54-14"><a href="#cb54-14" aria-hidden="true" tabindex="-1"></a>            <span class="co">// up until 97 + 26. This is used to index the character in node in the children list of a trie node</span></span>
<span id="cb54-15"><a href="#cb54-15" aria-hidden="true" tabindex="-1"></a>            <span class="bu">Character</span> c <span class="op">=</span> string<span class="op">.</span><span class="fu">charAt</span><span class="op">(</span>i<span class="op">);</span></span>
<span id="cb54-16"><a href="#cb54-16" aria-hidden="true" tabindex="-1"></a>            <span class="dt">int</span> cval <span class="op">=</span> c<span class="op">.</span><span class="fu">charValue</span><span class="op">();</span></span>
<span id="cb54-17"><a href="#cb54-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-18"><a href="#cb54-18" aria-hidden="true" tabindex="-1"></a>            <span class="co">// if the current root is invalid or has no children array initialized, there is nowhere to go really, therefore the passed</span></span>
<span id="cb54-19"><a href="#cb54-19" aria-hidden="true" tabindex="-1"></a>            <span class="co">// in string &#39;word&#39; is not part of the trie. there is no path in the tree which would describe this word</span></span>
<span id="cb54-20"><a href="#cb54-20" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>root <span class="op">==</span> <span class="kw">null</span> <span class="op">||</span> root<span class="op">.</span><span class="fu">children</span> <span class="op">==</span> <span class="kw">null</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb54-21"><a href="#cb54-21" aria-hidden="true" tabindex="-1"></a>                <span class="co">// nothing was found, return false</span></span>
<span id="cb54-22"><a href="#cb54-22" aria-hidden="true" tabindex="-1"></a>                <span class="cf">return</span> <span class="kw">false</span><span class="op">;</span></span>
<span id="cb54-23"><a href="#cb54-23" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb54-24"><a href="#cb54-24" aria-hidden="true" tabindex="-1"></a>            <span class="co">// set the next root to the child which corresponds to the char index, from the root.children nodes, that node can either be</span></span>
<span id="cb54-25"><a href="#cb54-25" aria-hidden="true" tabindex="-1"></a>            <span class="co">// null, or be initialized, when we re-enter the next iteration, it will either terminate on root == null / or root.children</span></span>
<span id="cb54-26"><a href="#cb54-26" aria-hidden="true" tabindex="-1"></a>            <span class="co">// == null or keep going</span></span>
<span id="cb54-27"><a href="#cb54-27" aria-hidden="true" tabindex="-1"></a>            root <span class="op">=</span> root<span class="op">.</span><span class="fu">children</span><span class="op">[</span>cval <span class="op">-</span> <span class="ch">&#39;a&#39;</span><span class="op">];</span></span>
<span id="cb54-28"><a href="#cb54-28" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb54-29"><a href="#cb54-29" aria-hidden="true" tabindex="-1"></a>        <span class="co">// reaching this point does not mean we have found the string &#39;word&#39; still, the path might exist, as a subpath of another longer</span></span>
<span id="cb54-30"><a href="#cb54-30" aria-hidden="true" tabindex="-1"></a>        <span class="co">// word, we have to see if the node at the end of the path for the current string &#39;word&#39; was marked as terminating, meaning it</span></span>
<span id="cb54-31"><a href="#cb54-31" aria-hidden="true" tabindex="-1"></a>        <span class="co">// represent a word in the trie.</span></span>
<span id="cb54-32"><a href="#cb54-32" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> root<span class="op">.</span><span class="fu">terminating</span><span class="op">;</span></span>
<span id="cb54-33"><a href="#cb54-33" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<h4 id="deleting-1">Deleting</h4>
<p>todo: this is not yet finalized, finish it</p>
<h3 id="b-trees">B-Trees</h3>
<h2 id="workeriterator-approach">Worker&amp;Iterator approach</h2>
<p>Solving tree problems very often involves a very common approach
technique, which as to be taken extra note of. Very often the problems
for trees involve developing two recursive solutions. One might be
called the main worker solution, and the other is the iterating
function. This approach comes very often in tree problems. Two functions
with dedicated roles / actions.</p>
<div class="sourceCode" id="cb55"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb55-1"><a href="#cb55-1" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> <span class="fu">worker</span><span class="op">(</span><span class="bu">Node</span> root<span class="op">,</span> Params<span class="kw">...</span> params<span class="op">)</span> <span class="op">{</span></span>
<span id="cb55-2"><a href="#cb55-2" aria-hidden="true" tabindex="-1"></a>        <span class="co">// is a recursive function that does the actual work on a node basis</span></span>
<span id="cb55-3"><a href="#cb55-3" aria-hidden="true" tabindex="-1"></a>        <span class="co">// it is meant to do the actual work, produce result and use that result</span></span>
<span id="cb55-4"><a href="#cb55-4" aria-hidden="true" tabindex="-1"></a>        <span class="co">// in the iterating function, to accumulate it, to store it, to return it</span></span>
<span id="cb55-5"><a href="#cb55-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb55-6"><a href="#cb55-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb55-7"><a href="#cb55-7" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> <span class="fu">iterator</span><span class="op">(</span><span class="bu">Node</span> root<span class="op">)</span> <span class="op">{</span></span>
<span id="cb55-8"><a href="#cb55-8" aria-hidden="true" tabindex="-1"></a>        <span class="co">// iterator solution which basically goes through the nodes, collects</span></span>
<span id="cb55-9"><a href="#cb55-9" aria-hidden="true" tabindex="-1"></a>        <span class="co">// information for the worker function to do it&#39;s job, the worker</span></span>
<span id="cb55-10"><a href="#cb55-10" aria-hidden="true" tabindex="-1"></a>        <span class="co">// execution might happen as pre, post recursive call or we might call it</span></span>
<span id="cb55-11"><a href="#cb55-11" aria-hidden="true" tabindex="-1"></a>        <span class="co">// multiple times in the iterator function , but it is the main solver</span></span>
<span id="cb55-12"><a href="#cb55-12" aria-hidden="true" tabindex="-1"></a>        <span class="fu">worker</span><span class="op">(</span>root<span class="op">)</span></span>
<span id="cb55-13"><a href="#cb55-13" aria-hidden="true" tabindex="-1"></a>        <span class="fu">iterator</span><span class="op">(</span>root<span class="op">.</span><span class="fu">left</span><span class="op">)</span></span>
<span id="cb55-14"><a href="#cb55-14" aria-hidden="true" tabindex="-1"></a>        <span class="fu">iterator</span><span class="op">(</span>root<span class="op">.</span><span class="fu">right</span><span class="op">)</span></span>
<span id="cb55-15"><a href="#cb55-15" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<p>We can notice how many times the worker &amp; iterator approach was
observed above, there are multitude of solutions, which make use of it
like</p>
<ul>
<li><p><a href="###Ancestor">Ancestor</a> - makes use of the contains,
which is the main function providing the result based on which the
iterator function decides how to proceed further down the tree, or
stop</p></li>
<li><p><a href="###Subtrees">Subtrees</a> - makes use of the compare,
which is the main function providing the result to validate subtree
equality, the iterator function simply goes in both left and right
direction</p></li>
</ul>
<h1 id="graphs">Graphs</h1>
<p>Graphs are a collection of nodes with edges between some of them. It
is a known fact that all trees are graphs, but not all graphs are trees.
A graph, which has cycles cannot be called a tree. Trees can only be
valid when there are no cycles between nodes.</p>
<p>A graph could contain multiple other sub-graphs, such that there are
no connections between different sub-graphs, if there are connections
between all nodes in a graph, we call this graph a connected one</p>
<p>Below we have an example of a graph, which contains two sub-graphs,
there are no connections between the two sub-graphs</p>
<div class="sourceCode" id="cb56"><pre
class="sourceCode txt"><code class="sourceCode default"><span id="cb56-1"><a href="#cb56-1" aria-hidden="true" tabindex="-1"></a>          k   o     m -- j -- w</span>
<span id="cb56-2"><a href="#cb56-2" aria-hidden="true" tabindex="-1"></a>         /    /     \    |</span>
<span id="cb56-3"><a href="#cb56-3" aria-hidden="true" tabindex="-1"></a>   a -- c -- f       y --</span>
<span id="cb56-4"><a href="#cb56-4" aria-hidden="true" tabindex="-1"></a>    \       /</span>
<span id="cb56-5"><a href="#cb56-5" aria-hidden="true" tabindex="-1"></a>    b --- d</span></code></pre></div>
<p>In practice, the most used graph we would encounter is a directed
graph, where the edges / connections have a direction, meaning
connection from <code>a -&gt; b</code> does not mean that
<code>b -&gt; a</code> exists automatically</p>
<h2 id="representations">Representations</h2>
<p>Depending on the task at hand there might be better or worse
representations to use, what is important is that as much information is
contained in the representation as possible (incoming edges, parent
nodes etc.)</p>
<h3 id="class-nodes">Class &amp; Nodes</h3>
<p>There are multiple ways to represent a graph, the most common one is
with a graph node, and a graph class, which is just enough to implement
most all graph features we would ever need. We need the class on top of
a node since in a graph it is possible to not have path from one single
root node to all others, that is actually usually the case, a graph
might have many root nodes (ones with no incoming edges), or it might
have no roots (nodes with 0 incoming edges), in that case if all nodes
have incoming edges this graph has cycles, there is no obvious graph
root to speak of</p>
<div class="sourceCode" id="cb57"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb57-1"><a href="#cb57-1" aria-hidden="true" tabindex="-1"></a>    <span class="kw">class</span> <span class="bu">Node</span> <span class="op">{</span></span>
<span id="cb57-2"><a href="#cb57-2" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> incoming<span class="op">;</span></span>
<span id="cb57-3"><a href="#cb57-3" aria-hidden="true" tabindex="-1"></a>        <span class="bu">Integer</span> value<span class="op">;</span></span>
<span id="cb57-4"><a href="#cb57-4" aria-hidden="true" tabindex="-1"></a>        <span class="bu">Node</span><span class="op">[]</span> children<span class="op">;</span></span>
<span id="cb57-5"><a href="#cb57-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb57-6"><a href="#cb57-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-7"><a href="#cb57-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">class</span> Graph <span class="op">{</span></span>
<span id="cb57-8"><a href="#cb57-8" aria-hidden="true" tabindex="-1"></a>        <span class="bu">Node</span><span class="op">[]</span> nodes<span class="op">;</span></span>
<span id="cb57-9"><a href="#cb57-9" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<p>In the structure above take note of the <code>incoming</code>
property, which is important, and tells us how many incoming edges link
to the current node, while <code>children</code> tell us how many
outbound connections we have coming out of the current node</p>
<h3 id="adjacency-matrices">Adjacency Matrices</h3>
<p>One popular way to represent a graph is by simply using a hash map
where the keys are the values of the nodes, and the nodes themselves,
and each value / node has a connection to a list of the nodes it
connects to. Instead of a normal hash map we could also use a multi map,
which is a more convenient way to add new node connections</p>
<div class="sourceCode" id="cb58"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb58-1"><a href="#cb58-1" aria-hidden="true" tabindex="-1"></a>    <span class="bu">HashMap</span><span class="op">&lt;</span><span class="bu">Integer</span><span class="op">,</span> <span class="bu">List</span><span class="op">&lt;</span><span class="bu">Integer</span><span class="op">&gt;&gt;</span> matrix<span class="op">;</span></span>
<span id="cb58-2"><a href="#cb58-2" aria-hidden="true" tabindex="-1"></a>    matrix<span class="op">.</span><span class="fu">put</span><span class="op">(</span><span class="dv">1</span><span class="op">,</span> <span class="bu">Arrays</span><span class="op">.</span><span class="fu">asList</span><span class="op">(</span><span class="dv">5</span><span class="op">,</span> <span class="dv">3</span><span class="op">,</span> <span class="dv">1</span><span class="op">));</span></span>
<span id="cb58-3"><a href="#cb58-3" aria-hidden="true" tabindex="-1"></a>    matrix<span class="op">.</span><span class="fu">put</span><span class="op">(</span><span class="dv">2</span><span class="op">,</span> <span class="bu">Arrays</span><span class="op">.</span><span class="fu">asList</span><span class="op">(</span><span class="dv">3</span><span class="op">,</span> <span class="dv">1</span><span class="op">));</span></span>
<span id="cb58-4"><a href="#cb58-4" aria-hidden="true" tabindex="-1"></a>    matrix<span class="op">.</span><span class="fu">put</span><span class="op">(</span><span class="dv">3</span><span class="op">,</span> <span class="bu">Arrays</span><span class="op">.</span><span class="fu">asList</span><span class="op">(</span><span class="dv">2</span><span class="op">,</span> <span class="dv">5</span><span class="op">,</span> <span class="dv">1</span><span class="op">));</span></span>
<span id="cb58-5"><a href="#cb58-5" aria-hidden="true" tabindex="-1"></a>    matrix<span class="op">.</span><span class="fu">put</span><span class="op">(</span><span class="dv">4</span><span class="op">,</span> <span class="bu">Arrays</span><span class="op">.</span><span class="fu">asList</span><span class="op">(</span><span class="dv">3</span><span class="op">));</span></span>
<span id="cb58-6"><a href="#cb58-6" aria-hidden="true" tabindex="-1"></a>    matrix<span class="op">.</span><span class="fu">put</span><span class="op">(</span><span class="dv">5</span><span class="op">,</span> <span class="bu">Arrays</span><span class="op">.</span><span class="fu">asList</span><span class="op">(</span><span class="dv">3</span><span class="op">,</span> <span class="dv">4</span><span class="op">));</span></span></code></pre></div>
<p>In the example above each key represents a unique node value, while
the arrays represent the links that node has to other nodes. This is for
directed graphs</p>
<h3 id="d-flags-array">2D Flags Array</h3>
<p>Another variant of the Adjacency matrix is a simple 2d array where
each position where an edge / connection exists in the 2d array is
marked with 1, and where no connection exists is marked with 0. In this
representation either the rows or the cols will represent from and to.
They are not interchangeable.</p>
<p>Below the <code>to</code> is presented by the columns, and the
<code>from</code> is presented by the rows. Meaning we can read this
matrix like that - <code>col to row</code> tells us the outgoing edges
for the node and <code>row to col</code> tells us the incoming edges for
the node.</p>
<ul>
<li>Take col-node <code>2</code> which in the matrix has 1 incoming edge
- <code>3</code></li>
<li>Take row-node <code>2</code> which in the matrix has 2 outgoing
edges - <code>1, 3</code></li>
</ul>
<p>That information tells us that node <code>2 and 3</code> are
bidirectionally connected in the graph example given below. While node
<code>2 and 1</code> are only connected from node <code>2 to 1</code>
but not the other way, in other words this is a singly directed
edge.</p>
<div class="sourceCode" id="cb59"><pre
class="sourceCode txt"><code class="sourceCode default"><span id="cb59-1"><a href="#cb59-1" aria-hidden="true" tabindex="-1"></a>      | 1 2 3 4 5</span>
<span id="cb59-2"><a href="#cb59-2" aria-hidden="true" tabindex="-1"></a>    -------------</span>
<span id="cb59-3"><a href="#cb59-3" aria-hidden="true" tabindex="-1"></a>    1 | 1 0 1 0 1</span>
<span id="cb59-4"><a href="#cb59-4" aria-hidden="true" tabindex="-1"></a>    2 | 1 0 1 0 0</span>
<span id="cb59-5"><a href="#cb59-5" aria-hidden="true" tabindex="-1"></a>    3 | 1 1 0 0 1</span>
<span id="cb59-6"><a href="#cb59-6" aria-hidden="true" tabindex="-1"></a>    4 | 0 0 1 0 0</span>
<span id="cb59-7"><a href="#cb59-7" aria-hidden="true" tabindex="-1"></a>    5 | 0 0 1 1 0</span></code></pre></div>
<h2 id="creation">Creation</h2>
<p>A very simple example, which creates a graph from a list of edges,
where the edges represent a simple <code>from - to</code> relation
between nodes. In the example below there are two main functions</p>
<ul>
<li><p>edges - creates an array / list of edges, the input here is a
simple list of values, which represents the <code>unique</code> graph
node values, and the links they form to other nodes.
e.g. <code>a, b, a, c, a, d, c, b, c,d</code>. In simple terms node
<code>a</code> has outgoing / child connections to nodes
<code>b, c and d</code>, then node <code>c</code> has outgoing / child
connections to nodes <code>b and d</code> and so on.</p></li>
<li><p>create - creates the graph node representation, in this case a
list of nodes, representing the graph, from a list of edges or
connections. While the edge <code>from</code> property must be present,
the <code>to</code> might be null, signaling that this node has no
connection to another node for example, or in other words it has no
outgoing connection, the input array / list of edges might look
something like that - <code>a, nil, a, c, a, d</code>.</p></li>
</ul>
<div class="sourceCode" id="cb60"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb60-1"><a href="#cb60-1" aria-hidden="true" tabindex="-1"></a>    <span class="kw">class</span> <span class="bu">Node</span> <span class="op">{</span></span>
<span id="cb60-2"><a href="#cb60-2" aria-hidden="true" tabindex="-1"></a>        <span class="bu">Integer</span> value<span class="op">;</span></span>
<span id="cb60-3"><a href="#cb60-3" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> incoming <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb60-4"><a href="#cb60-4" aria-hidden="true" tabindex="-1"></a>        <span class="bu">List</span><span class="op">&lt;</span><span class="bu">Node</span><span class="op">&gt;</span> children<span class="op">;</span></span>
<span id="cb60-5"><a href="#cb60-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb60-6"><a href="#cb60-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb60-7"><a href="#cb60-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">class</span> Edge <span class="op">{</span></span>
<span id="cb60-8"><a href="#cb60-8" aria-hidden="true" tabindex="-1"></a>        <span class="bu">Integer</span> from<span class="op">;</span></span>
<span id="cb60-9"><a href="#cb60-9" aria-hidden="true" tabindex="-1"></a>        <span class="bu">Integer</span> to<span class="op">;</span></span>
<span id="cb60-10"><a href="#cb60-10" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb60-11"><a href="#cb60-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb60-12"><a href="#cb60-12" aria-hidden="true" tabindex="-1"></a>    <span class="bu">List</span><span class="op">&lt;</span>Edge<span class="op">&gt;</span> <span class="fu">edges</span><span class="op">(</span><span class="bu">List</span><span class="op">&lt;</span>T<span class="op">&gt;</span> elements<span class="op">)</span> <span class="op">{</span></span>
<span id="cb60-13"><a href="#cb60-13" aria-hidden="true" tabindex="-1"></a>        <span class="co">// list has to be an even number since connections are from - to, note</span></span>
<span id="cb60-14"><a href="#cb60-14" aria-hidden="true" tabindex="-1"></a>        <span class="co">// that to could be a null element but still has to be present</span></span>
<span id="cb60-15"><a href="#cb60-15" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>elements<span class="op">.</span><span class="fu">size</span><span class="op">()</span> <span class="op">%</span> <span class="dv">2</span> <span class="op">!=</span> <span class="dv">0</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb60-16"><a href="#cb60-16" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="bu">Collections</span><span class="op">.</span><span class="fu">emptyList</span><span class="op">();</span></span>
<span id="cb60-17"><a href="#cb60-17" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb60-18"><a href="#cb60-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb60-19"><a href="#cb60-19" aria-hidden="true" tabindex="-1"></a>        <span class="co">// hold the list of edges, representing the graph connections</span></span>
<span id="cb60-20"><a href="#cb60-20" aria-hidden="true" tabindex="-1"></a>        <span class="bu">List</span><span class="op">&lt;</span>Edge<span class="op">&gt;</span> edges <span class="op">=</span> <span class="kw">new</span> <span class="bu">ArrayList</span><span class="op">&lt;&gt;();</span></span>
<span id="cb60-21"><a href="#cb60-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb60-22"><a href="#cb60-22" aria-hidden="true" tabindex="-1"></a>        <span class="co">// elements is a plain array which contains pairs of links, connections</span></span>
<span id="cb60-23"><a href="#cb60-23" aria-hidden="true" tabindex="-1"></a>        <span class="co">// between the nodes, we use that to construct the connections or edges</span></span>
<span id="cb60-24"><a href="#cb60-24" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> elements<span class="op">.</span><span class="fu">size</span><span class="op">();</span> i <span class="op">+=</span> <span class="dv">2</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb60-25"><a href="#cb60-25" aria-hidden="true" tabindex="-1"></a>            edges<span class="op">.</span><span class="fu">add</span><span class="op">(</span><span class="fu">edge</span><span class="op">(</span>elements<span class="op">.</span><span class="fu">get</span><span class="op">(</span>i<span class="op">),</span> elements<span class="op">.</span><span class="fu">get</span><span class="op">(</span>i <span class="op">+</span> <span class="dv">1</span><span class="op">)));</span></span>
<span id="cb60-26"><a href="#cb60-26" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb60-27"><a href="#cb60-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb60-28"><a href="#cb60-28" aria-hidden="true" tabindex="-1"></a>        <span class="co">// return the list of edges constructed from the elements array</span></span>
<span id="cb60-29"><a href="#cb60-29" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> edges<span class="op">;</span></span>
<span id="cb60-30"><a href="#cb60-30" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb60-31"><a href="#cb60-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb60-32"><a href="#cb60-32" aria-hidden="true" tabindex="-1"></a>    <span class="bu">List</span><span class="op">&lt;</span><span class="bu">Node</span><span class="op">&gt;</span> <span class="fu">create</span><span class="op">(</span><span class="bu">List</span><span class="op">&lt;</span>Edge<span class="op">&gt;</span> edges<span class="op">)</span> <span class="op">{</span></span>
<span id="cb60-33"><a href="#cb60-33" aria-hidden="true" tabindex="-1"></a>        <span class="co">// the cache holds each unique node based on it&#39;s primary value, and a</span></span>
<span id="cb60-34"><a href="#cb60-34" aria-hidden="true" tabindex="-1"></a>        <span class="co">// link to the node instance / reference itself</span></span>
<span id="cb60-35"><a href="#cb60-35" aria-hidden="true" tabindex="-1"></a>        <span class="bu">Map</span><span class="op">&lt;</span>T<span class="op">,</span> <span class="bu">Node</span><span class="op">&gt;</span> cache <span class="op">=</span> <span class="kw">new</span> <span class="bu">HashMap</span><span class="op">&lt;&gt;();</span></span>
<span id="cb60-36"><a href="#cb60-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb60-37"><a href="#cb60-37" aria-hidden="true" tabindex="-1"></a>        <span class="co">// simple constructor producer which initializes a graph node with</span></span>
<span id="cb60-38"><a href="#cb60-38" aria-hidden="true" tabindex="-1"></a>        <span class="co">// correct value, like incoming edges, and the children</span></span>
<span id="cb60-39"><a href="#cb60-39" aria-hidden="true" tabindex="-1"></a>        Function<span class="op">&lt;</span>T<span class="op">,</span> <span class="bu">Node</span><span class="op">&gt;</span> constructor <span class="op">=</span> <span class="op">(</span>T value<span class="op">)</span> <span class="op">-&gt;</span> <span class="op">{</span></span>
<span id="cb60-40"><a href="#cb60-40" aria-hidden="true" tabindex="-1"></a>            <span class="bu">Node</span> node <span class="op">=</span> <span class="kw">new</span> GraphNode<span class="op">&lt;&gt;();</span></span>
<span id="cb60-41"><a href="#cb60-41" aria-hidden="true" tabindex="-1"></a>            node<span class="op">.</span><span class="fu">children</span> <span class="op">=</span> <span class="kw">new</span> <span class="bu">ArrayList</span><span class="op">&lt;&gt;();</span></span>
<span id="cb60-42"><a href="#cb60-42" aria-hidden="true" tabindex="-1"></a>            node<span class="op">.</span><span class="fu">value</span> <span class="op">=</span> value<span class="op">;</span></span>
<span id="cb60-43"><a href="#cb60-43" aria-hidden="true" tabindex="-1"></a>            node<span class="op">.</span><span class="fu">incoming</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb60-44"><a href="#cb60-44" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> node<span class="op">;</span></span>
<span id="cb60-45"><a href="#cb60-45" aria-hidden="true" tabindex="-1"></a>        <span class="op">};</span></span>
<span id="cb60-46"><a href="#cb60-46" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb60-47"><a href="#cb60-47" aria-hidden="true" tabindex="-1"></a>        <span class="co">// go through all the edges, and create and link the node instances</span></span>
<span id="cb60-48"><a href="#cb60-48" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span>Edge edge <span class="op">:</span> edges<span class="op">)</span> <span class="op">{</span></span>
<span id="cb60-49"><a href="#cb60-49" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>edge<span class="op">.</span><span class="fu">from</span> <span class="op">!=</span> <span class="kw">null</span> <span class="op">&amp;&amp;</span> <span class="op">!</span>cache<span class="op">.</span><span class="fu">containsKey</span><span class="op">(</span>edge<span class="op">.</span><span class="fu">from</span><span class="op">))</span> <span class="op">{</span></span>
<span id="cb60-50"><a href="#cb60-50" aria-hidden="true" tabindex="-1"></a>                <span class="co">// construct the node instance for the `from` edge</span></span>
<span id="cb60-51"><a href="#cb60-51" aria-hidden="true" tabindex="-1"></a>                cache<span class="op">.</span><span class="fu">put</span><span class="op">(</span>edge<span class="op">.</span><span class="fu">from</span><span class="op">,</span> constructor<span class="op">.</span><span class="fu">apply</span><span class="op">(</span>edge<span class="op">.</span><span class="fu">from</span><span class="op">));</span></span>
<span id="cb60-52"><a href="#cb60-52" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb60-53"><a href="#cb60-53" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb60-54"><a href="#cb60-54" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>edge<span class="op">.</span><span class="fu">to</span> <span class="op">!=</span> <span class="kw">null</span> <span class="op">&amp;&amp;</span> <span class="op">!</span>cache<span class="op">.</span><span class="fu">containsKey</span><span class="op">(</span>edge<span class="op">.</span><span class="fu">to</span><span class="op">))</span> <span class="op">{</span></span>
<span id="cb60-55"><a href="#cb60-55" aria-hidden="true" tabindex="-1"></a>                <span class="co">// construct the node instance for the `to` edge</span></span>
<span id="cb60-56"><a href="#cb60-56" aria-hidden="true" tabindex="-1"></a>                cache<span class="op">.</span><span class="fu">put</span><span class="op">(</span>edge<span class="op">.</span><span class="fu">to</span><span class="op">,</span> constructor<span class="op">.</span><span class="fu">apply</span><span class="op">(</span>edge<span class="op">.</span><span class="fu">to</span><span class="op">));</span></span>
<span id="cb60-57"><a href="#cb60-57" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb60-58"><a href="#cb60-58" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb60-59"><a href="#cb60-59" aria-hidden="true" tabindex="-1"></a>            <span class="co">// extract the node `from`, from the cache, `from` link is mandatory</span></span>
<span id="cb60-60"><a href="#cb60-60" aria-hidden="true" tabindex="-1"></a>            <span class="co">// and will always be present, since it represents the source node,</span></span>
<span id="cb60-61"><a href="#cb60-61" aria-hidden="true" tabindex="-1"></a>            <span class="co">// while `to` is optional since an outgoing connection might or</span></span>
<span id="cb60-62"><a href="#cb60-62" aria-hidden="true" tabindex="-1"></a>            <span class="co">// might not be present.</span></span>
<span id="cb60-63"><a href="#cb60-63" aria-hidden="true" tabindex="-1"></a>            <span class="bu">Node</span> current <span class="op">=</span> cache<span class="op">.</span><span class="fu">get</span><span class="op">(</span>edge<span class="op">.</span><span class="fu">from</span><span class="op">);</span></span>
<span id="cb60-64"><a href="#cb60-64" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb60-65"><a href="#cb60-65" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>edge<span class="op">.</span><span class="fu">to</span> <span class="op">!=</span> <span class="kw">null</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb60-66"><a href="#cb60-66" aria-hidden="true" tabindex="-1"></a>                <span class="co">// when the edge connection to is valid, we link it to the</span></span>
<span id="cb60-67"><a href="#cb60-67" aria-hidden="true" tabindex="-1"></a>                <span class="co">// instance / reference of the node which represents the edge.to</span></span>
<span id="cb60-68"><a href="#cb60-68" aria-hidden="true" tabindex="-1"></a>                <span class="bu">Node</span> child <span class="op">=</span> cache<span class="op">.</span><span class="fu">get</span><span class="op">(</span>edge<span class="op">.</span><span class="fu">to</span><span class="op">);</span></span>
<span id="cb60-69"><a href="#cb60-69" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb60-70"><a href="#cb60-70" aria-hidden="true" tabindex="-1"></a>                <span class="co">// add the child node to the current edge.from children list,</span></span>
<span id="cb60-71"><a href="#cb60-71" aria-hidden="true" tabindex="-1"></a>                <span class="co">// this represents the forward, outbound connections of edge.from</span></span>
<span id="cb60-72"><a href="#cb60-72" aria-hidden="true" tabindex="-1"></a>                current<span class="op">.</span><span class="fu">children</span><span class="op">.</span><span class="fu">add</span><span class="op">(</span>child<span class="op">);</span></span>
<span id="cb60-73"><a href="#cb60-73" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb60-74"><a href="#cb60-74" aria-hidden="true" tabindex="-1"></a>                <span class="co">// make sure to increment the incoming edges for the child, as</span></span>
<span id="cb60-75"><a href="#cb60-75" aria-hidden="true" tabindex="-1"></a>                <span class="co">// we have added a new incoming edge</span></span>
<span id="cb60-76"><a href="#cb60-76" aria-hidden="true" tabindex="-1"></a>                child<span class="op">.</span><span class="fu">incoming</span><span class="op">++;</span></span>
<span id="cb60-77"><a href="#cb60-77" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb60-78"><a href="#cb60-78" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb60-79"><a href="#cb60-79" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb60-80"><a href="#cb60-80" aria-hidden="true" tabindex="-1"></a>        <span class="co">// get the values from the cache map, which are all the nodes in the</span></span>
<span id="cb60-81"><a href="#cb60-81" aria-hidden="true" tabindex="-1"></a>        <span class="co">// graph, return this as the final result of the constructed graph</span></span>
<span id="cb60-82"><a href="#cb60-82" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> cache<span class="op">.</span><span class="fu">values</span><span class="op">().</span><span class="fu">stream</span><span class="op">().</span><span class="fu">collect</span><span class="op">(</span>Collectors<span class="op">.</span><span class="fu">toList</span><span class="op">());</span></span>
<span id="cb60-83"><a href="#cb60-83" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<h2 id="traversing">Traversing</h2>
<p>Graphs have two major traversal approaches, similarly to trees, we
can either use:</p>
<ul>
<li><p>Breadth first - where each level of the graph is visited, before
the next one is, then drill to the next immediate level and repeat,
algorithm is based off of storing the nodes in a queue</p></li>
<li><p>Depth first - where each level is visited in depth, down to the
very last link, before neighbor levels are considered, algorithm is
based off of storing the nodes in a stack</p></li>
</ul>
<p>In the examples below the input list of graph nodes
<code>List&lt;Node&gt;</code> represent a set of input nodes from which
to start the traversal, that list could simply be the entire list of
nodes, which belong to the graph, or simply a small set of pre-selected
ones, for example, select only the ones without incoming edges, and
traverse from them in depth or breadth</p>
<h3 id="bfs">BFS</h3>
<p>Similarly to trees, however not as widely used with tree traversal,
BFS is very much a cornerstone traversal approach for graphs, this
approach inspects each immediate graph neighbors before going down to
each of their children, inspecting a level of depth at a time</p>
<p>Note that is quite important when a node is marked as visited in
either BFS or DFS traversals, this is due to how the traversal works,
while in the recursive approach we have more freedom, in the iterative
BFS approach the visited mark must be done when the child node is added
to the queue.</p>
<p>This detail, of when the node is marked as visited comes in again
when we discuss the Dijkstra algorithm, where the visited mark is done
in a different position in the iterative process, and it is very
important to take a note of that. The early or late marking of a node as
visited, could drastically change the algorithm, the problem and the
solution.</p>
<div class="sourceCode" id="cb61"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb61-1"><a href="#cb61-1" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> <span class="fu">breadth</span><span class="op">(</span><span class="bu">Queue</span><span class="op">&lt;</span><span class="bu">Node</span><span class="op">&gt;</span> queue<span class="op">,</span> <span class="bu">List</span><span class="op">&lt;</span><span class="bu">Integer</span><span class="op">&gt;</span> path<span class="op">,</span> <span class="bu">Set</span><span class="op">&lt;</span><span class="bu">Node</span><span class="op">&gt;</span> visited<span class="op">)</span> <span class="op">{</span></span>
<span id="cb61-2"><a href="#cb61-2" aria-hidden="true" tabindex="-1"></a>        <span class="co">// remove the current element from the queue</span></span>
<span id="cb61-3"><a href="#cb61-3" aria-hidden="true" tabindex="-1"></a>        <span class="bu">Node</span> node <span class="op">=</span> queue<span class="op">.</span><span class="fu">remove</span><span class="op">();</span></span>
<span id="cb61-4"><a href="#cb61-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-5"><a href="#cb61-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>node <span class="op">==</span> <span class="kw">null</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb61-6"><a href="#cb61-6" aria-hidden="true" tabindex="-1"></a>            <span class="co">// reaching this point should not really be possible, since the</span></span>
<span id="cb61-7"><a href="#cb61-7" aria-hidden="true" tabindex="-1"></a>            <span class="co">// queue would normally not get any nil elements pushed into it</span></span>
<span id="cb61-8"><a href="#cb61-8" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span><span class="op">;</span></span>
<span id="cb61-9"><a href="#cb61-9" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb61-10"><a href="#cb61-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-11"><a href="#cb61-11" aria-hidden="true" tabindex="-1"></a>        <span class="co">// add the value of the current node to the path, before adding the</span></span>
<span id="cb61-12"><a href="#cb61-12" aria-hidden="true" tabindex="-1"></a>        <span class="co">// children to the queue</span></span>
<span id="cb61-13"><a href="#cb61-13" aria-hidden="true" tabindex="-1"></a>        path<span class="op">.</span><span class="fu">add</span><span class="op">(</span>node<span class="op">.</span><span class="fu">value</span><span class="op">);</span></span>
<span id="cb61-14"><a href="#cb61-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-15"><a href="#cb61-15" aria-hidden="true" tabindex="-1"></a>        <span class="co">// for each child of the current node</span></span>
<span id="cb61-16"><a href="#cb61-16" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="bu">Node</span> child <span class="op">:</span> node<span class="op">.</span><span class="fu">children</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb61-17"><a href="#cb61-17" aria-hidden="true" tabindex="-1"></a>            <span class="co">// before trying to go down, make sure the child is not visited already</span></span>
<span id="cb61-18"><a href="#cb61-18" aria-hidden="true" tabindex="-1"></a>            <span class="co">// could be, in case other nodes have links to this child, and have</span></span>
<span id="cb61-19"><a href="#cb61-19" aria-hidden="true" tabindex="-1"></a>            <span class="co">// been processed before</span></span>
<span id="cb61-20"><a href="#cb61-20" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(!</span>visited<span class="op">.</span><span class="fu">contains</span><span class="op">(</span>child<span class="op">))</span> <span class="op">{</span></span>
<span id="cb61-21"><a href="#cb61-21" aria-hidden="true" tabindex="-1"></a>                <span class="co">// mark the current node as visited, we want to make sure that if the</span></span>
<span id="cb61-22"><a href="#cb61-22" aria-hidden="true" tabindex="-1"></a>                <span class="co">// graph has cycles, we never pass through this again, otherwise it</span></span>
<span id="cb61-23"><a href="#cb61-23" aria-hidden="true" tabindex="-1"></a>                <span class="co">// would be added to the queue repeatedly</span></span>
<span id="cb61-24"><a href="#cb61-24" aria-hidden="true" tabindex="-1"></a>                visited<span class="op">.</span><span class="fu">add</span><span class="op">(</span>child<span class="op">);</span></span>
<span id="cb61-25"><a href="#cb61-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-26"><a href="#cb61-26" aria-hidden="true" tabindex="-1"></a>                <span class="co">// append child to the end of the queue</span></span>
<span id="cb61-27"><a href="#cb61-27" aria-hidden="true" tabindex="-1"></a>                queue<span class="op">.</span><span class="fu">add</span><span class="op">(</span>child<span class="op">);</span></span>
<span id="cb61-28"><a href="#cb61-28" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb61-29"><a href="#cb61-29" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb61-30"><a href="#cb61-30" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb61-31"><a href="#cb61-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-32"><a href="#cb61-32" aria-hidden="true" tabindex="-1"></a>    <span class="bu">List</span><span class="op">&lt;</span><span class="bu">Integer</span><span class="op">&gt;</span> <span class="fu">breadth</span><span class="op">(</span><span class="bu">List</span><span class="op">&lt;</span><span class="bu">Node</span><span class="op">&gt;</span> graph<span class="op">)</span> <span class="op">{</span></span>
<span id="cb61-33"><a href="#cb61-33" aria-hidden="true" tabindex="-1"></a>        <span class="co">// the input list graph, would contain a list of starting nodes, from</span></span>
<span id="cb61-34"><a href="#cb61-34" aria-hidden="true" tabindex="-1"></a>        <span class="co">// which we would like to start traversing the graph in breadth</span></span>
<span id="cb61-35"><a href="#cb61-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-36"><a href="#cb61-36" aria-hidden="true" tabindex="-1"></a>        <span class="co">// construct the queue firstly initialized with the input graph nodes</span></span>
<span id="cb61-37"><a href="#cb61-37" aria-hidden="true" tabindex="-1"></a>        <span class="bu">Queue</span><span class="op">&lt;</span><span class="bu">Node</span><span class="op">&gt;</span> queue <span class="op">=</span> <span class="kw">new</span> <span class="bu">LinkedList</span><span class="op">&lt;&gt;(</span>graph<span class="op">);</span></span>
<span id="cb61-38"><a href="#cb61-38" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-39"><a href="#cb61-39" aria-hidden="true" tabindex="-1"></a>        <span class="co">// hold state for visited nodes, already having been traversed over</span></span>
<span id="cb61-40"><a href="#cb61-40" aria-hidden="true" tabindex="-1"></a>        <span class="bu">Set</span><span class="op">&lt;</span><span class="bu">Node</span><span class="op">&gt;</span> visited <span class="op">=</span> <span class="kw">new</span> <span class="bu">HashSet</span><span class="op">&lt;&gt;();</span></span>
<span id="cb61-41"><a href="#cb61-41" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-42"><a href="#cb61-42" aria-hidden="true" tabindex="-1"></a>        <span class="co">// hold the nodes, in order of the way they were visited</span></span>
<span id="cb61-43"><a href="#cb61-43" aria-hidden="true" tabindex="-1"></a>        <span class="bu">List</span><span class="op">&lt;</span><span class="bu">Integer</span><span class="op">&gt;</span> result <span class="op">=</span> <span class="kw">new</span> <span class="bu">LinkedList</span><span class="op">&lt;&gt;();</span></span>
<span id="cb61-44"><a href="#cb61-44" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-45"><a href="#cb61-45" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span> <span class="op">(!</span>queue<span class="op">.</span><span class="fu">isEmpty</span><span class="op">())</span> <span class="op">{</span></span>
<span id="cb61-46"><a href="#cb61-46" aria-hidden="true" tabindex="-1"></a>            <span class="co">// pull from the queue the current element, add its children and</span></span>
<span id="cb61-47"><a href="#cb61-47" aria-hidden="true" tabindex="-1"></a>            <span class="co">// keep doing that until the queue is emtpy, meaning all nodes that</span></span>
<span id="cb61-48"><a href="#cb61-48" aria-hidden="true" tabindex="-1"></a>            <span class="co">// were reachable from the starting ones were visited at least once</span></span>
<span id="cb61-49"><a href="#cb61-49" aria-hidden="true" tabindex="-1"></a>            <span class="fu">breadth</span><span class="op">(</span>queue<span class="op">,</span> result<span class="op">,</span> visited<span class="op">);</span></span>
<span id="cb61-50"><a href="#cb61-50" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb61-51"><a href="#cb61-51" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-52"><a href="#cb61-52" aria-hidden="true" tabindex="-1"></a>        <span class="co">// return the path formed by traversing the nodes starting from the</span></span>
<span id="cb61-53"><a href="#cb61-53" aria-hidden="true" tabindex="-1"></a>        <span class="co">// input list of graph nodes</span></span>
<span id="cb61-54"><a href="#cb61-54" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> result<span class="op">;</span></span>
<span id="cb61-55"><a href="#cb61-55" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<h3 id="dfs">DFS</h3>
<p>Works very much like a DFS in trees, with the added caveat that we do
not have 2 children at most, but N children, each node is fully
inspected, down to its last leaf children, before the next one is picked
up.</p>
<div class="sourceCode" id="cb62"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb62-1"><a href="#cb62-1" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> <span class="fu">depth</span><span class="op">(</span><span class="bu">Node</span> node<span class="op">,</span> <span class="bu">List</span><span class="op">&lt;</span><span class="bu">Integer</span><span class="op">&gt;</span> path<span class="op">,</span> <span class="bu">Set</span><span class="op">&lt;</span><span class="bu">Node</span><span class="op">&gt;</span> visited<span class="op">)</span> <span class="op">{</span></span>
<span id="cb62-2"><a href="#cb62-2" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>node <span class="op">==</span> <span class="kw">null</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb62-3"><a href="#cb62-3" aria-hidden="true" tabindex="-1"></a>            <span class="co">// reaching this point should not really be possible, since children</span></span>
<span id="cb62-4"><a href="#cb62-4" aria-hidden="true" tabindex="-1"></a>            <span class="co">// array should never contain nil nodes, but add this guard case</span></span>
<span id="cb62-5"><a href="#cb62-5" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span><span class="op">;</span></span>
<span id="cb62-6"><a href="#cb62-6" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb62-7"><a href="#cb62-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb62-8"><a href="#cb62-8" aria-hidden="true" tabindex="-1"></a>        <span class="co">// add the value of the current node to the path, before adding the</span></span>
<span id="cb62-9"><a href="#cb62-9" aria-hidden="true" tabindex="-1"></a>        <span class="co">// children to the queue</span></span>
<span id="cb62-10"><a href="#cb62-10" aria-hidden="true" tabindex="-1"></a>        path<span class="op">.</span><span class="fu">add</span><span class="op">(</span>node<span class="op">.</span><span class="fu">value</span><span class="op">);</span></span>
<span id="cb62-11"><a href="#cb62-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb62-12"><a href="#cb62-12" aria-hidden="true" tabindex="-1"></a>        <span class="co">// for each child of the current node</span></span>
<span id="cb62-13"><a href="#cb62-13" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="bu">Node</span> child <span class="op">:</span> node<span class="op">.</span><span class="fu">children</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb62-14"><a href="#cb62-14" aria-hidden="true" tabindex="-1"></a>            <span class="co">// before trying to go down, make sure the child is not visited already</span></span>
<span id="cb62-15"><a href="#cb62-15" aria-hidden="true" tabindex="-1"></a>            <span class="co">// could be, in case other nodes have links to this child, and have</span></span>
<span id="cb62-16"><a href="#cb62-16" aria-hidden="true" tabindex="-1"></a>            <span class="co">// been processed before</span></span>
<span id="cb62-17"><a href="#cb62-17" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(!</span>visited<span class="op">.</span><span class="fu">contains</span><span class="op">(</span>child<span class="op">))</span> <span class="op">{</span></span>
<span id="cb62-18"><a href="#cb62-18" aria-hidden="true" tabindex="-1"></a>                <span class="co">// mark the current node as visited, we want to make sure that if the</span></span>
<span id="cb62-19"><a href="#cb62-19" aria-hidden="true" tabindex="-1"></a>                <span class="co">// node has cycles, we never pass through this again, otherwise infinite</span></span>
<span id="cb62-20"><a href="#cb62-20" aria-hidden="true" tabindex="-1"></a>                <span class="co">// recursion would occur</span></span>
<span id="cb62-21"><a href="#cb62-21" aria-hidden="true" tabindex="-1"></a>                visited<span class="op">.</span><span class="fu">add</span><span class="op">(</span>child<span class="op">);</span></span>
<span id="cb62-22"><a href="#cb62-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb62-23"><a href="#cb62-23" aria-hidden="true" tabindex="-1"></a>                <span class="co">// dive in depth for the current child</span></span>
<span id="cb62-24"><a href="#cb62-24" aria-hidden="true" tabindex="-1"></a>                <span class="fu">depth</span><span class="op">(</span>child<span class="op">,</span> path<span class="op">,</span> visited<span class="op">);</span></span>
<span id="cb62-25"><a href="#cb62-25" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb62-26"><a href="#cb62-26" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb62-27"><a href="#cb62-27" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb62-28"><a href="#cb62-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb62-29"><a href="#cb62-29" aria-hidden="true" tabindex="-1"></a>    <span class="bu">List</span><span class="op">&lt;</span><span class="bu">Integer</span><span class="op">&gt;</span> <span class="fu">depth</span><span class="op">(</span><span class="bu">List</span><span class="op">&lt;</span><span class="bu">Node</span><span class="op">&gt;</span> graph<span class="op">)</span> <span class="op">{</span></span>
<span id="cb62-30"><a href="#cb62-30" aria-hidden="true" tabindex="-1"></a>        <span class="co">// the input list graph, would contain a list of starting nodes, from</span></span>
<span id="cb62-31"><a href="#cb62-31" aria-hidden="true" tabindex="-1"></a>        <span class="co">// which we would like to start traversing the graph in depth</span></span>
<span id="cb62-32"><a href="#cb62-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb62-33"><a href="#cb62-33" aria-hidden="true" tabindex="-1"></a>        <span class="co">// hold state for visited nodes, already having been traversed over</span></span>
<span id="cb62-34"><a href="#cb62-34" aria-hidden="true" tabindex="-1"></a>        <span class="bu">Set</span><span class="op">&lt;</span><span class="bu">Node</span><span class="op">&gt;</span> visited <span class="op">=</span> <span class="kw">new</span> <span class="bu">HashSet</span><span class="op">&lt;&gt;();</span></span>
<span id="cb62-35"><a href="#cb62-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb62-36"><a href="#cb62-36" aria-hidden="true" tabindex="-1"></a>        <span class="co">// hold the nodes, in order of the way they were visited</span></span>
<span id="cb62-37"><a href="#cb62-37" aria-hidden="true" tabindex="-1"></a>        <span class="bu">List</span><span class="op">&lt;</span><span class="bu">Integer</span><span class="op">&gt;</span> result <span class="op">=</span> <span class="kw">new</span> <span class="bu">LinkedList</span><span class="op">&lt;&gt;();</span></span>
<span id="cb62-38"><a href="#cb62-38" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb62-39"><a href="#cb62-39" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="bu">Node</span> node <span class="op">:</span> graph<span class="op">)</span> <span class="op">{</span></span>
<span id="cb62-40"><a href="#cb62-40" aria-hidden="true" tabindex="-1"></a>            <span class="co">// go through all nodes of the graph, dive depth first for each node</span></span>
<span id="cb62-41"><a href="#cb62-41" aria-hidden="true" tabindex="-1"></a>            <span class="fu">depth</span><span class="op">(</span>node<span class="op">,</span> result<span class="op">,</span> visited<span class="op">);</span></span>
<span id="cb62-42"><a href="#cb62-42" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb62-43"><a href="#cb62-43" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> result<span class="op">;</span></span>
<span id="cb62-44"><a href="#cb62-44" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<h3 id="dijkstra">Dijkstra</h3>
<p>A way to find the shortest path between two points in a weighted
directed graph (which might have cycles). Where all edges must have
positive values. Note that a side effect of Dijkstra is that it finds
the shortest paths from the <code>start</code> node to any other node
that can be reached by start, and one of them being <code>end</code> (if
start and end have path or link between each other of course).</p>
<p>The way the Dijkstra works to find the shortest path, is by
maintaining 4 separate structures</p>
<ul>
<li><p>priority queue / min heap - this is the core of the Dijkstra
algorithm, we push nodes, and their absolute cost / path in that min
heap, by the nature of the min heap, the nodes with the least cost /
weight will be at the very top of the heap, pulling from it means we
always pull the best cost node</p></li>
<li><p>distances - maps a node, actually a unique
<code>node.value,</code> and a min path to that node, in the end of the
algorithm we would have the shortest paths to all nodes in the graph
from the starting position, in the distances map</p></li>
<li><p>previous - mirrored structure of distance, where for each min
distance for a given node the previous node from where this min distance
was achieved is stored in, we use previous to backtrack from where we
came to achieve the shortest path, and thus can generate all the pahts
from all nodes to the starting node (if the starting node had a path to
them of course)</p></li>
<li><p>visited - nodes, which are pulled from the priority queue are
marked as visited, to avoid re-visiting them, the first time a node is
visited, is also the first time we extract it from the min heap, meaning
it is going to be the one with the min weight</p></li>
</ul>
<p>What is crucial to note is that the min heap can contain the same
node i.e <code>node.value</code> more than once, but with different
weights, since we can reach that node from many places, each time we do
find a better cost weight (compared to the current
<code>distance[node.value]</code> weight) we then push to the heap.</p>
<p>Naturally because it is a min heap, the best cost
<code>WeightNode</code> would be found near the top of the heap, when we
pull a node that is not visited for the first time, we always pull the
best <code>WeightNode</code> for that node (even if there are
duplicates, the others would have worse cost, and will be deeper in the
heap), we then mark the node by <code>node.value</code> as visited.</p>
<p>Note that unlike DFS and BFS, we do not mark the nodes when we first
encounter them as children, but we mark them as visited only when we
pull them from the queue, this guarantees that by the time we pull the
node, all paths to that node would have been investigated, best cost
weight would have been found. And naturally we would pull the best cost
from the min heap for that node / <code>node.value</code>. After we pull
a node we have to check if it has been visited, having been visited
already means that the best cost for that node was pulled, and
processed, we can simply <code>continue</code> (this handles the
duplicates with worse costs / weights, by simply removing them from the
queue without taking any action, and just skips to the next iteration in
the algorithm)</p>
<p>The two main loop ending conditions for the Dijkstra are 2, these do
not tell us if we have reached the end node target, however they are
used to know when to stop traversing the graph</p>
<ul>
<li>all nodes - either the visited structure contains the same number of
nodes as the entire graph, meaning we have visited all possible nodes,
this might not obtain if we have sub-graphs with no connections, and the
start node is in one sub-graph, the end-node in another, we would never
reach the 2-nd sub-graph nodes, meaning
<code>visitedGraphNodes.size</code> would never equal
<code>totalGraphNodes.size</code></li>
<li>min heap empty - priority queue is empty, this would happen in case
we pop every possible node that we could have reached from the starting
position node, by that time we still do not know if we have actually
reached end, but at least we have gone over all possible paths that
could have been traversed starting from the <code>starting</code>
node</li>
</ul>
<p>The final stage, we try to reconstruct the path from end to start
backwards, using the previous structure, we can check if we have
mappings following the previous, if we reach <code>start</code> then we
had a link from <code>end</code> to <code>start</code>, otherwise no
path between the two targets exists.</p>
<div class="sourceCode" id="cb63"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb63-1"><a href="#cb63-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">// base utility weight node class which extends from the base graph node class,</span></span>
<span id="cb63-2"><a href="#cb63-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">// used to maintain and track the absolute weight of the graph nodes while</span></span>
<span id="cb63-3"><a href="#cb63-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">// executing Dijkstra, in a priority queue</span></span>
<span id="cb63-4"><a href="#cb63-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">class</span> WeightNode <span class="kw">extends</span> <span class="bu">Node</span> <span class="kw">implements</span> <span class="bu">Comparable</span><span class="op">&lt;</span>WeightNode<span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb63-5"><a href="#cb63-5" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> weight <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb63-6"><a href="#cb63-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb63-7"><a href="#cb63-7" aria-hidden="true" tabindex="-1"></a>        <span class="co">// create a weight node from a graph node, by cloning over the</span></span>
<span id="cb63-8"><a href="#cb63-8" aria-hidden="true" tabindex="-1"></a>        <span class="co">// properties of the base node</span></span>
<span id="cb63-9"><a href="#cb63-9" aria-hidden="true" tabindex="-1"></a>        <span class="kw">public</span> <span class="fu">WeightNode</span><span class="op">(</span><span class="bu">Node</span> node<span class="op">,</span> <span class="dt">int</span> weight<span class="op">)</span> <span class="op">{</span></span>
<span id="cb63-10"><a href="#cb63-10" aria-hidden="true" tabindex="-1"></a>            <span class="kw">this</span><span class="op">.</span><span class="fu">weight</span> <span class="op">=</span> weight<span class="op">;</span></span>
<span id="cb63-11"><a href="#cb63-11" aria-hidden="true" tabindex="-1"></a>            <span class="kw">this</span><span class="op">.</span><span class="fu">value</span> <span class="op">=</span> node<span class="op">.</span><span class="fu">value</span><span class="op">;</span></span>
<span id="cb63-12"><a href="#cb63-12" aria-hidden="true" tabindex="-1"></a>            <span class="kw">this</span><span class="op">.</span><span class="fu">children</span> <span class="op">=</span> node<span class="op">.</span><span class="fu">children</span><span class="op">;</span></span>
<span id="cb63-13"><a href="#cb63-13" aria-hidden="true" tabindex="-1"></a>            <span class="kw">this</span><span class="op">.</span><span class="fu">incoming</span> <span class="op">=</span> node<span class="op">.</span><span class="fu">incoming</span><span class="op">;</span></span>
<span id="cb63-14"><a href="#cb63-14" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb63-15"><a href="#cb63-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb63-16"><a href="#cb63-16" aria-hidden="true" tabindex="-1"></a>        <span class="at">@Override</span></span>
<span id="cb63-17"><a href="#cb63-17" aria-hidden="true" tabindex="-1"></a>        <span class="kw">public</span> <span class="dt">int</span> <span class="fu">compareTo</span><span class="op">(</span>WeightNode o<span class="op">)</span> <span class="op">{</span></span>
<span id="cb63-18"><a href="#cb63-18" aria-hidden="true" tabindex="-1"></a>            <span class="co">// required for the priority queue, we care only about comparing the</span></span>
<span id="cb63-19"><a href="#cb63-19" aria-hidden="true" tabindex="-1"></a>            <span class="co">// total weight, or cost of each node.</span></span>
<span id="cb63-20"><a href="#cb63-20" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="kw">this</span><span class="op">.</span><span class="fu">weight</span> <span class="op">-</span> o<span class="op">.</span><span class="fu">weight</span><span class="op">;</span></span>
<span id="cb63-21"><a href="#cb63-21" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb63-22"><a href="#cb63-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb63-23"><a href="#cb63-23" aria-hidden="true" tabindex="-1"></a>        <span class="at">@Override</span></span>
<span id="cb63-24"><a href="#cb63-24" aria-hidden="true" tabindex="-1"></a>        <span class="kw">public</span> <span class="dt">boolean</span> <span class="fu">equals</span><span class="op">(</span><span class="bu">Object</span> obj<span class="op">)</span> <span class="op">{</span></span>
<span id="cb63-25"><a href="#cb63-25" aria-hidden="true" tabindex="-1"></a>            WeightNode node <span class="op">=</span> <span class="op">(</span>WeightNode<span class="op">)</span> obj<span class="op">;</span></span>
<span id="cb63-26"><a href="#cb63-26" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="kw">this</span><span class="op">.</span><span class="fu">value</span><span class="op">.</span><span class="fu">equals</span><span class="op">(</span>node<span class="op">.</span><span class="fu">value</span><span class="op">);</span></span>
<span id="cb63-27"><a href="#cb63-27" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb63-28"><a href="#cb63-28" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb63-29"><a href="#cb63-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb63-30"><a href="#cb63-30" aria-hidden="true" tabindex="-1"></a>    <span class="bu">List</span><span class="op">&lt;</span><span class="bu">String</span><span class="op">&gt;</span> <span class="fu">computeShortestPath</span><span class="op">(</span><span class="bu">List</span><span class="op">&lt;</span><span class="bu">Node</span><span class="op">&gt;</span> nodes<span class="op">,</span> <span class="bu">Node</span> start<span class="op">,</span> <span class="bu">Node</span> end<span class="op">)</span> <span class="op">{</span></span>
<span id="cb63-31"><a href="#cb63-31" aria-hidden="true" tabindex="-1"></a>        <span class="co">// this is the cornerstone of this algorithm, this is a min heap, which orders the nodes such that the ones with smallest cost</span></span>
<span id="cb63-32"><a href="#cb63-32" aria-hidden="true" tabindex="-1"></a>        <span class="co">// / weight are at the front of the queue, remember that the same node i.e. node.value can be added in this heap more than once,</span></span>
<span id="cb63-33"><a href="#cb63-33" aria-hidden="true" tabindex="-1"></a>        <span class="co">// but with different costs, since we might reach that node from multiple other nodes, but since we work with a min heap, these</span></span>
<span id="cb63-34"><a href="#cb63-34" aria-hidden="true" tabindex="-1"></a>        <span class="co">// WeightNodes would be ordered by cost, so we will always pull the smallest node by cost first.</span></span>
<span id="cb63-35"><a href="#cb63-35" aria-hidden="true" tabindex="-1"></a>        <span class="bu">PriorityQueue</span><span class="op">&lt;</span>WeightNode<span class="op">&gt;</span> heap <span class="op">=</span> <span class="kw">new</span> <span class="bu">PriorityQueue</span><span class="op">&lt;&gt;();</span></span>
<span id="cb63-36"><a href="#cb63-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb63-37"><a href="#cb63-37" aria-hidden="true" tabindex="-1"></a>        <span class="co">// visited holds nodes by identifier, that is important, since the heap might contain the same &#39;node&#39; multiple times with</span></span>
<span id="cb63-38"><a href="#cb63-38" aria-hidden="true" tabindex="-1"></a>        <span class="co">// different costs</span></span>
<span id="cb63-39"><a href="#cb63-39" aria-hidden="true" tabindex="-1"></a>        <span class="bu">Set</span><span class="op">&lt;</span><span class="bu">String</span><span class="op">&gt;</span> visited <span class="op">=</span> <span class="kw">new</span> <span class="bu">HashSet</span><span class="op">&lt;&gt;();</span></span>
<span id="cb63-40"><a href="#cb63-40" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb63-41"><a href="#cb63-41" aria-hidden="true" tabindex="-1"></a>        <span class="co">// distances from a given node / node.value so far, these are the total accumulated distances, and always represent the minimum</span></span>
<span id="cb63-42"><a href="#cb63-42" aria-hidden="true" tabindex="-1"></a>        <span class="co">// distance to the specific node, or more precisely the shortest distance to each node id &lt;-&gt; node.value</span></span>
<span id="cb63-43"><a href="#cb63-43" aria-hidden="true" tabindex="-1"></a>        <span class="bu">Map</span><span class="op">&lt;</span><span class="bu">String</span><span class="op">,</span> <span class="bu">Integer</span><span class="op">&gt;</span> distances <span class="op">=</span> <span class="kw">new</span> <span class="bu">HashMap</span><span class="op">&lt;&gt;();</span></span>
<span id="cb63-44"><a href="#cb63-44" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb63-45"><a href="#cb63-45" aria-hidden="true" tabindex="-1"></a>        <span class="co">// a mirror of the distances map, it tells us from where we came to achieve that min distance for a given node, they are both</span></span>
<span id="cb63-46"><a href="#cb63-46" aria-hidden="true" tabindex="-1"></a>        <span class="co">// updated together always, this way later on we can use previous to backtrack the shortest path</span></span>
<span id="cb63-47"><a href="#cb63-47" aria-hidden="true" tabindex="-1"></a>        <span class="bu">Map</span><span class="op">&lt;</span><span class="bu">String</span><span class="op">,</span> <span class="bu">Node</span><span class="op">&gt;</span> previous <span class="op">=</span> <span class="kw">new</span> <span class="bu">HashMap</span><span class="op">&lt;&gt;();</span></span>
<span id="cb63-48"><a href="#cb63-48" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb63-49"><a href="#cb63-49" aria-hidden="true" tabindex="-1"></a>        <span class="co">// nodes are identified by their value, that is like an id for a node, so update the initial distances, and previous, as well as</span></span>
<span id="cb63-50"><a href="#cb63-50" aria-hidden="true" tabindex="-1"></a>        <span class="co">// the heap, which at the start would contain the &#39;start&#39; node we want to start from. The cost to the current start node is</span></span>
<span id="cb63-51"><a href="#cb63-51" aria-hidden="true" tabindex="-1"></a>        <span class="co">// obviously zero, add this as a 0 weight node to the heap</span></span>
<span id="cb63-52"><a href="#cb63-52" aria-hidden="true" tabindex="-1"></a>        distances<span class="op">.</span><span class="fu">put</span><span class="op">(</span>start<span class="op">.</span><span class="fu">value</span><span class="op">,</span> <span class="dv">0</span><span class="op">);</span></span>
<span id="cb63-53"><a href="#cb63-53" aria-hidden="true" tabindex="-1"></a>        previous<span class="op">.</span><span class="fu">put</span><span class="op">(</span>start<span class="op">.</span><span class="fu">value</span><span class="op">,</span> <span class="kw">null</span><span class="op">);</span></span>
<span id="cb63-54"><a href="#cb63-54" aria-hidden="true" tabindex="-1"></a>        heap<span class="op">.</span><span class="fu">add</span><span class="op">(</span><span class="kw">new</span> <span class="fu">WeightNode</span><span class="op">(</span>start<span class="op">,</span> <span class="dv">0</span><span class="op">));</span></span>
<span id="cb63-55"><a href="#cb63-55" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb63-56"><a href="#cb63-56" aria-hidden="true" tabindex="-1"></a>        <span class="co">// loop until we see all nodes in the graph, this is the very basic exit condition, it might not obtain, if we have sub-graphs</span></span>
<span id="cb63-57"><a href="#cb63-57" aria-hidden="true" tabindex="-1"></a>        <span class="co">// that have no connections between each other in the main graph, but the heap -&gt; break would be our backup exit strategy</span></span>
<span id="cb63-58"><a href="#cb63-58" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span> <span class="op">(</span>visited<span class="op">.</span><span class="fu">size</span><span class="op">()</span> <span class="op">&lt;</span> nodes<span class="op">.</span><span class="fu">size</span><span class="op">())</span> <span class="op">{</span></span>
<span id="cb63-59"><a href="#cb63-59" aria-hidden="true" tabindex="-1"></a>            <span class="co">// it is possible for the queue to become empty, before all nodes in the graph are visited, one way this could happen is if</span></span>
<span id="cb63-60"><a href="#cb63-60" aria-hidden="true" tabindex="-1"></a>            <span class="co">// we have two sub-graphs, part of the main graph, which have no connections between each other</span></span>
<span id="cb63-61"><a href="#cb63-61" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>heap<span class="op">.</span><span class="fu">isEmpty</span><span class="op">())</span> <span class="op">{</span></span>
<span id="cb63-62"><a href="#cb63-62" aria-hidden="true" tabindex="-1"></a>                <span class="cf">break</span><span class="op">;</span></span>
<span id="cb63-63"><a href="#cb63-63" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb63-64"><a href="#cb63-64" aria-hidden="true" tabindex="-1"></a>            <span class="co">// pull the current shortest path node, from the priority queue / min heap, in this case, the heap is sorted based on the</span></span>
<span id="cb63-65"><a href="#cb63-65" aria-hidden="true" tabindex="-1"></a>            <span class="co">// cost of the weight node</span></span>
<span id="cb63-66"><a href="#cb63-66" aria-hidden="true" tabindex="-1"></a>            WeightNode node <span class="op">=</span> heap<span class="op">.</span><span class="fu">remove</span><span class="op">();</span></span>
<span id="cb63-67"><a href="#cb63-67" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb63-68"><a href="#cb63-68" aria-hidden="true" tabindex="-1"></a>            <span class="co">// we can check if it has been visited before first, based on the value of the node, if it has it means that it was present</span></span>
<span id="cb63-69"><a href="#cb63-69" aria-hidden="true" tabindex="-1"></a>            <span class="co">// already in the heap with a smaller total cost / weight, so any further presence of the same node would be with higher</span></span>
<span id="cb63-70"><a href="#cb63-70" aria-hidden="true" tabindex="-1"></a>            <span class="co">// cost / weight we do not want to consider it</span></span>
<span id="cb63-71"><a href="#cb63-71" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>visited<span class="op">.</span><span class="fu">contains</span><span class="op">(</span>node<span class="op">.</span><span class="fu">value</span><span class="op">))</span> <span class="op">{</span></span>
<span id="cb63-72"><a href="#cb63-72" aria-hidden="true" tabindex="-1"></a>                <span class="cf">continue</span><span class="op">;</span></span>
<span id="cb63-73"><a href="#cb63-73" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb63-74"><a href="#cb63-74" aria-hidden="true" tabindex="-1"></a>            <span class="co">// add / mark the current node as visited, reaching here means the current node was not visited so far, meaning this is the</span></span>
<span id="cb63-75"><a href="#cb63-75" aria-hidden="true" tabindex="-1"></a>            <span class="co">// first time we pull it from the heap, meaning we are pulling the one with the smallest cost, remember the heap might</span></span>
<span id="cb63-76"><a href="#cb63-76" aria-hidden="true" tabindex="-1"></a>            <span class="co">// contain multiple nodes with the same value, but different &#39;costs&#39;, due to the fact that in a graph we might reach the</span></span>
<span id="cb63-77"><a href="#cb63-77" aria-hidden="true" tabindex="-1"></a>            <span class="co">// same &#39;node&#39; from multiple parent nodes. By saying &#39;node&#39; we really mean &#39;node.value&#39; - that is the identifier for a node</span></span>
<span id="cb63-78"><a href="#cb63-78" aria-hidden="true" tabindex="-1"></a>            visited<span class="op">.</span><span class="fu">add</span><span class="op">(</span>node<span class="op">.</span><span class="fu">value</span><span class="op">);</span></span>
<span id="cb63-79"><a href="#cb63-79" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb63-80"><a href="#cb63-80" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> <span class="op">(</span><span class="bu">Node</span> child <span class="op">:</span> node<span class="op">.</span><span class="fu">children</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb63-81"><a href="#cb63-81" aria-hidden="true" tabindex="-1"></a>                <span class="co">// extract the current path to the current child so far, or default to some big value, careful, we are not using</span></span>
<span id="cb63-82"><a href="#cb63-82" aria-hidden="true" tabindex="-1"></a>                <span class="co">// INT_MAX, due to the fact that it might overflow if we add anything more than 0 to it</span></span>
<span id="cb63-83"><a href="#cb63-83" aria-hidden="true" tabindex="-1"></a>                <span class="bu">Integer</span> current <span class="op">=</span> distances<span class="op">.</span><span class="fu">getOrDefault</span><span class="op">(</span>child<span class="op">.</span><span class="fu">value</span><span class="op">,</span> <span class="dv">9999</span><span class="op">);</span></span>
<span id="cb63-84"><a href="#cb63-84" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb63-85"><a href="#cb63-85" aria-hidden="true" tabindex="-1"></a>                <span class="co">// compute the &#39;would be&#39; distance from the current node to the current child, this is the cost of the current node so</span></span>
<span id="cb63-86"><a href="#cb63-86" aria-hidden="true" tabindex="-1"></a>                <span class="co">// far + the weight cost of the current child, care with overflow, if using INT_MAX. The method `getWeightCost`, simply</span></span>
<span id="cb63-87"><a href="#cb63-87" aria-hidden="true" tabindex="-1"></a>                <span class="co">// returns the cost / edge value from the current `node` to the `child`</span></span>
<span id="cb63-88"><a href="#cb63-88" aria-hidden="true" tabindex="-1"></a>                <span class="bu">Integer</span> possible <span class="op">=</span> distances<span class="op">.</span><span class="fu">getOrDefault</span><span class="op">(</span>node<span class="op">.</span><span class="fu">value</span><span class="op">,</span> <span class="dv">9999</span><span class="op">)</span> <span class="op">+</span> node<span class="op">.</span><span class="fu">getWeightCost</span><span class="op">(</span>child<span class="op">);</span></span>
<span id="cb63-89"><a href="#cb63-89" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb63-90"><a href="#cb63-90" aria-hidden="true" tabindex="-1"></a>                <span class="co">// in case the possible new distance is actually smaller than the distance stored so far, we update the distance stored</span></span>
<span id="cb63-91"><a href="#cb63-91" aria-hidden="true" tabindex="-1"></a>                <span class="co">// so far, update the previous node we come from, and add the child to the heap</span></span>
<span id="cb63-92"><a href="#cb63-92" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> <span class="op">(</span>possible <span class="op">&lt;</span> current<span class="op">)</span> <span class="op">{</span></span>
<span id="cb63-93"><a href="#cb63-93" aria-hidden="true" tabindex="-1"></a>                    <span class="co">// update from which node we came to the current child, since we found better / lower cost path value</span></span>
<span id="cb63-94"><a href="#cb63-94" aria-hidden="true" tabindex="-1"></a>                    previous<span class="op">.</span><span class="fu">put</span><span class="op">(</span>child<span class="op">.</span><span class="fu">value</span><span class="op">,</span> node<span class="op">);</span></span>
<span id="cb63-95"><a href="#cb63-95" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb63-96"><a href="#cb63-96" aria-hidden="true" tabindex="-1"></a>                    <span class="co">// update the distances to the current child node as we have found shorter path to it than what we had so far</span></span>
<span id="cb63-97"><a href="#cb63-97" aria-hidden="true" tabindex="-1"></a>                    distances<span class="op">.</span><span class="fu">put</span><span class="op">(</span>child<span class="op">.</span><span class="fu">value</span><span class="op">,</span> possible<span class="op">);</span></span>
<span id="cb63-98"><a href="#cb63-98" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb63-99"><a href="#cb63-99" aria-hidden="true" tabindex="-1"></a>                    <span class="co">// every time we find path to a given node which is shorter (so far) we add it to the heap, it would be &#39;sorted&#39;</span></span>
<span id="cb63-100"><a href="#cb63-100" aria-hidden="true" tabindex="-1"></a>                    <span class="co">// based on it&#39;s weight into the heap, note we add the total &#39;weight&#39; not just the &#39;child.weight&#39;</span></span>
<span id="cb63-101"><a href="#cb63-101" aria-hidden="true" tabindex="-1"></a>                    heap<span class="op">.</span><span class="fu">add</span><span class="op">(</span><span class="kw">new</span> <span class="fu">WeightNode</span><span class="op">(</span>child<span class="op">,</span> possible<span class="op">));</span></span>
<span id="cb63-102"><a href="#cb63-102" aria-hidden="true" tabindex="-1"></a>                <span class="op">}</span></span>
<span id="cb63-103"><a href="#cb63-103" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb63-104"><a href="#cb63-104" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb63-105"><a href="#cb63-105" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb63-106"><a href="#cb63-106" aria-hidden="true" tabindex="-1"></a>        <span class="co">// collect the path from start - end</span></span>
<span id="cb63-107"><a href="#cb63-107" aria-hidden="true" tabindex="-1"></a>        <span class="bu">List</span><span class="op">&lt;</span><span class="bu">String</span><span class="op">&gt;</span> path <span class="op">=</span> <span class="kw">new</span> <span class="bu">LinkedList</span><span class="op">&lt;&gt;();</span></span>
<span id="cb63-108"><a href="#cb63-108" aria-hidden="true" tabindex="-1"></a>        <span class="bu">Node</span> target <span class="op">=</span> end<span class="op">;</span></span>
<span id="cb63-109"><a href="#cb63-109" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb63-110"><a href="#cb63-110" aria-hidden="true" tabindex="-1"></a>        <span class="cf">do</span> <span class="op">{</span></span>
<span id="cb63-111"><a href="#cb63-111" aria-hidden="true" tabindex="-1"></a>            <span class="co">// starting off from the end node, track back using the previous map, which tells us from where we came to achieve the</span></span>
<span id="cb63-112"><a href="#cb63-112" aria-hidden="true" tabindex="-1"></a>            <span class="co">// current path, remember previous and distances were updated together meaning previous contains the shortest cost / path to</span></span>
<span id="cb63-113"><a href="#cb63-113" aria-hidden="true" tabindex="-1"></a>            <span class="co">// a given node / node.value</span></span>
<span id="cb63-114"><a href="#cb63-114" aria-hidden="true" tabindex="-1"></a>            path<span class="op">.</span><span class="fu">add</span><span class="op">(</span>target<span class="op">.</span><span class="fu">value</span><span class="op">);</span></span>
<span id="cb63-115"><a href="#cb63-115" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb63-116"><a href="#cb63-116" aria-hidden="true" tabindex="-1"></a>            <span class="co">// move backwards to previous node</span></span>
<span id="cb63-117"><a href="#cb63-117" aria-hidden="true" tabindex="-1"></a>            target <span class="op">=</span> previous<span class="op">.</span><span class="fu">get</span><span class="op">(</span>target<span class="op">.</span><span class="fu">value</span><span class="op">);</span></span>
<span id="cb63-118"><a href="#cb63-118" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span> <span class="cf">while</span> <span class="op">(</span>target <span class="op">!=</span> <span class="kw">null</span> <span class="op">&amp;&amp;</span> target <span class="op">!=</span> start<span class="op">);</span></span>
<span id="cb63-119"><a href="#cb63-119" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb63-120"><a href="#cb63-120" aria-hidden="true" tabindex="-1"></a>        <span class="co">// return the path, we might want to validate if the start / end correspond to the</span></span>
<span id="cb63-121"><a href="#cb63-121" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> path<span class="op">;</span></span>
<span id="cb63-122"><a href="#cb63-122" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<h3 id="a-star">A-star</h3>
<p>Similarly to Dijkstra, the implementation is actually the same, a way
to find the shortest path between two nodes in a weighted graph, the
only meaningful difference is the way the cost is computed, in Dijkstra
we simply compare the cost / weight of the shortest path to a given node
so far, to the current weight or cost of the path to that node at the
moment. However A-star takes us a step further, it defines an additional
function <code>h</code>, a heuristic, which modifies the calculation
such that it tries to guess how much cheaper would the cost be if we go
through the current <code>node</code> to the end goal</p>
<p>The heuristic function is only computed when we add the node to the
priority queue, it biases the priority queue order such that nodes with
less cost <code>IN RELATION TO THE TARGET GOAL ONLY</code>, would be put
to the front of the heap, which means that unlike Dijkstra in the
distances array, we do not have all shortest paths from the start to
every other node, we only have the shortest distance from start to end,
since the children we took from the heap were the ones with cost biased
by the heuristic, and the heuristic function is a function of the
<code>current</code> and <code>end</code> node strictly,
i.e. <code>h = heuristic(node, end)</code>.</p>
<p>The value of the heuristic function could be positive, negative or 0,
depends on how it is defined. Imagine a negative value of the heuristic,
would imply that the cost to the goal node is actually very low, since
we would subtract it from the current <code>weight</code> cost, a very
big positive heuristic value would imply a very costly path to the goal
node if we took that route.</p>
<p>A heuristic is defined very much differently based on the use case,
if our graph was instead a grid, the heuristic is usually a coordinate
computation of the <code>current node</code>, in relation to the
<code>end</code> goal. There are several famous ones:</p>
<ul>
<li><p>Manhattan distance - on a grid where we can move in 4 directions,
up/down/right/left <code>d = abs(x1 - x2) + abs(y1 - y2)</code>. The
simplest one, we can move only in right angles</p>
<div class="sourceCode" id="cb64"><pre
class="sourceCode txt"><code class="sourceCode default"><span id="cb64-1"><a href="#cb64-1" aria-hidden="true" tabindex="-1"></a>    - 1 -</span>
<span id="cb64-2"><a href="#cb64-2" aria-hidden="true" tabindex="-1"></a>    1 x 1</span>
<span id="cb64-3"><a href="#cb64-3" aria-hidden="true" tabindex="-1"></a>    - 1 -</span></code></pre></div></li>
<li><p>Euclidean distance - on a grid where we can move in 8 directions,
including the 4 cardinal ones, plus, moving in diagonals, it is simply
the Pythagorean theorem -
<code>d = sqrt(pow(x1 - x2, 2) + pow(y1 - y2, 2))</code>. Here moving in
diagonals is simply the length of hypotenuse of the right triangle
formed.</p>
<div class="sourceCode" id="cb65"><pre
class="sourceCode txt"><code class="sourceCode default"><span id="cb65-1"><a href="#cb65-1" aria-hidden="true" tabindex="-1"></a>    5 3 5</span>
<span id="cb65-2"><a href="#cb65-2" aria-hidden="true" tabindex="-1"></a>    4 x 4</span>
<span id="cb65-3"><a href="#cb65-3" aria-hidden="true" tabindex="-1"></a>    5 3 5</span></code></pre></div></li>
<li><p>Chebyshev distance - on a grid where we can still move in the 8
directions, as described above, <code>d = max(y2 - y1, x2 - x1)</code>.
Here moving in diagonals is just as expensive as moving in the costliest
direction</p>
<div class="sourceCode" id="cb66"><pre
class="sourceCode txt"><code class="sourceCode default"><span id="cb66-1"><a href="#cb66-1" aria-hidden="true" tabindex="-1"></a>   3 3 3</span>
<span id="cb66-2"><a href="#cb66-2" aria-hidden="true" tabindex="-1"></a>   2 x 2</span>
<span id="cb66-3"><a href="#cb66-3" aria-hidden="true" tabindex="-1"></a>   3 3 3</span></code></pre></div></li>
</ul>
<p>In the examples above we have to simply substitute the coordinates of
the current node for <code>x1 and y1</code> and then the coordinates for
the target goal node <code>x2 and y2</code>, the resulting value is our
heuristic function. Notice that a lower value - meaning lower distance,
meaning less cost, is better, higher means - more distance between the
child and goal node, meaning it is worse to take that path through that
node (to the goal node) overall.</p>
<p>The implementation pretty much follows the base Dijkstra one, with
the addition of having a special function, which calculates the
heuristic cost of each node. And take a good look at how it is used, the
heuristic is calculated, at the very moment the node is added to the
queue, by that time we know that this distance coming from the parent is
smaller than any current distance for that node, we further bias that
node’s cost based on the heuristic, if the heuristic is very big the
cost would be big, the node would be pushed down the min heap, if the
heuristic is low (maybe negative) the cost would be low, and the node
would be pushed to the front of the min heap</p>
<p>A-star with heuristic, which always evaluates to 0, is essentially
just the Dijkstra algorithm, since no node is biased towards the end
goal, in other words, there is no one or more special nodes in the graph
we can take to make our cost extra cheaper, we only consider the cost of
the weights, there is no additional feature / property, which could
further reduce our costs.</p>
<div class="sourceCode" id="cb67"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb67-1"><a href="#cb67-1" aria-hidden="true" tabindex="-1"></a>    <span class="kw">....................................</span><span class="op">..</span></span>
<span id="cb67-2"><a href="#cb67-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb67-3"><a href="#cb67-3" aria-hidden="true" tabindex="-1"></a>    <span class="fu">while</span> <span class="op">(</span>visited<span class="op">.</span><span class="fu">size</span><span class="op">()</span> <span class="op">&lt;</span> nodes<span class="op">.</span><span class="fu">size</span><span class="op">())</span> <span class="op">{</span></span>
<span id="cb67-4"><a href="#cb67-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb67-5"><a href="#cb67-5" aria-hidden="true" tabindex="-1"></a>        <span class="kw">....................................</span><span class="op">..</span></span>
<span id="cb67-6"><a href="#cb67-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb67-7"><a href="#cb67-7" aria-hidden="true" tabindex="-1"></a>        <span class="fu">for</span> <span class="op">(</span><span class="bu">Node</span> child <span class="op">:</span> node<span class="op">.</span><span class="fu">children</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb67-8"><a href="#cb67-8" aria-hidden="true" tabindex="-1"></a>            <span class="co">// current min cost so far, to reach the child node, or default to some high value if none</span></span>
<span id="cb67-9"><a href="#cb67-9" aria-hidden="true" tabindex="-1"></a>            <span class="bu">Integer</span> current <span class="op">=</span> distances<span class="op">.</span><span class="fu">getOrDefault</span><span class="op">(</span>child<span class="op">.</span><span class="fu">value</span><span class="op">,</span> <span class="dv">9999</span><span class="op">);</span></span>
<span id="cb67-10"><a href="#cb67-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb67-11"><a href="#cb67-11" aria-hidden="true" tabindex="-1"></a>            <span class="co">// the possible new cost, note that the heuristic is still not calculated here, see below</span></span>
<span id="cb67-12"><a href="#cb67-12" aria-hidden="true" tabindex="-1"></a>            <span class="bu">Integer</span> possible <span class="op">=</span> distances<span class="op">.</span><span class="fu">getOrDefault</span><span class="op">(</span>node<span class="op">.</span><span class="fu">value</span><span class="op">,</span> <span class="dv">9999</span><span class="op">)</span> <span class="op">+</span> node<span class="op">.</span><span class="fu">getWeightCost</span><span class="op">(</span>child<span class="op">);</span></span>
<span id="cb67-13"><a href="#cb67-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb67-14"><a href="#cb67-14" aria-hidden="true" tabindex="-1"></a>            <span class="co">// in case the possible new distance is actually smaller than the distance stored so far</span></span>
<span id="cb67-15"><a href="#cb67-15" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>possible <span class="op">&lt;</span> current<span class="op">)</span> <span class="op">{</span></span>
<span id="cb67-16"><a href="#cb67-16" aria-hidden="true" tabindex="-1"></a>                <span class="co">// these remain the same as they do in Dijkstra, we update both previous and</span></span>
<span id="cb67-17"><a href="#cb67-17" aria-hidden="true" tabindex="-1"></a>                <span class="co">// distances for the specific node, they must be kept in sync, to use later</span></span>
<span id="cb67-18"><a href="#cb67-18" aria-hidden="true" tabindex="-1"></a>                previous<span class="op">.</span><span class="fu">put</span><span class="op">(</span>child<span class="op">.</span><span class="fu">value</span><span class="op">,</span> node<span class="op">);</span></span>
<span id="cb67-19"><a href="#cb67-19" aria-hidden="true" tabindex="-1"></a>                distances<span class="op">.</span><span class="fu">put</span><span class="op">(</span>child<span class="op">.</span><span class="fu">value</span><span class="op">,</span> possible<span class="op">);</span></span>
<span id="cb67-20"><a href="#cb67-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb67-21"><a href="#cb67-21" aria-hidden="true" tabindex="-1"></a>                <span class="co">// take a very good note of how and where the heuristic is calculated, and</span></span>
<span id="cb67-22"><a href="#cb67-22" aria-hidden="true" tabindex="-1"></a>                <span class="co">// that it is based on the child node, and the cost it would take</span></span>
<span id="cb67-23"><a href="#cb67-23" aria-hidden="true" tabindex="-1"></a>                <span class="co">// to get to the goal node, and that is the value we put in the</span></span>
<span id="cb67-24"><a href="#cb67-24" aria-hidden="true" tabindex="-1"></a>                <span class="co">// queue, the lower the heuristic the better, means less cost.</span></span>
<span id="cb67-25"><a href="#cb67-25" aria-hidden="true" tabindex="-1"></a>                heap<span class="op">.</span><span class="fu">add</span><span class="op">(</span><span class="kw">new</span> <span class="fu">WeightNode</span><span class="op">(</span>child<span class="op">,</span> possible <span class="op">+</span> <span class="fu">heuristic</span><span class="op">(</span>child<span class="op">,</span> end<span class="op">));</span></span>
<span id="cb67-26"><a href="#cb67-26" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb67-27"><a href="#cb67-27" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb67-28"><a href="#cb67-28" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb67-29"><a href="#cb67-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb67-30"><a href="#cb67-30" aria-hidden="true" tabindex="-1"></a>    <span class="kw">....................................</span><span class="op">..</span></span></code></pre></div>
<h1 id="sorting">Sorting</h1>
<h2 id="topological-sort">Topological sort</h2>
<p>This type of sort / ordering of graph nodes works only for directed
graphs, without cycles. There are many ways to detect cycles in a graph,
the implementation below assumes valid graph.</p>
<p>Topological sorting is a way to order nodes in a graph in such a way
that the nodes with the least amount of incoming edges come first. The
nodes are basically ordered / sorted in increasing order of the number
of incoming edges.</p>
<p>A very common use case would be to represent a build system, where
each module is a node, each dependency between the modules is an edge.
We would like to see, which modules need to be built first, second,
third and so on. We would like to print the modules in the correct build
order. This is where Topological sort comes in handy.</p>
<p>What we do is select the modules with no incoming edges, meaning they
have no dependencies, then we breadth traverse their immediate children,
decrease the children’s incoming edge count, if a child’s incoming edge
count becomes 0, add that to the path, and to the processing queue,
repeat until processing queue is empty</p>
<div class="sourceCode" id="cb68"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb68-1"><a href="#cb68-1" aria-hidden="true" tabindex="-1"></a>    <span class="bu">List</span><span class="op">&lt;</span><span class="bu">String</span><span class="op">&gt;</span> <span class="fu">sort</span><span class="op">(</span><span class="bu">List</span><span class="op">&lt;</span><span class="bu">Node</span><span class="op">&gt;</span> graph<span class="op">)</span> <span class="op">{</span></span>
<span id="cb68-2"><a href="#cb68-2" aria-hidden="true" tabindex="-1"></a>        <span class="co">// the queue here will receive the next node in the graph which has no more incoming edges</span></span>
<span id="cb68-3"><a href="#cb68-3" aria-hidden="true" tabindex="-1"></a>        <span class="bu">Queue</span><span class="op">&lt;</span><span class="bu">Node</span><span class="op">&gt;</span> queue <span class="op">=</span> <span class="kw">new</span> <span class="bu">LinkedList</span><span class="op">&lt;&gt;();</span></span>
<span id="cb68-4"><a href="#cb68-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb68-5"><a href="#cb68-5" aria-hidden="true" tabindex="-1"></a>        <span class="co">// the result holds the list of nodes in topological order, ordered front to back, at the front the nodes with the least number</span></span>
<span id="cb68-6"><a href="#cb68-6" aria-hidden="true" tabindex="-1"></a>        <span class="co">// of incoming edges - zero, and increasing</span></span>
<span id="cb68-7"><a href="#cb68-7" aria-hidden="true" tabindex="-1"></a>        <span class="bu">List</span><span class="op">&lt;</span><span class="bu">String</span><span class="op">&gt;</span> result <span class="op">=</span> <span class="kw">new</span> <span class="bu">LinkedList</span><span class="op">&lt;&gt;();</span></span>
<span id="cb68-8"><a href="#cb68-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb68-9"><a href="#cb68-9" aria-hidden="true" tabindex="-1"></a>        <span class="co">// put in the queue all the nodes with no incoming edges, these would be the ones with which we would have to start, if there</span></span>
<span id="cb68-10"><a href="#cb68-10" aria-hidden="true" tabindex="-1"></a>        <span class="co">// are none, then there is no topological order, meaning the graph probably has cycles</span></span>
<span id="cb68-11"><a href="#cb68-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="bu">Node</span> node <span class="op">:</span> graph<span class="op">)</span> <span class="op">{</span></span>
<span id="cb68-12"><a href="#cb68-12" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>node<span class="op">.</span><span class="fu">incoming</span> <span class="op">==</span> <span class="dv">0</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb68-13"><a href="#cb68-13" aria-hidden="true" tabindex="-1"></a>                <span class="co">// add node with no incoming edges</span></span>
<span id="cb68-14"><a href="#cb68-14" aria-hidden="true" tabindex="-1"></a>                queue<span class="op">.</span><span class="fu">add</span><span class="op">(</span>node<span class="op">);</span></span>
<span id="cb68-15"><a href="#cb68-15" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb68-16"><a href="#cb68-16" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb68-17"><a href="#cb68-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb68-18"><a href="#cb68-18" aria-hidden="true" tabindex="-1"></a>        <span class="co">// while the queue is not empty, meaning we have nodes to go through,</span></span>
<span id="cb68-19"><a href="#cb68-19" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span> <span class="op">(!</span>queue<span class="op">.</span><span class="fu">isEmpty</span><span class="op">())</span> <span class="op">{</span></span>
<span id="cb68-20"><a href="#cb68-20" aria-hidden="true" tabindex="-1"></a>            <span class="co">// pop the current node, remember, they are only added to the queue if they have no incoming edges</span></span>
<span id="cb68-21"><a href="#cb68-21" aria-hidden="true" tabindex="-1"></a>            <span class="bu">Node</span> node <span class="op">=</span> queue<span class="op">.</span><span class="fu">remove</span><span class="op">();</span></span>
<span id="cb68-22"><a href="#cb68-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb68-23"><a href="#cb68-23" aria-hidden="true" tabindex="-1"></a>            <span class="co">// add the node to the result</span></span>
<span id="cb68-24"><a href="#cb68-24" aria-hidden="true" tabindex="-1"></a>            result<span class="op">.</span><span class="fu">add</span><span class="op">(</span>node<span class="op">.</span><span class="fu">value</span><span class="op">);</span></span>
<span id="cb68-25"><a href="#cb68-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb68-26"><a href="#cb68-26" aria-hidden="true" tabindex="-1"></a>            <span class="co">// for each child of the current node, go and decrement the incoming edge, child is linked to the current node,</span></span>
<span id="cb68-27"><a href="#cb68-27" aria-hidden="true" tabindex="-1"></a>            <span class="co">// therefore we have to &#39;remove&#39; this incoming edge from the current node to the parent.</span></span>
<span id="cb68-28"><a href="#cb68-28" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> <span class="op">(</span><span class="bu">Node</span> child <span class="op">:</span> node<span class="op">.</span><span class="fu">children</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb68-29"><a href="#cb68-29" aria-hidden="true" tabindex="-1"></a>                <span class="co">// &#39;remove&#39; the current connection from node - child</span></span>
<span id="cb68-30"><a href="#cb68-30" aria-hidden="true" tabindex="-1"></a>                child<span class="op">.</span><span class="fu">incoming</span><span class="op">--;</span></span>
<span id="cb68-31"><a href="#cb68-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb68-32"><a href="#cb68-32" aria-hidden="true" tabindex="-1"></a>                <span class="co">// when incoming becomes zero or less, add the child node to the queue, the child might have more than one incoming</span></span>
<span id="cb68-33"><a href="#cb68-33" aria-hidden="true" tabindex="-1"></a>                <span class="co">// edges, it will be added only when the last incoming edge for it was removed</span></span>
<span id="cb68-34"><a href="#cb68-34" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> <span class="op">(</span>child<span class="op">.</span><span class="fu">incoming</span> <span class="op">&lt;=</span> <span class="dv">0</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb68-35"><a href="#cb68-35" aria-hidden="true" tabindex="-1"></a>                    <span class="co">// add to the processing queue</span></span>
<span id="cb68-36"><a href="#cb68-36" aria-hidden="true" tabindex="-1"></a>                    queue<span class="op">.</span><span class="fu">add</span><span class="op">(</span>child<span class="op">);</span></span>
<span id="cb68-37"><a href="#cb68-37" aria-hidden="true" tabindex="-1"></a>                <span class="op">}</span></span>
<span id="cb68-38"><a href="#cb68-38" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb68-39"><a href="#cb68-39" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb68-40"><a href="#cb68-40" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb68-41"><a href="#cb68-41" aria-hidden="true" tabindex="-1"></a>        <span class="co">// the topological order of the graph&#39;s nodes are contained in the list result</span></span>
<span id="cb68-42"><a href="#cb68-42" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> result<span class="op">;</span></span>
<span id="cb68-43"><a href="#cb68-43" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
</body>
</html>
