Preface

Java Database Connectivity, or JDBC, is a crucial Java API that defines how a client application can access a database. Because of this, JDBC is a key component when building large-scale enterprise Java solutions.

At a high level, working with a database using JDBC involves three main steps. First, you establish a connection to the database. Next, you execute SQL queries to retrieve, create, or modify tables in the database. Finally, you close the connection to the database.

Java provides a set of APIs to perform these activities. JDBC allows you to establish a connection, execute SQL queries, and close the connection when finished. One of the main benefits of JDBC is that you are not writing code for a specific database. Instead, JDBC creates a loose coupling between your Java program and the type of database you use. For example, different databases may have their own ways of establishing a connection, but JDBC hides these differences and offers a single set of APIs to interact with all types of relational databases.

It is important to note that JDBC supports only relational databases, such as MySQL, Oracle, Microsoft SQL Server, and DB2. It does not support newer types of databases, such as NoSQL databases.

JDBC

There are several vital components that make up JDBC, and understanding how these components work is essential. The architecture of JDBC includes database drivers and the driver manager, both of which play key roles.

JDBC drivers are designed to interact with their respective database management systems. The driver manager acts as a directory of JDBC drivers. It maintains a list of available data sources and their drivers, and it chooses the appropriate driver to communicate with the target database. The driver manager can handle multiple drivers at the same time, each connected to its own data source.

Connection

The Connection interface represents the link between your application and the database. It serves as the channel through which the application and the database communicate.

Some of the most important methods in the Connection interface include the following.

First, the createStatement method creates a Statement object, which you can use to send SQL statements to the database.

Next, the prepareStatement method creates a PreparedStatement object. This object can contain SQL statements with input parameters, represented by question mark symbols, which act as placeholders for actual values you will provide later.

The prepareCall method creates a CallableStatement object, which is used for calling stored procedures in the database. Like PreparedStatement, it can have input or output parameters, also represented by question marks.

The getMetaData method retrieves a DatabaseMetaData object. This metadata contains information about the database schema, tables, and more. It is especially useful when you do not know the details of the underlying database.

The createClob method returns a Clob object, which stands for Character Large Object. This is a built-in SQL type used to store large text values in a database table.

The createBlob method returns a Blob object, which stands for Binary Large Object. This is another built-in SQL type, used to store large binary data in a database table.

The setSchema method allows you to set the schema for the current connection, specifying which part of the database you want to access.

Finally, the getSchema method returns the name of the schema associated with the current connection, or null if no schema is set.

Driver

The first step in communicating with a database is to set up a connection between your application and the database server. Establishing this connection requires understanding the database URL format.

The general format for a database connection URL string is as follows: it starts with the word "jdbc," followed by a subprotocol, and then a subname. Each of these components carries specific information needed for the database connection and for the driver manager to establish the link between the database and the Java application.

The "jdbc" part is the same for all relational databases. The subprotocol differs for each database management system and specifies the vendor and database type. This helps the driver manager identify which database vendor the connection string is describing. The subname depends on the database, but its general format is the server address, followed by the port number, and then the database name. The server address depends on where the database is deployed. Each database management system uses a specific port number. For example, the default port for MySQL is thirty-three zero six. Finally, the database name to connect to is provided.

Here are some example connection strings. The first one connects to a PostgreSQL database running on localhost, with the database name "test." The second connects to an Oracle database at the IP address one twenty-seven dot zero dot zero dot one, on port forty-four thousand, with the database name "test." The third connects to a Microsoft SQL Server database at the host "himalaya," on port fourteen thirty-three.

Now, let's look at a Java class that demonstrates how to establish a connection to a MySQL database. In this example, the URL specifies the JDBC protocol and the MySQL subprotocol. The server address is localhost, and the port is thirty-three zero six. The database name is "addressBook." The program logs in as the user "root" with the password "mysql one two three." The connection is established using the DriverManager.getConnection method, which takes the URL, database name, username, and password as arguments. The connection is managed using a try-with-resources statement, so it is closed automatically when the block ends. If the connection is successful, the program prints a success message. If anything goes wrong, an exception is thrown, and the program prints the exception's stack trace.

If you try to run this program as is, it will fail with an exception. This is because the Java Virtual Machine does not include any database drivers by default. In this case, you need a driver for MySQL. You can download the driver from the official vendor, usually as a JAR file. To use the driver, you must add the JAR file to your classpath when compiling and running the application. This is done by appending the full path to the JAR file to the "-cp" argument when using the javac and java commands.

In summary, JDBC provides a standard way to connect Java applications to relational databases, execute SQL queries, and manage connections, all while hiding the differences between various database vendors. To use JDBC, you need the appropriate driver for your database, and you must include it in your application's classpath.


Usually, when a connection to the database fails and throws an exception, there is little that can be done to recover from it. These errors are often unrecoverable, even though they are checked exceptions. The only practical response is to log the exception and gracefully notify the user about the issue. Such exceptions typically occur if the host is not reachable, the credentials are incorrect, or the database is protected in unexpected ways. All of these situations cannot be resolved during the application's run-time.

Manager

The DriverManager class is responsible for establishing the connection between your program and the JDBC drivers. It keeps track of different data sources and JDBC drivers, so you do not need to explicitly load drivers yourself. When you call the getConnection method, DriverManager searches for a suitable driver and, if found, loads it automatically. It also manages multiple concurrent drivers, each connected to their respective data sources.

For example, when you use the getConnection method with a URL, database name, username, and password, DriverManager attempts to establish a connection to the specified database.

In another example, you can obtain the driver for a specific connection string. The code retrieves the driver for a MySQL database and prints out the fully qualified name of the MySQL JDBC driver. This demonstrates that DriverManager can automatically load the appropriate driver. Once you have the Driver object, you can establish a connection by calling its connect method, passing in the database URL and, optionally, a properties file. This properties file can include the username, password, and other connection details.

Querying

Once a connection to the desired database is established, you can perform various operations. The most common operations are known by the acronym CRUD, which stands for create, read, update, and delete.

Statement

A statement is an SQL command that allows you to communicate with the database and receive results. The Statement interface sits above the PreparedStatement and CallableStatement interfaces.

The Statement interface is used to send basic SQL statements to the database without any parameters. You typically create a Statement using the createStatement method from the Connection interface.

The PreparedStatement interface represents a pre-compiled statement that can be customized using input parameters. It is usually more efficient than a raw Statement, especially if the same SQL statement is executed multiple times. You can obtain a PreparedStatement instance by calling the prepareStatement method on the Connection interface.

The CallableStatement interface is used to execute stored procedures. CallableStatement instances can handle input, output, and input-output parameters. To get an instance, you call the prepareCall method on the Connection interface.

Once you have created a Statement instance, it is ready to be executed. The Statement interface provides three main execute methods: executeQuery, executeUpdate, and execute. The method you use depends on the type of SQL statement.

If the statement is a SELECT query, you should use the executeQuery method. This method is intended for retrieving data and is not destructive. It returns a ResultSet.

If the statement is an INSERT, UPDATE, or DELETE, you should use the executeUpdate method. This method is used for statements that modify the database and returns an integer indicating the number of rows affected.

If the type of statement is unknown, or if the instance was not produced by the caller of the execute methods, you can use the execute method. This method may return multiple ResultSets, multiple update counts, or a combination of both.

ResultSet

Relational databases organize data in tables, each with a set of attributes. When you query a database, the results are returned as a ResultSet. A ResultSet is essentially a table with column headings and the values requested by your query.

A ResultSet maintains a cursor that points to the current row. Only one row can be read at a time, so you must move the cursor to access other rows. Initially, the cursor is positioned just before the first row. You need to call the next method to advance the cursor to the first row. The next method returns a boolean value, so it is commonly used in a while loop to iterate over all rows in the ResultSet.

There are several methods available to navigate the ResultSet. The beforeFirst method sets the cursor just before the first row. The afterLast method sets the cursor just after the last row. The absolute method moves the cursor to a specific row number, using an absolute position in the table. The relative method moves the cursor relative to its current position, either forward or backward. The next method advances the cursor to the next row, while the previous method moves it to the previous row.

Extraction

Now that we have covered the necessary interfaces, let's look at how to execute a simple SQL query on the database using Connection, Statement, and ResultSet. The general high-level steps to extract information from a database are as follows.

First, obtain a Connection object. Then, create a Statement, which is used to obtain the ResultSet. This pattern of actions is common in all database-related applications.

The following example demonstrates this process. It defines a class called DbConnector with a method to connect to a MySQL database named addressBook using the root user and a password. Another class, DbQuery, contains the main method. Inside the main method, it establishes a connection, creates a statement, executes a SELECT query on the contact table, and prints out the results. The output includes the ID, first name, last name, email, and phone number for each contact. If an SQL exception occurs, it prints the stack trace and exits the program.

This example shows the typical workflow for connecting to a database, executing a query, and processing the results in Java using JDBC.


In the example above, the column names are used to extract information from the query. However, you can also use column indices instead. It’s important to remember that these indices are defined based on the query itself, not on the absolute number of columns in the underlying table. 

For instance, if your select statement retrieves all columns, then the table and the query will have the same order and number of columns. But this is not always the case—sometimes your query only selects a subset of columns, and the indices will reflect that subset.

To extract column information using indices, you can use a loop that iterates over the result set and prints out each column by its index. In this approach, the first column is accessed with index one, not zero. For example, you might see a loop that prints out five columns by calling methods like getInt with index one, getString with index two, and so on, up to index five.

Pay close attention to the fact that the column index in the ResultSet object starts from one. If you try to access a column by an index that is greater than the total number of columns in the result set, an exception will be thrown. For example, if you attempt to extract a sixth column when only five are present, you will get a SQL exception indicating that the column index is out of range.

This behavior is different from what happens when you access rows outside the valid range using methods like absolute or relative. In those cases, the result set simply wraps around, rather than throwing an exception.

Now, in situations where you do not know the data type or the number of columns in advance, you can use the getMetaData method on the ResultSet object. This returns a ResultSetMetaData object, which provides methods such as getColumnCount to determine how many columns are present.

When the data type of a column entry is unknown, you can use the getObject method on the ResultSet. This allows you to fetch the value of any column, regardless of its type.

For example, you might first determine the number of columns using getMetaData and getColumnCount. Then, as you iterate over each row in the result set, you loop from index one up to the number of columns, calling getObject for each column and printing the results. This approach lets you fetch and print all columns and their values from a ResultSet instance, without needing to know the data types or column names in advance.

Although in most cases the columns are known when writing the statement and query, it’s useful to remember that metadata for the current result set is always available.

Consider another example where you connect to the database, create a statement, and execute a query that selects only the first name and email from the contact table, filtering for entries where the first name is Michael. In this case, only two columns are extracted: first name and email. If you were to use indices instead of column names, the allowed indices would be one and two, since those are the only columns being returned by the query.

Updating

Updating the database can be done in two main ways. You can use regular SQL queries to update the database directly, or you can fetch a result set using a query and then modify both the result set and the database through the ResultSet interface. Both methods are supported, and the choice depends on your use case.

To modify the result set and the database, the ResultSet class provides a set of update methods for each data type. There are also supporting methods such as updateRow and deleteRow to help manage changes.

For example, you might connect to the database, create a statement with the appropriate options to allow updates, and execute a query to select all contacts with the first name Michael. First, you fetch and display the data before making any updates. Then, you move the cursor to the first entry, update the phone number for that entry, and call updateRow to commit the change to the database. Finally, you reset the cursor and print out the updated data.

It’s important to note two key points. First, to make a ResultSet updatable, you must create the statement with the correct options—specifically, TYPE_SCROLL_SENSITIVE and CONCUR_UPDATABLE. Second, after making changes to a row in the result set, you must call updateRow to actually persist those changes in the database. Otherwise, the changes remain only in memory.

Inserting

Inserting a row is very similar to updating a row in a ResultSet. The main difference is that, when inserting, you must move the ResultSet cursor to a special insert row position. Once there, you use the update methods to set the values for each column in the new row. After setting all the values, you call insertRow to commit the new row to the database.

For example, you might connect to the database, create an updatable statement, and execute a query to select all contacts. You display the data before the insert, then move the cursor to the insert row, set the values for first name, last name, email, and phone number, and finally call insertRow to commit the new row. After the insert, you reset the cursor and print out the updated data.

Just as with updates, calling insertRow is what actually commits the new row to the database. It’s also important to provide the correct data type for each value and to ensure that no column is left blank. If a required column is missing a value, a SQL exception will be thrown.

Deleting

Now, let’s move on to deleting rows from the database.


Deleting

Deleting records in a database follows a similar pattern to inserting and updating. Specifically, you must call a special method to actually perform the operation and commit the changes to the database. For deletions, this method is called deleteRow. Unlike insert or update operations, there is nothing more to be done—no columns to update or insert. Calling deleteRow is the only required step to commit the deletion to the database.

In the provided example, a connection to the database is established, and a statement is created that allows for both scrolling and updating the result set. The code then queries for contacts with the first name “John.” If such a record exists, it moves the cursor to the first matching row and deletes it using the deleteRow method. After closing the first result set, the code fetches all remaining contacts from the database and prints them out, showing the state of the table after the deletion. If any SQL exception occurs, the error is printed and the program exits.

Creation

It is also possible to run update statements directly from the statement object. Previously, we saw how a result set can be used to modify the database. Here, we demonstrate how the executeUpdate method can be used to alter the state of the database, specifically by creating a new table.

In this example, a connection to the database is established, and a statement object is created. The code then executes a SQL statement to create a table called familyGroup, which includes an auto-incrementing integer ID and a nickname column. If the table is created successfully, a confirmation message is printed. If there is an error, such as a syntax issue in the SQL statement or an inaccessible database, the exception is caught, printed, and the program exits. The executeUpdate method is used here because the statement performs an update action on the database. If the SQL statement is incorrect, a MySQL syntax exception will be raised. It is the responsibility of the application developer to ensure the statement is correct.

Caveats

There are several important caveats to keep in mind when working with Statement and ResultSet objects.

First, the absolute method of ResultSet moves the cursor to a specific row number. If the row number is positive, the cursor moves from the beginning of the result set. If the row number is negative, the cursor moves from the end. For example, if there are ten entries, calling absolute three moves to the third row, while absolute negative two moves to the eighth row. If the value is out of range, the cursor moves to either the start or the end of the result set.

Calling absolute one is equivalent to calling first, and absolute negative one is equivalent to calling last.

You can use either a column name or a column index with ResultSet methods. The index refers to the position in the result set, not the column number in the database table.

A Statement object will close the current ResultSet if the statement itself is closed, re-executed, or used to retrieve a new set of results. This means it is not strictly necessary to call the close method on the ResultSet, since any ResultSet instance is bound to its Statement object.

If you have two columns in a ResultSet with the same name, retrieving values by column name will always return the value from the first matching column. In such cases, you should use the column index instead.

You can use column names in ResultSet methods without worrying about case sensitivity. Methods like getString and getObject accept case-insensitive column names.

The PreparedStatement interface inherits from Statement, but it overrides all versions of the execute methods. For example, the behavior of executeUpdate may differ from its base method.

Any update can be canceled using the cancelRowUpdates method, but this must be called before calling updateRow. In all other cases, cancelRowUpdates has no effect.

When connecting to the database, you must specify the correct username and password. Otherwise, an SQL exception will be thrown.

The insertRow, updateRow, and deleteRow methods act on the current row selected by the cursor in the ResultSet. This means they operate on the row where the cursor was last moved, whether by moveToInsertRow, absolute, relative, or other cursor movement methods.

Summary

Let’s review the key components required to connect to a database.

JDBC, or Java Database Connectivity, hides the differences among various database management systems and offers a single set of application programming interfaces to interact with all types of databases. The complexity of handling different database systems is managed by the JDBC driver manager and the JDBC drivers themselves.

The getConnection method in the DriverManager class takes three arguments: a URL string, a username string, and a password string.

The syntax of the URL needed to obtain a Connection object is: jdbc, followed by a colon, then the subprotocol, another colon, and finally the subname.

If the JDBC API cannot locate the JDBC driver, it throws an SQL exception. If the driver JAR files are available, they must be included in the classpath so the JDBC API can find the driver.

Now, let’s describe the interfaces that make up the core of JDBC.

The java.sql.Connection interface provides a communication channel between the application and the database.

JDBC supports two main classes for querying and updating: Statement and ResultSet.

A Statement represents a SQL statement that can be sent to the database to execute queries and receive results. There are three types of statements. The basic Statement sends a SQL statement without parameters. The PreparedStatement represents a pre-compiled SQL statement that can be customized using input parameters. The CallableStatement executes stored procedures and can handle input, output, and input-output parameters.

A ResultSet is a table with column headings and associated values returned by a query.

To submit queries and read results from the database, a ResultSet object maintains a cursor pointing to the current row. Initially, the cursor is set just before the first row. Calling the next method advances the cursor by one row.

The column index in a ResultSet starts from one, not zero.

After modifying the contents of a row in a ResultSet, you must call updateRow. Otherwise, any changes made to the ResultSet will be lost.

You can use a try-with-resources statement to automatically close resources such as Connection, ResultSet, and Statement. It is not an error to close a ResultSet multiple times, even before the try-with-resources statement closes it at the end of the block. If the ResultSet is no longer needed, it can be closed as soon as possible.


