Advanced Design

A significant portion of Java interview questions often focus on changes introduced in Java 8, especially those related to language features and the standard library. This chapter covers lambda expressions, which are foundational for understanding Streams and the new capabilities available in Java 8.

Abstract

Abstract classes provide a way to specify an abstraction without including implementation details. In some cases, using an abstract class is more suitable than using interfaces, because abstract classes can provide both behavior and abstraction semantics. An abstract class defines common functionality and a more stringent definition for the type.

For example, consider a class called Shape that declares an abstract method named area. This method does not have an implementation in the abstract class, and any subclass must provide its own implementation.

Abstract classes cannot be instantiated directly. They are defined using the abstract keyword in the class declaration, and must include at least one abstract method that lacks an implementation. If you try to provide an implementation for a method marked as abstract, the compiler will issue an error.

It is a compile-time error if a class is defined as abstract but does not contain at least one abstract, non-implemented method. Similarly, if a class is not declared abstract but contains an abstract, non-implemented method, this is also a compile-time error. Additionally, an abstract class cannot be declared as both abstract and final.

An abstract class can extend another abstract class, as long as the rules above are followed. This means that the extending abstract class must leave at least one abstract method unimplemented.

Final

The final keyword can be applied to classes, methods, and variables. As mentioned earlier, final classes cannot be extended. Final methods cannot be overridden, and final variables cannot be reassigned.

Classes

Declaring a class as final has several benefits that are often overlooked but are quite important. As discussed in the chapter on immutability, defining a class as final ensures that it is never subclassed. This guarantees that the behavior of the class cannot be changed, effectively sealing the class from any external third-party interference that might misuse its interface.

There is also a performance benefit. Since the compiler knows that a final class cannot be subclassed, it can optimize calls to the member methods of the class. For a final class, there is no possibility of dynamic polymorphism, also known as late binding. Therefore, method calls can be optimized during bytecode generation.

Methods

A final method behaves similarly to a final class. It prevents the method from being overridden, which can be used to guarantee that certain behavior from a superclass is never changed. This ensures that specific functionality is not accidentally altered.

Variables

Final variables are mostly used when dealing with immutable classes. They are a useful way to ensure that a member variable is never reassigned. A final variable can be assigned only once, either in the constructor—across all constructors defined for a given class—or alongside the variable declaration. If a final variable is not assigned, it will result in a compile-time error.

Nested Classes

A nested class is a class defined within an enclosing class. There are four types of nested classes.

Static Inner Classes

Static inner classes are defined in a static context and are bound to the class type itself. There are several rules regarding their usage and what they can access from the enclosing class or type.

Every static inner nested class is associated with the enclosing class type itself.

The accessibility of the static class is determined by the outer class. Even if the static inner class is declared public, if the outer class has package-private or default access, then the static inner class will not be publicly accessible, regardless of its own modifier.

The name of the inner static class is expressed in the context of the wrapping outer class name. To use the nested static inner class, you must reference it using the outer class name followed by the inner class name. It is also possible to statically import the inner class to avoid this long expression.

When a static inner class or interface is defined inside an enclosing interface, they are implicitly static. There is no way to define a local inner class or interface inside an interface. However, this restriction does not apply to abstract classes.

Static nested classes can be declared abstract or final. They can also be used as base classes for other classes, or they can extend another class type, including the enclosing one.

Static nested classes can have static members, which is not true for all types of nested classes.

Static nested classes can only access static members of the enclosing class. However, if the static inner class has a reference to an instance object of the enclosing class, it can access its members, regardless of the access modifier—private or otherwise.

Enclosing classes can access the static members of the inner static class. If they have a reference to an instance of the inner static class, they can also access its member variables, regardless of access modifiers.

To instantiate a static inner class, you must reference the outer class name first, then the static member class. For example, you would create an instance by using the outer class name, followed by a dot, then the inner class name, and finally the constructor.

The following example demonstrates the relationship between an outer class and its inner static class. The outer class contains both static and instance members, and it creates an instance of the inner static class, passing itself as a reference. The inner static class can access both the static and instance members of the outer class, provided it has a reference to the outer class instance.

To create an instance of the inner class, you use the outer class name, followed by a dot, then the inner class name, and finally the constructor. Note that the inner class must be visible. If the outer class is defined with package-private or default access, the inner class will not be visible if the outer class itself is not visible.

Inner Classes

Inner classes are a specialized case of static inner classes, where the inner class is defined as a non-static member inside another class. The most important difference is that the instance of a non-static inner class is not bound to the class type itself, but to each instance of the enclosing class. Each instance of the outer class has its own instance of the non-static inner class.

Every non-static inner nested class is associated with an instance of the enclosing class type. This is different from static inner classes, which are bound to the class type definition itself.

The inner class can access the non-static members of the enclosing class without needing a reference to an instance of the enclosing class. This is because the inner non-static nested class is bound to the instance of the class, not the class itself.

The outer class cannot access member variables of the nested inner class without declaring an instance of it.

The inner non-static class cannot have static members defined. This is because the class type definition itself is tied to an instance of the enclosing outer class, and static members are bound to the class type, not an instance. Therefore, the inner class type definition does not exist independently of the outer class instance.

The next example demonstrates an outer class with both static and instance members, and an inner class that is non-static. The inner class can access the outer class’s members directly, reflecting the close relationship between the two.


Let’s start by looking at the code that demonstrates how to create an instance of an inner static class from within its enclosing class. In this example, the Outer class has a constructor that creates an instance of its Inner class, passing the current instance as a reference. The code also shows how to access a private member of the inner class from the outer class. Inside the Inner class, the constructor accesses both an instance member of the enclosing Outer class and a static member of the Outer class. This demonstrates the different ways inner classes can interact with their enclosing class’s members.

To create an instance of the inner class from outside the Outer class, you need a reference to an existing Outer instance. You then use that reference to create a new Inner instance. This is necessary because non-static inner classes are always associated with an instance of their enclosing class.

Now, let’s move on to local classes.

Local classes are named class definitions that exist only within the local scope of a code block, such as inside a method, constructor, or initialization block. They are not tied to the enclosing class or its instances. In earlier versions of Java, you could not define local interfaces inside methods, constructors, or initialization blocks, but this restriction was removed in later versions.

Local inner classes have some important limitations. For example, you cannot return an instance of a locally defined class type directly from a method, because the class type only exists within the method’s scope. However, if the local class extends or implements a type that is visible outside the method, you can return that supertype instead. For instance, if a local class implements the Closeable interface, you can return a Closeable from the method.

When you define a local class inside a method, any local variable accessed by the class must be effectively final. This means that once the variable is assigned, it cannot be changed for the rest of the method’s scope, even outside the local class. If you try to reassign such a variable, the compiler will generate an error. However, variables not used inside the local class are not subject to this restriction.

The general rule is that only final or effectively final variables can be accessed by a local class. If a variable is not explicitly marked as final, the compiler will treat it as effectively final if it is not reassigned after its initial assignment.

Next, let’s discuss anonymous classes.

Anonymous classes, as the name suggests, do not have a name. They are defined and instantiated in a single expression, usually as part of a method call or assignment. Anonymous classes are useful in situations where you need a one-off implementation of an interface or an abstract class. They are similar to local classes, but without a name.

Because anonymous classes have no name, you cannot define explicit constructors for them. Instead, you provide any necessary initialization in an instance initializer block or by setting fields directly. Anonymous classes are defined in the new expression itself, and they cannot extend more than one class or implement more than one interface.

For example, you might use an anonymous class to provide a custom implementation of the Closeable interface or to override methods of a concrete class. The syntax is similar to defining a subclass, but without a class name. You can define instance variables and override methods as needed.

In practice, anonymous classes were often used to implement functional interfaces before the introduction of lambda expressions in Java. With lambdas, many use cases for anonymous classes have been replaced by more concise syntax.

Now, let’s talk about enums.

Enums, or enumeration types, provide a way to define a set of named constants. Unlike in some other languages where enums are just integers, in Java, enums are full-fledged class types. They can have fields, methods, and constructors, and each enum constant is a singleton instance of the enum class.

The simplest form of an enum defines a set of named constants, which are assigned ordinal values at compile time. For example, you might define an enum called PrinterType with values like DOTMATRIX, INKJET, and LASER.

Enums can also have constructors, but these constructors are always private. This is because enum instances are created by the runtime, not by the user. Each enum constant can be initialized with arguments that are passed to the constructor. For example, you might define a PrinterType enum where each constant has a page print capacity. The constructor sets this value, and you can define methods to access it.

The key point is that enums in Java are much more powerful than simple integer constants. They provide type safety, can have custom behavior, and ensure that each constant is a unique instance at runtime. This makes them a robust choice for representing fixed sets of related values in your code.


Enums can have custom methods, which extend their behavior. For example, a method called getPrintPageCapacity might return the page print capacity for a particular enum constant.

Enums are explicitly defined as public, static, and final. This means they are always visible, cannot be extended, and cannot be bound to a class instance. In other words, enums cannot be defined as non-static inner classes inside another class type.

There are several important rules that apply to enumerations in Java, which set them apart from regular class types and instances.

First, an enum cannot be created with the new keyword. Instead, they are created by the runtime based on their definition in the enum type itself.

Second, enumerations are comparable using the double equals operator. This is possible because every enum instance of a given enum type exists and is created only once by the runtime.

Third, enumerations from the same type can also be compared using the equals operator. This is equivalent to using double equals, unless the method is overridden.

By default, the toString method of an enum type prints the name of the enumeration entry itself. However, the toString method can be overridden, just like for any other class type.

Using the values method on the enumeration type returns an array of enumeration constants for that specific type.

Enumeration constants, or entries, cannot be cloned. The clone method by default throws a CloneNotSupportedException.

Interfaces

An interface is a special type in the Java language. It provides no member variables and only has member methods, which by default are not implemented. Interfaces usually represent some sort of behavior.

Unlike abstract classes, interfaces are not implemented using the extends keyword, but with the implements keyword. Additionally, a class type can implement as many interfaces as needed, while in Java, a class can only extend from a single parent class.

In Java 8, the interface structure was improved with the addition of default methods. These provide a way to attach utility methods that are similar to static methods. However, default methods are not static, since they can be overridden by the class that implements the interface. If the class implementor chooses to do so, these methods usually provide a wrapper of some sort around the API of the interface they are within.

For example, in the Iterator interface, there is a default method called forEachRemaining. This method loops over the remaining entries in the iterator, calling hasNext and next. The hasNext and next methods are not implemented by default, but the default method wraps their usage in a general-purpose implementation.

Several key points differentiate interfaces from regular classes.

Interfaces can extend from other interfaces, one or more, using the extends keyword. However, they cannot extend from abstract or concrete classes.

Interfaces cannot be instantiated. They cannot have constructors declared or defined. However, a reference variable to an interface can refer to an object that implements it. For example, you can write: Iterator it equals new IteratorImpl.

Interfaces do not contain non-static instance variables. If a data member is defined in an interface, it is implicitly declared as public, static, and final.

An interface can have abstract, default, and static methods. All methods in an interface are by default abstract. There is no need to explicitly provide the abstract keyword, which is used in abstract classes to mark methods without implementation. In interfaces, the default is that methods do not have an implementation.

An interface can be declared within another interface or class, and it is always by default static. This is known as a nested interface. There is no notion of a non-static nested interface, since non-static nested types are linked to an instance.

An interface can have an empty body. These are usually called marker interfaces. They are left over for future extension or used during reflection stages to identify certain behavior.

If an abstract class implements an interface, it does not have to implement the methods immediately. However, the concrete implementations of that class must do so.

Only public member methods of an interface are allowed. The interface would be useless if it had a hidden state that is not accessible from the outside. The idea of an interface is to be as open as possible, exposing an action or behavior. It should not, and cannot, be used to hide actions or behavior.

For example, both the interface and its methods are by default implicitly defined as public. There is no reason to provide a qualifier to the methods or to the interface itself. If you try to declare a protected or private method in an interface, it will produce a compiler error. A method without a qualifier is public by default.

Default methods cannot be qualified as synchronized. This is because the synchronized qualifier on a method requires the runtime to lock the current object or instance. However, interfaces are not instantiable. It is possible, though, to use a synchronized block inside the default method, which locks around the current instance.

For example, synchronizing around an interface method can be done within the body. When the method is invoked, you can refer to this, which refers to the instance or object of the class type that has implemented the interface. However, this is of the type of the interface. On the other hand, marking the default method itself as synchronized is not allowed, since the runtime does not know which instance to create the lock around.

Diamond Pattern

There is a well-known issue when declaring multiple interfaces. When a class implements multiple interfaces, it is possible for two interfaces to provide default methods with the same signature. This issue can only happen with default methods, since non-default ones have no implementation.

For example, suppose you have two interfaces, Interface1 and Interface2, both providing a default method called foo. If a class called Diamond implements both interfaces, the compiler will produce a compile-time error. It sees two methods with the same signature coming from two different type hierarchies. To avoid this, the method must be overridden in the child class to explicitly specify which method is to be used.

If you try to call foo directly without overriding it in the implementation, the compiler will not know which default method to call, and this will result in a compile-time error.


To resolve the issue described above, and to avoid a compiler error, you need to qualify the method using the super keyword. Just as the this keyword refers to the current instance, the super keyword refers to the superclass or interface of a given class. Both calls can be used or referenced here, or in any other method in the Diamond class.

If a certain condition is met, you can use Interface1.super.foo to call the default method from the first interface. Otherwise, you can use Interface2.super.foo to call the default method from the second interface.

This approach is now correct. After the method in Diamond properly resolves the conflict between the two foo methods, the compiler will recognize that the method is explicitly overridden in the implementation and will know how to call it. When you create a new instance of Diamond and call foo, it will work as expected.

Now, let’s consider another scenario. When an interface and a base class have the same method signature, for backward compatibility, the Java runtime will pick the method from the base class. In this case, the “class wins” rule is applied. This ensures compatibility with older versions and the established behavior of the language.

For example, suppose you have a class called BaseClass with a method foo, and an interface called BaseInterface that also defines a default method foo. If you create a class called Diamond that extends BaseClass and implements BaseInterface, then when you call foo on a Diamond instance, the method from BaseClass will be called. Even though there are two methods with the same signature, the one from the interface will be completely ignored by the compiler.

Now, let’s discuss a small caveat. What happens if the method in BaseClass is marked as final? Since final means the method cannot be overridden, the compiler will be confused. It will still try to apply the “class wins” rule, but if you attempt to override the method, the compiler will throw an error. You cannot change this behavior.

For example, if you have a BaseClass with a final foo method, and a BaseInterface with a default foo method, and then you try to override foo in a subclass called Diamond, the compiler will produce an error. Even though you might think the compiler would assume you want to override the method from the interface, since the one from the class is final, that is not the case. The class still wins, and the compiler insists on overriding the method from the class. Since it is final, this results in a compile-time error.

Functional interfaces

The concept of a functional interface was introduced in Java 8, alongside lambda expressions. The idea behind functional interfaces is that they provide only one single method that must be implemented. An interface with no methods, or only default methods, is not considered a functional interface. Java 8 introduced a new annotation called FunctionalInterface, which can be used to mark interfaces at compile time. This annotation is used to validate whether a given interface is truly a functional interface.

Some examples of functional interfaces in the Java standard library include Runnable in the java.lang package, Comparator in the java.util package, ActionListener in the java.awt.event package, and FileFilter in the java.io package. Each of these interfaces defines a single abstract method.

A functional interface must have at least one abstract, non-implemented, non-default method to be considered a functional interface. Functional interfaces are closely related to lambda expressions, and many new additions to the java.lang library use them.

For example, if you declare an interface with the FunctionalInterface annotation and provide one abstract, non-implemented, and non-default method, that is perfectly valid. However, if the interface has no methods at all, or if it has more than one abstract method, the compiler will produce an error. The same applies if the interface only has default methods and no abstract methods.

There are some interesting caveats related to functional interfaces and interfaces in general. Interfaces do not inherit from the Object class, but they implicitly declare many of the same methods as Object. If you provide an abstract method from the Object class in the interface, it still remains a functional interface.

For example, the Comparator interface is a valid functional interface even though it declares both compare and equals methods. This is because the equals method matches the one defined in the Object class. Even though interfaces do not inherit from Object by default, they have the same methods. In this case, the signature of equals matches the one in Object, so there is no compiler error. However, if the interface only declared the equals method, then a compiler error would occur, since the interface would not have a single abstract method. Remember, methods that match those from Object are not considered abstract; they are provided with a default implementation by the runtime if one is not supplied.

Declaring methods that match the default ones from Object in a functional or regular interface does not count as adding abstract methods. They are more like default methods, which are implemented by the runtime if an implementation is not provided.

Lambda expression

One of the most important features introduced in Java 8, and in the language in general, is the lambda expression. Lambda expressions are like closures. They provide an easy way to supply a stateful callback or action behavior.

Several coordinated changes were made in the language, the virtual machine, and the libraries to enable lambda expressions and related features. First, a new operator, the arrow operator, was added to introduce lambda expressions. This operator is used to define and declare lambda references in user code. The function reference operator was also introduced, which is directly related to lambda expressions and allows functions to be converted to lambda expressions. These, in turn, are simple functional interfaces.

The default keyword was introduced, used in interfaces, and most importantly, it allows certain interfaces to be converted into functional interfaces while still retaining backward compatibility. The streams library and the integration of the collections library with streams were also introduced. This change made the streams library interoperate smoothly with the collections library, without significant friction.

The introduction of lambda expressions brought a slight paradigm shift in the way programs are developed. It allows behavior or actions to be passed as function arguments. Lambda expressions represent a stateless transformation on a piece of data, which can be passed around just like a simple variable.

The functional programming style is a style of programming that focuses on writing functions to perform tasks, rather than changing the state or data of a program in a step-by-step approach. Functional design comes from languages like Lisp or Scheme. It promotes functions and actions as user-accessible and writable variables in user code.

Key concepts of functional programming include pure functions and state immutability. Pure functions always produce the same output for the same input, without relying on or changing the state of internal or external data. State immutability means that data is not changed directly. Instead of modifying existing data in place, functions create and return new data based on the original data. This approach avoids side effects, where one part of the program changes something that affects another part in an unexpected way.


First class functions

In Java, functions are considered first class objects. This means you can treat them like any other variable. You can pass functions as arguments to other functions, return them from functions, or assign them to variables. This flexibility allows you to write code that is more modular and expressive.

High order functions

High order functions are those that take other functions as input, or return functions as output. Common examples include functions like map, filter, or reduce, which apply other functions to collections of data in useful ways.

Lambda syntax and declaration

A lambda expression in Java is defined by two main elements: the argument list and the body. These are separated by the special arrow operator, which is written as a hyphen followed by a greater-than sign. For example, you can define a variable as a lambda that returns the number five, or a lambda that takes a single argument and returns its square. If the lambda has a single argument and its type is not provided, you can omit the parentheses. When specifying multiple arguments, you can often omit the types, since Java can deduce them from the context. However, if you provide a type for one argument, you must provide types for all arguments in the list. Lambdas do not always have to return a value; they can simply execute an action and exit.

Lambda expressions are always linked to a specific type. This type can be a user-defined functional interface, or one of the existing functional interfaces provided by the Java standard library, such as Function, Predicate, or Consumer. In other words, the left-hand side of a lambda expression is always a concrete type, just like any other variable.

Custom functional interface example

The following example defines a custom functional interface called LambdaFunction, which has a single method named call. In the main method, a lambda expression is assigned to a variable of this type. The lambda prints "Hello world" when called. This demonstrates that the left-hand side of a lambda expression always refers to a specific type, and that the binding to this type determines the arguments and body of the lambda. Lambda expressions are similar to local anonymous classes, but provide a more concise way to create them. Calling the lambda is done by invoking the method defined in the interface, just as you would with any other object.

Calling the lambda expression is no different than accessing the respective method of the interface and passing the necessary arguments, if any. This is why lambda expressions are simply an extension of existing semantic and lexical objects in the Java language. They do not introduce a completely new type of lexical scoped object, but instead take advantage of other features of the language.

Lambda design

It is helpful to compare Java's approach to lambdas with other languages, such as JavaScript, where closures also exist and functions can be passed as arguments. In JavaScript, you can assign a function to a variable and then use the call operator to invoke it. Java did not introduce lambdas in this way, because doing so would have required significant changes to the language. Instead, Java reuses existing functionality to achieve similar results.

For example, in JavaScript, you can declare a variable outside a function, then define a closure that references this variable, and later invoke the closure. This illustrates how closures in other languages differ from lambda expressions in Java at a fundamental level.

This difference also explains why local variables referenced in lambda expressions in Java must be effectively final. That is, the variables must not be changed or reassigned in the lambda body or anywhere else in the local scope where the variable is visible. This restriction exists because of the way local variables are stored in Java, which is different from other languages.

Effectively final

Here is a simple example of what happens when a local variable or function argument is reassigned in the lambda body or elsewhere in the function. This is only relevant if the referenced local variable is used in both the lambda body and the function body. For function arguments, they are always considered effectively final within a lambda expression body.

In the example, a local variable named word is defined and used inside a lambda expression. Any attempt to reassign this variable, either inside or outside the lambda body, will result in a compiler error. This is true even if the reassignment happens after the lambda is created and called.

How lambdas are expanded

The next example shows how a lambda expression might be expanded by the compiler. Although the actual runtime implementation is different, conceptually the lambda is transformed into a named or anonymous class that captures the necessary scope inside member variables, which are initialized in the constructor.

For instance, a lambda that prints a local variable is conceptually expanded into an inner local class that implements Runnable. The captured variable becomes a private final member of the class, initialized when the lambda is created. When the run method is called, it prints the captured value.

Local variables and the Java memory model

It is important to note that local variables are not shared between threads in Java. They are stored on the stack and are not affected by the memory model. Only instance members, static fields, and array elements are stored on the heap and can be shared between threads. Because local variables cannot be shared, a copy of their value must be captured in an object, such as an instance member field, that can be shared between threads.

When a lambda is created, the captured value becomes an instance variable of the anonymous class representing the lambda. It holds the same value as the local variable at the time the lambda is created, but the two variables are distinct. Allowing reassignment of these variables in both the outer function scope and the lambda body would be confusing, since they share the same name and initial value but are actually different variables.

Member variables are not subject to these restrictions. The lambda automatically captures the current instance, and can access member variables without referencing this explicitly, although you can use this or super for clarity. Only local variables and function arguments are required to be effectively final, due to the reasons described above. If a lambda expression references a member variable, it is not subject to these restrictions, because of the way the Java memory model works. This means that member variables are mutable and can be reassigned both outside and inside the lambda body. This is important to remember.

Summary

Abstract classes and methods


Abstraction

An abstraction specifies the functionality that a class supports, without revealing the finer details of how that functionality is implemented. You cannot create instances directly from an abstract class. Abstract classes are important because they enable run-time polymorphism, which in turn allows for loose coupling between components.

Final Variables and Methods

A final class is a class that cannot be inherited from. In other words, you cannot create a subclass of a final class. A final method is a method that cannot be overridden by subclasses. If a class is declared as final, then all of its methods are implicitly final as well, meaning none of them can be overridden. A final variable is a variable that can be assigned only once.

Inner, Local, and Anonymous Classes

Java supports four types of nested classes. These are static nested classes, inner classes, local inner classes, and anonymous inner classes. Static nested classes can have static members, while the other types of nested classes cannot. Both static nested classes and inner classes can access members of their outer class, including private members. However, static nested classes can only access static members of the outer class. Local classes, which include both local inner classes and anonymous inner classes, can access all variables declared in the outer scope, whether that scope is a method, a constructor, or a statement block.

Enumerated Types

Enumerated types, or enums, provide a type-safe way to restrict user input to a fixed set of values. You cannot use the new keyword to create instances of an enum, even inside the enum definition itself. Enum classes are, by default, final classes, meaning they cannot be subclassed. All enum classes are implicitly derived from the java dot lang dot Enum class.

Interfaces and Overriding

An interface in Java can have three kinds of methods: abstract methods, default methods, and static methods. The diamond problem occurs when a derived type inherits two method definitions from base types that have the same signature. If two super interfaces have the same method name and one of them provides a definition, the compiler will issue an error, and you must resolve this conflict manually. If a base class and a base interface both define methods with the same signature, the method definition in the class takes precedence, and the interface definition is ignored. A functional interface is an interface that contains exactly one abstract method, but it can have any number of default or static methods. Declaring a functional interface creates a functional interface type, which can be used with lambda expressions. When declaring a functional interface, methods inherited from the Object class do not count as abstract methods.

Lambda Expressions

In a lambda expression, the left side of the arrow operator specifies the parameters, while the right side specifies the body of the function. The arrow operator, which is written as a hyphen followed by a greater-than sign, allows for concise expression of lambda functions. You can create a reference to a functional interface and assign a lambda expression to it. When you invoke the abstract method from that interface, it will call the assigned lambda expression. The compiler can infer the types of lambda parameters if they are omitted. When parameters are declared, they can include modifiers such as final. Any variables accessed by a lambda function are considered to be effectively final.


