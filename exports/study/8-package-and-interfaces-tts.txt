Packages

Packages provide a way to organize and compartmentalize a set of classes for a specific purpose. They serve as both a naming system and a visibility control mechanism. By defining classes inside a package, you can restrict access so that some classes are not accessible from outside that package. Additionally, you can define class members that are only visible to other members within the same package.

Creating a package in Java is straightforward. You simply include a package statement as the first line in your Java source file. Any classes declared in that file will belong to the specified package. The package statement creates a namespace for your classes. If you leave out the package statement, your classes are placed in the default package, which does not have a name.

Java uses file system directories to store packages. It is important to remember that case matters, and the directory name must match the package name exactly. Multiple files can use the same package statement, which just means that the classes in those files belong to the same package.

You can also create a hierarchy of packages by separating each level with a period. For example, a package declared as “java dot a w t dot image” should be stored in a directory structure that matches this hierarchy. On Windows, this would be “java backslash a w t backslash image.”

By default, the Java runtime system starts looking for packages in the current working directory. If your package is in a subdirectory of the current directory, it will be found. Alternatively, you can specify a directory path or multiple paths by setting the CLASSPATH environment variable. You can also use the dash classpath option with the java and javac commands to specify the path to your classes.

Access

Classes and packages both help encapsulate and control the scope of variables and methods. Packages act as containers for classes and other packages, while classes contain data and code.

A non-nested class in Java has only two possible access levels: default and public. If a class is declared as public, it can be accessed by any other code. If a class has default access, it can only be accessed by code within the same package. When a class is public, it must be the only public class in the file, and the file must have the same name as the class.

The following example demonstrates how access modifiers affect visibility. There are several classes defined in different packages, each with members that have different access levels: default, public, private, and protected. The example shows which members are accessible from within the same package, from a different package, and from subclasses. For instance, a class in the same package can access default and public members, but not private or protected ones. A class in a different package can only access public members. A subclass in a different package can access public and protected members, but not default or private ones.

Importing

Java provides the import statement to bring specific classes or entire packages into visibility. Once imported, you can refer to a class directly by its name, without needing to specify its full package path. The import statement is a convenience for programmers, saving you from having to type out long package names repeatedly. However, it is not strictly necessary; you can always use the fully qualified name of a class if you prefer.

In a Java source file, import statements come immediately after the package statement, if there is one, and before any class definitions. The general form of the import statement allows you to import a specific class or all classes in a package.

All standard Java classes are stored in a package called “java.” The basic language functions are in a subpackage called “java dot lang.” Normally, you have to import every package or class you want to use, but since Java would be unusable without the functionality in “java dot lang,” it is automatically imported by the compiler for all programs.

If you import two packages that both contain a class with the same name using the wildcard form, the compiler will not complain unless you try to use one of those classes. In that case, you will get a compile-time error and must specify the class’s full package name.

Interfaces

Using the keyword “interface,” you can fully separate a class’s interface from its implementation. In other words, an interface specifies what a class must do, but not how it does it. Interfaces are similar to classes in syntax, but they do not have instance variables. As a general rule, their methods are declared without a body.

Starting with Java Development Kit 8, it is possible to add a default implementation to an interface method. This means that interfaces can now specify some behavior, but default methods are a special-use feature. The original intent of interfaces—to define a contract without implementation—still remains.

Once you have defined an interface, one or more classes can implement it. To do this, you include the “implements” clause in your class definition.

Visibility

By default, all members of an interface are public, and the interface itself is also public. It would not make sense for interface types to have package-private access, as is the case with regular classes and their members when no access modifier is specified.

For example, if you define an interface with a method, both the interface and the method are implicitly public, even if you do not specify the access modifier.

Constants

You can use an interface to group a set of constants that will be used in other classes implementing the interface. By default, constants defined in an interface are implicitly public, static, and final. You do not need to specify these modifiers, and they cannot be any other way, since interfaces do not have instance member variables.

Java also allows you to define static methods in an interface, but there are some differences compared to static members in regular classes. For example, static methods in interfaces are not inherited by implementing classes. You must call them by prefixing the method name with the interface name.

In the provided example, an interface called SharedConstants defines several integer constants and a static method. A class that implements this interface can use the constants directly, without needing to prefix them with the interface name. However, to call the static method, you must use the interface name as a prefix.

It is generally discouraged to use interfaces solely for defining constants. Instead, constants should be defined in regular classes and exposed as public static final fields. To access a static constant from an interface that your class implements, you only need to reference its identifier. In contrast, static methods from interfaces must be called using the interface name.

The example also shows that static methods from interfaces cannot be called using “this dot method” or just “method.” They must be explicitly prefixed with the interface name. However, static methods inherited from regular classes can be called using “this” or directly by their name.

Implementing

To implement an interface in a class, you use the “implements” keyword in the class definition. You can also extend a superclass at the same time. The general form is: a class definition that may extend a superclass and may implement one or more interfaces, followed by the class body. This allows your class to inherit behavior from a superclass and also commit to providing the methods defined by the interfaces.


Let’s begin by noting an important distinction between interfaces and class inheritance. Unlike the relationship between child classes and base classes in inheritance, a given class can implement any number of interfaces. This is possible because interfaces specify behavior, not state. As a result, the usual drawbacks of multiple inheritance are completely avoided.

Now, let’s discuss the diamond problem, also known as the diamond inheritance problem. This issue arises in object-oriented programming languages that allow multiple inheritance, where a class can inherit from more than one parent class. The problem occurs when a class inherits from two classes that both inherit from the same superclass, creating an inheritance structure shaped like a diamond.

Imagine a scenario where class A is at the top. Classes B and C both inherit from A, and class D inherits from both B and C. In this structure, class D ends up inheriting two copies of A, which leads to ambiguity when calling or using class members.

Next, let’s talk about using interfaces to import shared constants into multiple classes. You can do this by declaring an interface that contains variables initialized to the desired values. Any class that implements this interface will have access to those constants.

Moving on to extending interfaces. An interface itself can be extended to inherit behavior from other interfaces. Unlike class inheritance, interfaces can extend from multiple other interfaces. This allows their behavior to be extended in a reusable and optimal way.

For example, consider three interfaces: A, B, and C. Interface A declares a method called methodA. Interface B declares methodB. Interface C extends both A and B, and adds its own method, methodC. A class D that implements interface C must provide implementations for all three methods: methodA, methodB, and methodC.

Now, let’s discuss default methods. With the release of Java Development Kit 8, interfaces gained a new capability called the default method. A default method lets you define a default implementation for an interface method. The primary motivation for default methods was to provide a way for interfaces to be expanded without breaking existing code. Recall that, traditionally, all methods defined by an interface had to be implemented by any class that used the interface.

For example, imagine an interface called Sequence. Initially, it defines a method called inspect. Later, two new methods, remove and insert, are added as default methods. A class called Immutable implements Sequence and only provides an implementation for inspect. Another class, Mutable, implements all three methods. In this example, the default methods allow the interface to be extended without forcing the Immutable class to provide empty or stub implementations for the new methods. This makes it possible to extend the behavior of an interface without breaking existing implementations, as long as the new behavior makes sense. Otherwise, a new interface should be created instead.

Let’s consider some caveats. As mentioned earlier, multiple inheritance is not allowed in Java. However, a class can implement multiple interfaces, and each interface can have a default method. What happens if a class implements two interfaces that both provide a default method with the same signature?

If two interfaces provide the same method signature, but the method is not a default implementation, there is no issue. Since interfaces have no instance, the signature of one interface will shadow the other, but because they are the same, this does not produce a compile-time error.

However, if both interfaces provide a default implementation for the same method, the class that implements both interfaces must override that method to resolve the ambiguity. For example, suppose interface A and interface B both provide default implementations for methodOne and methodTwo. If class C implements both A and B, it must provide its own implementation of methodOne to resolve the conflict. If it does not override methodTwo, there will be a compile-time error because the compiler cannot determine which default implementation to use.

In summary, interfaces in Java provide a flexible way to specify behavior, allow for multiple inheritance of type, and, with default methods, can evolve over time without breaking existing code. However, care must be taken when multiple interfaces provide default methods with the same signature, as this requires explicit resolution in the implementing class.


