Class design

Encapsulation

Encapsulation is the concept of combining data and the functions that operate on that data into a single unit. In object-oriented programming, this unit is called a class. The idea is to keep the data and its associated behavior together, making it easier to manage and protect.

Access modifiers in Java control how visible a class, method, or field is to other parts of the program. These modifiers help enforce encapsulation by restricting or allowing access as needed. If every variable in a class could be accessed from anywhere, there would be little point in grouping them together in a class. Encapsulation would lose its value.

There are four main types of access modifiers in Java: public, private, protected, and default.

Public

The public modifier is the most open. If a class or its members are declared as public, they can be accessed from any other class, regardless of the package. Think of it like a public place—anyone can enter.

However, there is an important detail. A public method in a class is only accessible to the outside world if the class itself is also declared as public. If the class uses default access, meaning no modifier is specified, then even public methods are only accessible within the same package.

For example, consider two files in different packages. One file defines a class with default access, and the other tries to use it. Even if the constructor is public, it is only accessible to classes within the same package. If a class in a different package tries to use it, a compile-time error occurs. This demonstrates how default access can prevent global public access, even when using the public modifier on methods or constructors.

Private

The private modifier is the strictest. A private class member cannot be accessed from outside the class. Only code within the same class can access these private members.

It is important to note that you cannot declare a class or interface as private or protected. Only public or default (no modifier) are allowed for top-level classes. Similarly, member methods or fields of an interface cannot be private or protected.

For example, trying to declare a class as private will result in a compile-time error. The language does not allow it.

Protected

The protected modifier allows a member to be accessed from the class where it is defined, as well as from any subclass, even if the subclass is in a different package. This is less restrictive than private, but more restrictive than public.

Default

The default, or package-protected, modifier is used when no access modifier is specified. In this case, the class or member is only accessible to other classes within the same package. It is not accessible from outside the package.

Relationship

To summarize the relationships between these modifiers, consider the following:

A public member is accessible from anywhere.
A private member is only accessible within the same class.
A protected member is accessible within the same class, any subclass, and other classes in the same package, but not from unrelated classes outside the package.
A default member is accessible within the same class, subclasses in the same package, and other classes in the same package, but not from outside the package.

Inheritance

Inheritance is a mechanism for reusing code in object-oriented programming. It allows you to define common properties and behaviors in a superclass, which can then be inherited by more specialized subclasses. Inheritance represents an "is-a" relationship between classes.

For example, you can define a method that takes an array of Number objects and sums them up. The Number class is a superclass of types like Float, Double, and Integer. By using the superclass, you can collect different numeric types in the same array and operate on them together. Each subclass implements a method called doubleValue, allowing them to be summed even though they are different concrete types.

Polymorphism

Polymorphism refers to the ability of a single entity to take on different forms. Most programming languages support two types of polymorphism: static and dynamic.

Static polymorphism, also known as early binding, is resolved at compile time. Function overloading is an example of static polymorphism. For instance, you might have a class called Square with two versions of a method named area. One version takes a single argument and calculates the area of a square, while the other takes two arguments and calculates the area of a rectangle. The compiler determines which version to call based on the arguments provided.

Dynamic polymorphism, or late binding, is resolved at runtime. Function overriding is an example of dynamic polymorphism. For example, you might have a superclass called Shape with a method named area. Subclasses like Circle and Square override this method to provide their own implementations. When you call area on a Shape reference, the actual method that gets executed depends on the runtime type of the object.

Overloading

Method overloading is the process of defining multiple methods with the same name but different input arguments or parameters. This feature works at compile time, and the compiler decides which version of the method to call based on the arguments provided.

Overloading allows you to define multiple versions of the same method, each tailored to different needs. However, overloading cannot be done solely based on return types. It depends on the method name and the order and types of arguments. The return type does not affect method overloading.


Let’s walk through the concepts of method overloading and overriding in Java, focusing on how the compiler resolves overloaded methods, the rules for upcasting, and the nuances of overriding methods from parent classes.

First, let’s look at method overloading.

In Java, you can define multiple methods with the same name but different parameter lists. For example, consider a class called Circle. This class has two methods named fillColor. One version takes three integer parameters—red, green, and blue—to color the circle using RGB values. The other version takes three floating-point parameters—hue, saturation, and brightness—to color the circle using HSB values. The actual implementation details are omitted here, but the key point is that both methods share the same name and differ only in their parameter types.

Overloaded methods can call each other, as long as a method does not call itself directly. If a method calls itself, that leads to recursion, which should be handled with care.

Constructors in Java can also be overloaded. The main difference between overloaded methods and constructors is that methods can return different types, while constructors always return an instance of the class they belong to. You can call one overloaded constructor from another within the same class to reduce code duplication. For example, the Circle class might have three constructors: one that takes x, y, and radius; another that takes just x and y and provides a default radius; and a third that provides default values for all three parameters.

Now, let’s discuss how the Java compiler resolves overloaded methods.

When you call an overloaded method, the compiler first looks for an exact match—meaning a method with the same number and types of parameters as the call. If it doesn’t find an exact match, it looks for the closest match by using implicit upcasting, also known as autocasting. If no suitable match is found, the compiler will produce an error.

Upcasting refers to converting a value to a more general type, which is always safe. For example, an Integer can be upcast to a Number, since Integer is a subclass of Number. Similarly, any class can be upcast to Object, since Object is the root of the class hierarchy. For strings, a String can be upcast to CharSequence or Object.

For primitive types, the upcasting rules are as follows: a byte can be upcast to a short, then to an int, and then to a long. This is a one-way process—downcasting is not allowed unless you do it explicitly, because it can cause errors or data loss.

There’s also a concept called autoboxing, where primitive types are automatically converted to their corresponding wrapper classes, such as int to Integer.

Let’s consider an example that demonstrates how overloaded methods are resolved. Imagine a series of overloaded methods named aMethod, each accepting a different parameter type: byte, short, int, long, Integer, Number, and Object. In the main method, you declare a byte variable with the value nine. When you call aMethod with this byte variable, the compiler will look for the most specific overload. If the byte version exists, it will use that. If not, it will look for short, then int, then long, and so on, moving up the type hierarchy until it finds a match. If no match is found, you’ll get a compiler error.

It’s important to remember that all numeric literals in Java code are defined as int or Integer by default. This can lead to some subtle issues. For example, if you define a method that takes a byte parameter and call it with the literal nine, the compiler will not find a matching overload, because nine is treated as an int. You must explicitly cast the literal to byte or short to match the corresponding overload.

Ambiguous overloading can occur when the compiler cannot determine which overloaded method to use. For instance, if you have two overloaded methods—one that takes a long and an int, and another that takes an int and a long—and you call the method with two integer literals, the compiler cannot decide which method to use, because both arguments can be upcast to long. This results in a compile-time error. However, if you explicitly cast the arguments to the appropriate types, the compiler can resolve the call.

Now, let’s move on to method overriding.

By default, all classes in Java extend from the Object class, which provides several important methods. These include toString, which defines how a class should be represented as a string; hashCode, which generates a hash code for the instance; and equals, which compares the current instance with another object. There are other methods, such as clone, which creates a copy of the object, and finalize, which is used to free resources before the object is garbage collected.

Some methods in Object, like wait, notify, notifyAll, and getClass, are declared as final and cannot be overridden.

When overriding a method, you cannot reduce the visibility of the method. For example, if the original method is public, the overridden method cannot be protected or private. However, you can increase the visibility—for instance, a private method can be overridden as protected or public. Additionally, you cannot change the method’s signature when overriding. The return type, parameter types, number of parameters, and method name must all match exactly.

There is a concept called covariant return types, which allows an overridden method to return a more specific type than the original method, as long as the new return type is a subclass of the original. For example, if you have an abstract class called Shape with an abstract method copy that returns a Shape, a subclass called Circle can override copy to return a Circle.

In summary, method overloading and overriding are powerful features in Java that allow you to write flexible and reusable code. Understanding how the compiler resolves overloaded methods, the rules for upcasting, and the constraints on overriding methods is essential for writing robust Java programs.


The example above is using a covariant type for the copy method. It overrides the copy method with a different return type. However, that return type is still part of the hierarchy of the Shape type, and is also a narrower type than Shape, which is the original return type of the copy method defined in the Shape abstract class. Therefore, this is allowed.

Covariant type inference is only allowed for return types. Changing the method arguments or parameters from the original declaration is not allowed, even when using covariant types. At this point, what happens is method overloading, not overriding. A method cannot be overridden and overloaded at the same time—it exists only in one or the other state.

Now, consider the following scenario. Imagine a type called Point, which aims to override the equals method. However, instead of overriding, it actually overloads it, leading to hidden mistakes in the code that are hard to spot.

In this example, a method called equals is defined that takes a Point as an argument and returns true if the x and y positions match, and false otherwise. When you create three Point objects and compare them using this method, it seems to work, because the types are Point and the overloaded method is being called. However, this is a mistake.

If you instead assign these Point objects to variables of type Object, and then call equals, the default equals method from Object is called. This method usually compares objects by reference, so the result is false, even if the x and y positions match.

This example shows how covariant types are not applicable for the arguments of a function that needs to be overridden. If you change the argument type, you end up overloading the method instead. That is why it is advisable to use the Override annotation. This annotation serves as a note to the compiler that you intend to override the method. If you change the method arguments to covariant types, the compiler will immediately issue an error, because it will see that you are overloading, not overriding.

In summary, use the Override annotation wherever possible to avoid such hidden mistakes, which can be detrimental to resolving issues in your code.

toString

As already discussed, overriding the toString method is not mandatory, but it is recommended. This helps identify different objects when they are printed out during debugging or general logging actions. The toString method has a specific string method signature that must be followed in order to correctly override the method.

hashCode and equals

These are the two methods that most classes should strive to correctly override, always. They are important for the correct functioning of many internal containers provided by the Java core libraries. They are often used to compare and distinguish different instances of a given class. They represent a consistent, constant way to generate a unique identifier for a given state of a class instance, and also a consistent way to compare different instances and their state.

The methods hashCode and equals need to be consistent for a class. For practical purposes, ensure that you follow this one rule: the hashCode method must return the same hash value for two objects if the equals method returns true for them. This is a general rule of thumb that must be followed to ensure correctness across the program.

Usually, both hashCode and equals use the members of a given class to generate the respective hash code or check the equality of an object.

In the provided example, a class called Point defines both hashCode and equals methods. The hashCode method uses bit manipulation and some prime numbers to generate a nearly unique hash code based on the x and y positions. The equals method performs basic checks, such as null and reference equality, and then compares the x and y positions if the argument is also a Point. Both methods use the same members to compute their results, ensuring that two objects with the same state will have the same hash code and will be considered equal.

Invocation

Method invocation from another context, such as a superclass, can be tricky. Let's explore the different options you have when you need to invoke a method outside the scope of the declaring class type.

Constructor

It is often useful to call the base class method inside the overridden method. To do that, you can use the special keyword super. The super keyword refers to the superclass, which is the parent of the current class. Every class type has a super type. Even if a class has no explicit parent, it extends by default from the Object class, which is still its superclass.

When calling the super constructor from your constructor, it must be the very first statement in the constructor.

In the provided examples, several scenarios are shown. In the first example, the super call in the constructor is the very first call, which is required. In the second example, the this call is used as the first statement, which is also allowed. In the third example, both super and this are called in the same constructor, which is not allowed and will produce a compile-time error. In the fourth example, a statement precedes the this call, which is also not allowed and will result in a compile-time error.

These examples show a few options for invoking a super or this constructor from the declaring type. However, note that it is not possible to combine both statements in the same constructor. Usually, to do this, you need two versions of the constructor: one with the super call only, and another that invokes it with this. Also, if a call to this or super is made in the constructor, it must be the very first statement, or a compile-time error will occur.

Methods

As a continuation of the above, calling super methods can be done at any place in the child method. It does not have to be the very first statement of the method, nor does it have to be called only once. There are no obvious restrictions to calling super methods from a regular member method of a declaring class, besides the potential for recursion problems, but the compiler will not complain.

In the provided example, there is a class called MemberMethodSuper with a method that returns zero. A subclass called MemberMethodThis overrides this method. Inside the overridden method, it calls a method called computeSomeValue, then calls the super method, and returns the sum of the two results. This demonstrates that the original implementation is not lost and can still be referenced using the super keyword.


Let’s continue with the explanation of the code and concepts provided.

First, there is a method called method2. This method is not present in the superclass, and it refers to the original implementation of another method called method. The method2 function returns the result of calling the superclass’s method twice and adding the results together. This demonstrates how a subclass can access and reuse functionality from its parent class, even in new methods that do not exist in the parent.

Now, let’s move on to the concept of composition.

Composition

Composition is a class design technique that complements inheritance. While inheritance represents an “is-a” relationship, composition represents a “has-a” relationship. This means that classes can be combined together to build more complex data structures. Unlike inheritance, there is no limit to how many classes you can combine using composition.

For example, consider a class called Circle. This class has a private member called center, which is a Point object, and another member called radius, which is a double. The constructor for Circle takes coordinates and a radius, then creates a new Point for the center and sets the radius. This demonstrates how a Circle “has a” Point as its center, rather than “is a” Point.

The general rule of thumb is to always prefer composition over inheritance. There are many cases where composition is the right choice, and inheritance is not. When designing a system, start by considering composition first. Only use inheritance if composition would make things less reusable or harder to interface with.

Use inheritance when a subclass truly specifies a base class, so you can take advantage of dynamic polymorphism. In other cases, use composition to get code that is easy to change and loosely coupled. In summary, favor composition over inheritance.

Singleton

The singleton is a special type of class design pattern that ensures a given class is instantiated only once. This usually happens on demand, the first time a method for the class is accessed, but sometimes it can also be done during a static block when the class loader loads the class for the first time. In either case, the idea is that only one single instance of the class will ever exist.

Singleton classes usually have no visible constructors to the outside world. Instead, they provide a public static final method, often called getSingleton. This method provides a single point of access for the singleton in a global context. It is responsible for creating the singleton the first time it is called, and returning the same instance on every subsequent call. A common example is a logging class, or any class that provides stateless utility actions that do not need to be stateful. Rarely would you persist static state in a singleton class.

In the example provided, the class is defined as final, meaning it cannot be extended. The singleton instance is declared as a private static member, but it is not initialized immediately. The constructor is private, so only members of the singleton class can access it. The getSingleton method is declared as synchronized and final. This ensures that if multiple threads call getSingleton at the same time, only one thread will create the instance, while others wait. Once the instance is created, it is returned for all future calls.

However, using synchronized on the entire method can be overkill, because the lock is acquired every time the method is called, even though it is only needed once, when the instance is created. There is a more efficient solution.

In the improved example, the getSingleton method first checks if the instance is null. If it is, it synchronizes on the Singleton class, and checks again if the instance is still null. If so, it creates the new instance. This approach, known as double-checked locking, ensures that the lock is only acquired when necessary, which is typically just once. This saves performance in the common case where the singleton has already been created.

Immutability

An immutable class is one whose state can never be altered after it is created. None of the methods or interfaces the class exposes will ever mutate the instance. Instead, methods may produce a copy of the original with a modified state, but the original instance remains unchanged. A classic example is the String class in Java. While String exposes methods that seem to mutate the string, such as trim, these methods actually produce a new instance with the modification applied.

Immutable classes are powerful because they ensure a functional approach to state transitions. They are robust, easy to use, and easy to reason about. However, they can also lead to performance problems if misused, because they may create many new instances instead of modifying existing ones.

Immutable objects are safer to use. Once their value is known, it cannot be changed and remains constant. They are also thread-safe, because no state can be changed, no matter how many threads use them. Additionally, immutable objects that share the same state can be cached or optimized by sharing.

A good rule of thumb is that all classes should be immutable unless there is a very good reason to make them mutable. In practice, this is often the case.

To define an immutable class, there are two main points to consider. First, make the fields final and initialize them in the constructor. This can be taken further by making the class itself final, and the methods final as well. This ensures that the class cannot be extended, and methods cannot be overridden, preventing any external party from producing a child class that silently mutates the instance state. Second, ensure that methods never mutate the state of the members. Extra care should be taken if the immutable type includes, through composition, mutable reference types. Such types could potentially mutate the internal state of the object.

In the example provided, there is a class called ImmutableValue. The value field is declared final and initialized in the constructor. The class is final, and the increment method is also final. The increment method must ensure that if the members themselves are mutable, it does not make any mutable calls on the object, or it restores it to the original state if necessary.

As mentioned, immutable classes can have the drawback of creating many new instances instead of modifying the original. This can be a problem, but it is usually solved by having a mutable version of the type, or by caching the immutable state so it can be reused. The default String implementation in Java does this.

Static

The static context in Java is usually bound to the type itself. When the class loader loads a class, the static context is initialized and bound to the loaded class instance. This allows you to reference a state that is bound not to an instance of the class, but to the class itself. Different instances of the class have access to this shared state. It is not truly shared between instances, but rather lives in a higher scope, making it visible to all instances.

Variable

Consider a class called StaticVariable. It has a private static integer called k, initialized to zero. The increment method increases k by one. When the class loader loads the class, the static variables and initializers are called, so the initial value of k is zero.

If you create two instances of StaticVariable, called s1 and s2, and call increment on s1, the value of k becomes one. If you then call increment on s2, the value of k becomes two. This demonstrates that the static variable k is shared across all instances of the class.


Different instances access the same state through a higher scope or level that is bound to the class type itself, not to the individual instance.

Block

There is also a concept called a static block, which extends the meaning and abilities of the static initializer. The purpose of a static block is to allow more complex code to be executed before a given static variable is initialized.

In the example provided, a class called StaticBlock contains a static block that creates a map and populates it with several key-value pairs. This static block is executed immediately after the Java Virtual Machine loads the class into memory. The static block acts like a default constructor for the class type itself. Semantically, it has a very similar effect to a constructor, but it operates at the class level rather than the instance level.

Rules

There are several important rules that apply to static context and static methods in particular.

First, static methods cannot use the this keyword, because that would imply referencing an instance. In a static context, there is no class instance to refer to.

Second, static methods cannot use the super keyword for the same reason. The super keyword is used to invoke a base class method in an instance context, which does not exist in a static context.

Third, static methods cannot be overridden. Overriding is a runtime, late-binding process that is only applicable to instance methods.

Fourth, static methods are mostly suited for utility purposes and actions. Since they cannot access member variables of an instance, they should not be used to mutate static state.

Finally, the main method must always be defined as static. Otherwise, there is no way for the runtime to locate the entry point for the program and execute it.

Summary

Let us briefly review the key points from each objective in this chapter.

Implement encapsulation

Encapsulation means combining data and the functions that operate on it as a single unit.

You cannot access the private methods of the base class in the derived class.

You can access a protected method either from a class in the same package, just like package-private or default access, as well as from a derived class.

You can also access a method with a default access modifier if it is in the same package.

You can access public methods of a class from any other class.

Implement inheritance

Inheritance is the process of creating hierarchical relationships between related classes. Inheritance is also called an “is-a” relationship.

You use the super keyword to call base class methods.

Inheritance implies an “is-a” relationship, while composition implies a “has-a” relationship.

It is generally better to favor composition over inheritance.

Implement polymorphism

Polymorphism is the ability to interpret the same message, such as a method call, with different meanings depending on the context.

Resolving a method call based on the dynamic type of the object is referred to as runtime polymorphism.

Overloading is an example of static polymorphism, also known as early binding, while overriding is an example of dynamic polymorphism, or late binding.

Method overloading means creating methods with the same name but different types and numbers of parameters.

You can have overloaded constructors. You can call a constructor of the same class from another constructor using the this keyword.

Overload resolution is the process by which the compiler determines which method to call when multiple overloaded definitions are available.

In overriding, the name of the method, the number of arguments, the types of arguments, and the return type must match exactly.

With covariant return types, you can provide a derived class of the return type in the overriding method.

Override hashCode, equals, and toString

You can override methods such as clone, equals, hashCode, toString, and finalize in your classes. However, methods like getClass, notify, notifyAll, and the overloaded versions of wait are declared final, so you cannot override them.

If you are using an object in containers like HashSet or HashMap, make sure you override the hashCode and equals methods correctly. For example, ensure that the hashCode method returns the same hash value for two objects if the equals method returns true for them.

Singleton and immutable classes

A singleton ensures that only one object of its class is created.

Making sure that a singleton implementation is truly singleton is a nontrivial task, especially in a multi-threaded environment.

Once an immutable object is created and initialized, it cannot be modified.

Immutable objects are safer to use than mutable objects. Furthermore, immutable objects are thread-safe. Additionally, immutable objects that have the same state can save space by sharing the state internally.

To define an immutable class, make it final. Make all its fields private and final. Provide only accessor methods, also known as getter methods, and do not provide mutator methods. For fields that are mutable reference types, or for methods that need to mutate the state, create a deep copy of the object if needed.

Static initialize blocks, variables, methods, and classes

There are two types of member variables: class variables and instance variables. All variables that require an instance, or object, of the class to access them are known as instance variables. All variables that are shared among all instances and are associated with a class rather than an object are referred to as class variables. These are declared using the static keyword.

All static members do not require an instance to call or access them. You can directly call or access them using the class name.

A static member can call or access only a static member of the same class.


