Lambda

The lambda expression is a form of anonymous class, or more specifically, a type of functional interface. In other words, it represents an executable action. Lambda expressions are also called closures. The term “closure” comes from the fact that they can enclose some kind of state. Lambdas are a special case of callback functions, but unlike typical callbacks, they can operate on state that is not just passed in as function parameters.

Structure

A lambda expression consists of two main components: the argument definition list, and the lambda body. This is similar to how you would define a callback. However, lambdas are not the same as callbacks. Lambdas have the ability to capture state from the outer scope, not just what is explicitly provided as arguments. The two structural parts—the argument list and the lambda body—are connected with the arrow operator. In Java, this operator is used only to construct lambda expressions.

For example, a lambda in Java is defined by specifying the arguments in parentheses, followed by an arrow, and then the body in curly braces. This structure allows you to define concise, inline implementations of functional interfaces.

Interfaces

With Java 8, the language introduced the concept of a functional interface. A functional interface is an interface that has only one method, and that method is not a default method. This feature works well with lambda expressions, since a lambda is essentially an anonymous class with a single function—the lambda itself. In practice, this means that functional interfaces and lambdas are closely related.

For example, you can define a functional interface with a single method, and then assign a lambda expression to a variable of that interface type. The Java compiler automatically creates an instance of a class that implements the functional interface whenever a lambda expression appears in a context where a target type is expected.

Declaration

When using a lambda expression, it must always be assigned to a well-defined type. This means the lambda must be assigned to a known interface type. If you try to assign a lambda to a variable with an inferred type, such as using the “var” keyword, the compiler will not be able to resolve the type and will produce an error. However, if you assign the lambda to a variable with an explicit functional interface type, it is valid.

Syntax

There are several rules that govern the syntax of lambda definitions and declarations. When a lambda has only one parameter, you do not need to enclose the parameter in parentheses. You also do not need to explicitly define the argument types; they are deduced from the functional interface signature. If the body of the lambda consists of a single statement, you do not need to surround it with curly brackets. In this case, the compiler provides an implicit return.

For example, you can define a functional interface with a single method that takes an integer. Then, you can assign a lambda to a variable of that interface type, using a single parameter without parentheses and a single statement body without curly brackets. The compiler will automatically add the return statement.

It is important to note that if you need to explicitly provide the type of one of the lambda arguments, then you must provide the type for all arguments. Otherwise, the compiler will produce an error.

Generics

Lambda expressions themselves cannot be generic, but the functional interfaces they are based on can be. This makes sense because the functional interface acts as the contract, while the lambda expression is the implementation. Therefore, the type must be defined when the lambda expression is created.

For example, you can define a generic functional interface, and then create specialized lambda instances for different types, such as Integer or Double. When invoking these lambda instances, the argument types must match exactly with the signature of the functional interface. Automatic type promotion does not work with lambda expressions, so the argument types must be an exact match.

Exceptions

Lambdas can throw exceptions. If the exception is a checked exception, it must be declared in the “throws” clause of the functional interface. You can define a functional interface whose method declares a checked exception, and then assign a lambda to it. When invoking the lambda, you must handle the exception as required by the interface contract.

Captures

There are strict rules about what a lambda can capture from the outer scope. Lambdas can capture local variables, but those variables must be effectively final, meaning they cannot be reassigned within the lambda body. Lambdas can also capture the “this” reference of the enclosing class and mutate non-final member variables. However, a lambda defined in a static context, such as a static method, does not have access to the “this” reference of the enclosing class. Lambdas can also reference static member variables of the enclosing or other classes.

For example, consider a class with static and non-static member variables. Inside a non-static method, you can define a lambda that accesses these member variables. However, if you try to modify a local variable captured by the lambda, the compiler will produce an error, because local variables captured by lambdas must be effectively final. You can, however, modify member variables of the enclosing class within the lambda.

References

Java provides another feature related to lambda expressions: method references. This allows you to capture a reference to an existing method that is compatible with the lambda’s functional interface declaration. The Java runtime will automatically create an anonymous class instance and lambda from a method reference to a static or non-static method. Java uses a special reference operator, double colon, where the left side is the target or instance reference—either a class instance variable or a class type.

Instance

To obtain an instance method reference, you use the instance variable itself as a prefix to the reference operator. For example, you can create a functional interface with a method that takes an integer and returns a character. Then, you can assign a method reference to the “charAt” method of a String instance. The lambda reference internally captures the “this” reference as the specific String instance, so invoking the method on the functional interface will call the corresponding method on that instance.

Static

You can also use method references to static methods. For example, you can reference the “join” method in the String class, which accepts a delimiter and elements to be joined. Even if the method signature specifies a superclass, such as CharSequence instead of String, the lambda signature can specify the subclass, and the correct reference will be resolved. This is not a compile-time error, as Java allows this kind of type compatibility in method references.


Let’s begin with the function signature for the join method from the String class in Java.

The join method is a static function that takes a delimiter and a variable number of elements, then returns a single string with the elements joined by the delimiter.

Next, consider the Functional interface. This interface defines a method called concat, which takes a delimiter and a variable number of elements, and returns a string.

In the example, a string variable is created with the value “hello-world.” Then, a reference to the static join method of the String class is assigned to a variable of type Functional. This means that the concat method of the Functional interface will use the String.join method internally. When ref.concat is called with a comma and the string, it concatenates the entries using the String.join method.

Now, let’s talk about generics.

It is possible to provide a generic reference to a method. The syntax is mostly the same, but there is a small caveat: the type argument of the generic needs to be specified as well.

The Comparator interface from java.lang is a functional interface used to compare two values of the same type. It returns an integer to indicate whether the first value is less than, equal to, or greater than the second value.

In the example, a class called CustomComparator defines a static generic method named comp. This method takes two numbers and returns the difference between their integer values.

A list of integers is created, and the max method from the Collections library is used to find the maximum entry. The custom comparator method is passed as a function reference, allowing the max method to use the custom comparison logic.

In summary, the max method of Collections is generic and takes a Comparator functional interface. The CustomComparator class provides a method with a matching signature, so its function reference can be passed directly to the max method.

Now, let’s discuss constructor references.

It is also possible to create references to class constructors. The idea is similar to regular methods, but with some differences. When referencing a constructor as a functional interface, the return type must be the class type, and the input must match the constructor’s arguments.

For example, the Functional interface defines a method called create that takes an integer and returns an Integer object. A reference to the Integer class constructor is assigned to a variable of type Functional. This allows you to create new Integer instances by calling the create method.

Next, let’s look at predefined functional interfaces in Java.

The Java core library provides several functional interfaces that cover most use cases for lambda expressions and method references. Here are some of the most common ones:

UnaryOperator takes an object of type T, applies a unary operation, and returns a result of the same type. Its method is called apply.

BinaryOperator takes two objects of type T, applies an operation, and returns a result of the same type. Its method is also called apply.

Consumer takes an object of type T and performs an operation on it. Its method is called accept.

Supplier returns an object of type T. Its method is called get.

Function takes an object of type T, applies an operation, and returns a result of type R. Its method is called apply.

Predicate determines if an object of type T meets a certain condition. It returns a boolean value, and its method is called test.

These predefined interfaces make it easy to use lambda expressions and method references in a wide variety of scenarios.


