CharSequence

CharSequence is the foundational interface in Java that represents any sequence of characters. Most classes in the core library that deal with strings or character sequences implement this interface. It defines the essential methods that all character sequences must provide, such as getting the length, converting to a string, checking if the sequence is empty, and accessing a character at a specific index. There are many more methods, but these are the basics.

Strings

Constructors

When you create a string in Java, unless you specify otherwise, the Java runtime uses the system’s default encoding to interpret character or byte arrays. This encoding is typically UTF-8 or UTF-16. There are several ways to construct a string:

First, you can use a constructor that takes an array of two-byte characters, creating a new string object from that array.

Second, there is a constructor that accepts a byte array, using one-byte elements to build the string.

Third, you can create a string from a StringBuilder, which copies the contents of the builder into a new string object.

Finally, string literals are a special type of string object handled by the runtime. These literals are pooled, meaning they are reused by the runtime. For example, when you write String lit equals "literal", the literal is a constant value defined in the source code and managed by the runtime for efficiency.

Basics

Concatenation

In Java, you can only use the plus operator to concatenate strings. Arithmetic operators other than plus are not allowed for strings. When you concatenate multiple string literals, Java combines them into a single string object, which is then stored in the string pool for reuse.

For example, if you write String long equals "one" plus "two" plus "three", Java produces one string object that is pooled by the runtime.

Be careful when concatenating strings with other types. Since there is no operator precedence, expressions are evaluated from left to right. For instance, if you write String expr equals "four " plus 2 plus 2, the result is "four 22", not "four 4". However, if you use parentheses, as in String expr equals "four " plus (2 plus 2), the result is "four 4".

When concatenation involves different data types, Java uses the Object.toString or String.valueOf methods to convert those types to string objects. This is how Java can concatenate objects that are not originally strings.

Extraction

To extract characters from a string, Java provides several methods.

The charAt method allows you to extract a single character from a string at a specified index.

The getChars method lets you extract a range of characters from a string into a character array. You specify the start and end indices, and the method copies the characters into the array.

The getBytes method converts the string into its byte representation, typically using the system’s default encoding. This is useful when you need the raw bytes of a string.

The toCharArray method converts the entire string into a character array, with each character occupying two bytes.

Comparison

To compare the contents of two string objects, rather than their references, you should use the equals or equalsIgnoreCase methods. These compare the strings character by character, either respecting or ignoring case.

The regionMatches method compares a specific region of one string to another, and it can be configured to ignore case.

The startsWith and endsWith methods check if a string begins or ends with another string. These are specialized cases of regionMatches.

The compareTo and compareToIgnoreCase methods implement the Comparable interface for strings, allowing you to compare them lexicographically, or in alphabetical order.

Searching

To search within a string, Java provides the indexOf and lastIndexOf methods.

The indexOf method finds the first occurrence of a character or substring, starting from a specified index. If the character or substring is not found, it returns negative one.

The lastIndexOf method finds the last occurrence of a character or substring, also starting from a specified index, and returns negative one if not found.

Reducing

Since strings in Java are immutable, you cannot modify a string in place. None of the API methods change the original string instance. Instead, each operation that produces a new string creates a new object in the Java runtime.

To reduce or transform a string, you can use various forms of the substring method. This method generates a new string object from the source string, starting at a given index and optionally ending at another index, which is not included in the result.

The concat method allows you to join multiple string objects, producing a new one. It is equivalent to using the plus operator.

The replace method replaces a single character or a sequence of characters in a string, generating a new string instance with the replacements.

The trim method returns a copy of the source string with all leading and trailing whitespace removed, including tabs and other Unicode whitespace characters.

The join method is an extension of concat. It joins a number of strings together, separated by a specific delimiter.

The toUpperCase and toLowerCase methods produce a copy of the original string with all characters converted to upper or lower case, respectively.

StringBuffer and StringBuilder

If you need a mutable string object, StringBuilder is the standard structure to use. StringBuilder provides a fast way to append or prepend to a string without the overhead of copying the string each time. It uses an internal dynamic array and offers methods to mutate the contents directly, unlike the base String class.

StringBuilder has a companion class called StringBuffer. The main difference is that StringBuffer is synchronized, making it thread-safe. This is similar to the difference between the Integer and AtomicInteger classes in the Java core library.

Both StringBuilder and StringBuffer can be constructed with a default size, a specified initial capacity, or from an existing CharSequence, such as a String.

Because these classes allow the string to be mutated, the API provides methods to expand or shrink the string at any point. You can append, prepend, or insert other strings, or explicitly set the length of the string. The internal buffer has a capacity property, which indicates how much empty space is available before a new allocation is needed. You can shrink the buffer with the trimToSize method, which reduces the capacity to match the current length of the string.

The key methods include:

capacity, which returns the current capacity of the buffer.

length, which gives the actual length of the string contained.

ensureCapacity, which enlarges the buffer’s capacity.

charAt and setCharAt, which allow you to extract or update a character at a specific position.

setLength, which extends or reduces the length of the string. If the new length is greater than the current string, null characters are added to fill the space. If it is smaller, the string is truncated.

append, which adds a string to the end of the buffer.

prepend, which adds a string to the start of the buffer.

insert, which inserts a string at a specified index.

trimToSize, which reduces the internal capacity to match the string’s length.

reverse, which reverses the contents of the string. This operation is fast because it does not require reallocation.

In summary, CharSequence is the base interface for character sequences in Java. String is the immutable implementation, while StringBuilder and StringBuffer provide mutable alternatives for efficient string manipulation. Each class offers a range of methods for creating, comparing, searching, and modifying strings, tailored to different use cases and performance needs.


Delete and Replace Methods

The delete and delCharAt methods allow you to remove parts of a string buffer. With delete, you can specify a start and end index to remove a substring. The delCharAt method lets you delete a single character at a specific position.

The replace method enables you to substitute a range of characters within the buffer. You provide the start and end positions for the range you want to replace, along with the new string that should take its place. This operation overrides the specified range with the new content.


