IO Streams

In Java, input and output operations are extensive. They go beyond just reading from or writing to the console or files. The System class in the java.lang package provides three important public static fields: out, err, and in. These represent the standard output, error, and input streams, respectively. System.in is an InputStream, while System.out and System.err are both PrintStream objects.

Here’s how you can read from the standard input stream, which is typically the keyboard or another input device. The code prompts the user to type a character, then reads a single byte from the input stream. The read method returns an integer, but the value represents a byte, ranging from zero to two hundred fifty-five. For example, if you type the character five, the output will be fifty-three, which is the ASCII code for the digit five. The read method returns an integer instead of a byte because it can also return negative one to signal an error or end-of-stream condition.

The standard input and output streams are initialized when the Java Virtual Machine starts. Sometimes, you might want to redirect these streams. Java allows you to do this by using the System.setIn, System.setOut, and System.setErr methods. System.setIn takes an InputStream, while System.setOut and System.setErr take PrintStream objects. This means you can redirect standard input, output, or error streams to other sources or destinations, such as files.

For example, you can redirect all System.out calls to a file instead of the display. This is useful for logging or capturing output for later analysis. In the provided code, a PrintStream is created for a file named log dot t x t, and System.setOut is called with this stream. Any subsequent calls to System.out.println will write to the file instead of the console.

Console

The Console class in Java provides a more user-friendly way to read data from standard input, compared to reading raw bytes from System.in. It also offers printing capabilities, giving you access to standard output. The Console class interacts directly with the underlying operating system to obtain file descriptors for standard input and output, and it provides a better API for usability.

To create a Console object, you call System.console. If the console object is null, it means the program was not started from a command line or terminal. For example, if you run the program from an integrated development environment, or IDE, the console object will not be available. This is because the Java Virtual Machine is started indirectly in these environments.

Once you have a Console object, you can use its methods to read lines of text or passwords, and to print formatted output. The Console class is not a direct wrapper around System.in or System.out, but instead provides its own methods for interacting with the console.

Here are some of the key methods provided by the Console class:

The reader method returns a Reader object associated with the console, which you can use to perform read operations.

The writer method returns a PrintWriter object for writing to the console.

The readLine method reads a line of text from the console and returns it as a string. This string does not include any line termination characters. If the read fails, for example if the user presses Control Z or Control D, the method returns null.

There is also a version of readLine that takes a format string and arguments. It first prints the formatted string, then reads a line of input.

The readPassword method reads a password from the console and returns it as a character array. When using this method, echoing is disabled, so nothing is displayed as the user types the password. There is also a version of readPassword that takes a format string and arguments, which prints a prompt before reading the password.

The format and printf methods both write formatted strings to the console. The printf method is provided as a convenience for those familiar with the C or C plus plus printf function. Both methods use format specifiers in the format string, and the actual arguments are passed after the format string. If the format string is incorrect, these methods can throw an IllegalFormatException.

Finally, the flush method flushes any data remaining in the console object's buffer, ensuring that all output is written.

The Console class supports formatting input and output using string-formatting flags, similar to the printf function in the C programming language. The first parameter of the printf method is a format string, which may contain string literals and format specifiers. The actual arguments are passed after the format string.

Output

The general syntax for a format specifier in a format string is as follows: percent sign, followed by an optional argument index, flags, width, precision, and finally the data type specifier. This allows you to control how values are formatted when printed to the console.


Let’s begin by discussing format specifiers in Java.

Each format specifier starts with a percent sign, followed by an argument index, flags, width, and precision information, and ends with a data type specifier. The argument index refers to the position of the argument in the argument list. It is an integer followed by a dollar sign, such as one dollar or two dollar, for the first and second arguments, respectively.

Flags are single-character symbols that specify characteristics like alignment and padding. For example, the minus sign flag specifies left alignment, while the zero flag pads number types with leading zeroes.

The width specifier indicates the minimum number of characters that the final formatted string will span. By default, if the data is shorter than the specified width, it is padded with spaces. If the data is longer, the full data appears in the output without being trimmed.

The precision field specifies the number of precision digits in the output. This is relevant only for floating point number arguments.

Finally, the data type specifier indicates the type of expected input data. This field acts as a placeholder for the specified input data.

Let’s analyze the following format string:

Percent minus fifteen s, tab, percent five d, double tab, percent d, double tab, percent point one f, newline.

In this format string, percent minus fifteen s means a string padded to at least fifteen characters. Percent five d means a decimal or integer with at most five digits, padded with spaces if it is less. Percent point one f means a floating point number displayed with at most one digit after the decimal point. The tab characters separate the formatted arguments, creating equal space between them.

Now, let’s review some common format symbols and their descriptions.

Percent b is for Boolean values.

Percent c is for characters.

Percent d is for signed decimal integers.

Percent e is for floating point numbers in scientific format.

Percent f is for floating point numbers in decimal format.

Percent g is for floating point numbers in either decimal or scientific format, depending on the value passed as an argument.

Percent h is for the hashcode of the passed argument.

Percent n is for a line separator, or new line character.

Percent o is for integers formatted as octal values.

Percent s is for strings.

Percent t is for date and time values.

Percent x is for integers formatted as hexadecimal values.

All of these format symbols are also supported by the format method in the Console class. In general, these format strings and symbols are applicable in a wide variety of places in the Java standard library.

If you do not specify any string formatting specifier, the printf method will not print anything from the given arguments.

Flags such as the minus sign and zero make sense only when you specify a width with the format specifier string.

You can also print the percent character in a format string. However, you need to use an escape sequence for it. In format specifier strings, percent is an escape character, so you need to use double percent to print a single percent sign.

You can use the argument index feature, which is an integer value followed by a dollar sign, to explicitly refer to the arguments by their index position. For example, the following code prints “world hello” because the order of arguments is reversed.

In this example, the printf method is called with the format string percent two dollar s, space, percent one dollar s, space, percent n, and the arguments “hello” and “world.” Here, two dollar refers to the second argument, which is “world,” and one dollar refers to the first argument, which is “hello.”

The less-than symbol in a format string supports relative indexing, allowing you to reuse the argument matched by the previous format specifier. For example, the following code prints “ten a twelve.”

In this code, the printf method is called with the format string percent d, space, percent less-than x, space, percent less-than o, and the argument ten. This prints ten as the decimal value, “a” as the hexadecimal value of ten, and twelve as the octal value of ten.

If you do not provide the intended input data type as expected by the format string, you can get an IllegalFormatConversionException. For instance, if you provide a string instead of an expected integer in your printRow method implementation, you will get an exception indicating that the format specifier d does not match a string type.

Now, let’s talk about input.

It is also possible to use the Console class to get input. There are some existing methods such as readLine and other read-based ones. In these methods, the first argument is the format specifier string, and the following arguments are the values that will be passed to the format specifier string. These methods return the character data read from the console.

Here is an example of how to use the Console class for input and output.

In this code, a Console object is obtained from System.console. If the console is not null, the program prompts the user to enter a username and password. The username is read as a string, and the password is read as a character array. The program then checks if the username is “scrat” and the password is “nuts.” If both match, it prints “login successful!” Otherwise, it prints “wrong user name or password.” Finally, the password array is filled with spaces to clear its contents.

Note that at the end, the password is emptied out. This is a common practice to clear the read password string once its use is over. The Arrays.fill method is used for this purpose. This is a secure programming practice to avoid malicious reads of program data to discover password strings. That is why the readPassword method returns a character array instead of a string. The string object will live in memory and is also immutable, meaning there is no easy way to forcefully destroy its contents. Once the password is read, used, and no longer needed, it is cleared from memory.

Now, let’s move on to streams.

The streams API discussed in earlier chapters is not the same as the IO streams discussed here. They have very different purposes and applications. Streams are ordered sequences of data. Java deals with input and output in terms of streams.

When you read a sequence of bytes from a binary file, the reading is done from an input stream, since the flow of information is from the file towards the runtime. When writing to a file, you use an output stream, since the flow of information is from the runtime to the file.

Character streams are meant for reading or writing to character or text-based input and output, such as text files, text documents, XML, or HTML files. The data is usually UTF-16 encoded and stored. Input and output character streams are called readers and writers, respectively. The abstract classes Reader and Writer, and their derived classes in the Java package, provide support for character streams.

Byte streams are meant for reading or writing to binary data input and output, such as executable files, image files, and files in low-level formats like zip, class, object, and executable files. The data dealt with is bytes, which are units of eight-bit data. Input and output byte streams are simply called input and output streams, respectively. The abstract classes InputStream and OutputStream, and their derived classes, provide support for byte streams.

Mixing different streams for different purposes is not recommended. For example, if you try to read a bitmap image with a Reader, which is a character stream, the character streams will read and parse the bytes as UTF-16. The final result will not be as expected. In this case, you should use a regular InputStream to read the contents of the image.

Let’s look at the hierarchy of character streams.

The Writer class is the base class. Derived from Writer are BufferedWriter, CharArrayWriter, FilterWriter, OutputStreamWriter, FileWriter, PrintWriter, PipedWriter, and StringWriter. OutputStreamWriter is further derived from FileWriter.

The Reader class is the base class for character input streams. Derived from Reader are BufferedReader, CharArrayReader, FilterReader, PushbackReader, InputStreamReader, FileReader, and PipedReader. InputStreamReader is further derived from FileReader.

Now, let’s look at the hierarchy of byte streams.

The InputStream class is the base class. Derived from InputStream are AudioInputStream, ByteArrayInputStream, FileInputStream, FilterInputStream, ObjectInputStream, PipedInputStream, SequenceInputStream, and StringBufferInputStream, which is deprecated. FilterInputStream is further derived into BufferedInputStream, DataInputStream, and PushbackInputStream.

This concludes our overview of format specifiers, input handling with the Console class, and the hierarchy and purpose of character and byte streams in Java.


OutputStream Hierarchy

The OutputStream class in Java serves as the base class for writing byte streams. Several specialized subclasses extend OutputStream, including ByteArrayOutputStream, FileOutputStream, and FilterOutputStream. FilterOutputStream itself has further subclasses, such as BufferedOutputStream, DataOutputStream, and PrintStream. There are also ObjectOutputStream and PipedOutputStream, each designed for specific output scenarios.

Character Streams

Let’s look at a basic example of reading a file from disk. The simplest approach is to use a FileReader and repeatedly call its read method in a loop, printing each character as it is read. However, this method is inefficient and potentially incorrect, especially when dealing with files encoded in UTF-8 or UTF-16. In these encodings, a single character can span multiple bytes—one to four bytes for UTF-8, and two to four bytes for UTF-16. If you read and print one character at a time, you might only capture part of a multi-byte character, resulting in incorrect or garbled output. This approach only works reliably for ASCII-encoded files, where each character is exactly one byte wide.

The code example demonstrates opening a FileReader for a file named "file.txt." It reads characters one by one in a loop, printing each character until the end of the file is reached. If the file is not found, or if an input-output error occurs, appropriate error messages are printed.

As mentioned, this method is crude and not recommended. It is slow and error-prone, especially when the file’s encoding is unknown. A better approach is to use a BufferedReader, which buffers input and can read entire lines or store the contents as a string, making it more efficient and robust.

Byte Streams

Byte streams are used for processing files that do not contain human-readable text. For example, a Java source file is readable, but a compiled .class file is not. The .class file is intended for the Java Virtual Machine, so you must use byte streams to process it. Many file formats include a special number, called a magic number, at the beginning of the file. This allows programs to quickly identify the file type without parsing the entire file. Some text files, especially those using Unicode encodings, may also include a Byte Order Mark, or BOM, to indicate the file’s byte order and encoding scheme.

The code example shows how to read the first four bytes of a file and compare them to the magic number for Java class files, which is "C A F E B A B E" in hexadecimal. If the bytes match, the file is identified as a .class file. If not, it is not a .class file. The code also demonstrates the need for explicit casting when working with byte values in Java, since numeric literals are integers by default.

To write data to files, you can use the OutputStream class. Writing data is essentially the reverse of reading data with InputStream.

Data Streams

There are special types of byte streams called data streams, which make it easier to write and read primitive types in Java, such as byte, short, int, long, float, and double. These types are represented as multi-byte values in the Java runtime, so writing them to a file and reading them back requires careful handling. Data streams write the actual bytes of the internal representation, not a human-readable format. While you could write these values as plain text, it would be much harder to read and parse them, especially for floating-point numbers.

The code example demonstrates writing the numbers one through ten to a file, storing each number as a byte, short, int, long, float, and double. The values are written in that order. When reading the data back, the same order must be followed to correctly reconstruct the original values. This is important because each primitive type has a fixed size—bytes are one byte, shorts are two bytes, ints are four bytes, longs are eight bytes, and so on. Reading the values in a different order would result in incorrect data.

Object Streams

Object streams are similar to data streams, but they are designed to write entire Java objects to files. Java provides serialization rules that allow object instances to be easily written to and read from files.

The code example creates a map of United States presidents and their terms. It then writes this map to a file using an ObjectOutputStream. If the file cannot be created or an input-output error occurs, appropriate error messages are printed.

In summary, Java provides a rich set of classes for reading and writing both text and binary data. Choosing the right stream class and handling encoding and data types carefully is essential for robust file processing.


Let’s walk through the code and concepts described.

The code example demonstrates how to read a serialized object from a file named “object dot data.” It uses an ObjectInputStream to read the object, checks if the object is a Map, and then prints out each entry in the map, showing the president’s name and description. If the file is not found, or if there is an input or output error, or if the class of the object cannot be recognized, the code prints an appropriate error message.

This example is similar to one using a Data stream, but here, a single object instance—specifically, a Map—is written to a file and then read back. The contents of the map are made persistent in the file and are serialized along with the rest of the object’s properties.

Serialization is the process of converting the contents of objects in memory, along with metadata describing those contents, into a format that can be stored or transmitted. If an object contains references to other objects, the serialization mechanism includes those as part of the serialized data as well. When Java serializes data, it includes not only the object’s data, but also metadata about the class type. This allows Java to reconstruct the exact type of the object during deserialization. This process works for built-in types like Map, List, and Set, as well as for custom user-defined objects.

A key property included during serialization is the serialVersionUID. This is a unique identifier that acts as a version number for the class. When an object is written to a file and later read back, the serialVersionUID in the file is compared with the one in the current class definition. If they do not match, deserialization will fail. The serialVersionUID helps ensure that a serialized object is compatible with the class definition it is being deserialized into. This is important for maintaining backward compatibility when you change the class over time.

While the Serializable interface is required for an object to be serialized, the serialVersionUID field helps control versioning and compatibility during serialization and deserialization. If you do not explicitly declare this UID, Java generates it automatically based on the class structure. This can lead to issues if the class changes, because the generated UID will also change.

Imagine you have a user class that was written to a file in its initial version. Some objects of this class were serialized. Over time, the class definition changes—new fields are added or old ones are removed. Java has no way to know how to read this new, modified version of the user class from the file. In such situations, it is possible to customize how an instance is read from the file at the user level.

There are special private methods that are not overrides or overloads of any methods in the Object class. These methods are only recognized by the Java serialization pipeline. They are called readObject, which takes an ObjectInputStream as a parameter, and writeObject, which takes an ObjectOutputStream. These methods allow you to manually control how an object is written or read. In the example above, reading and writing can be tied to changes in the class, or the process can be customized to handle future changes in the class’s declaration.

For example, consider a class called CustomUserClass that implements Serializable. Inside this class, you can define a private writeObject method that writes the default fields and then writes a custom field. Similarly, you can define a private readObject method that reads the default fields and then reads the custom field. This approach gives you flexibility to handle changes in the class structure over time.

Now, let’s move on to the summary of key points.

Summary

To read and write data from the console, Java provides three public static fields in the System class: in, out, and err. These represent the standard input, output, and error streams. System.in is of type InputStream, while System.out and System.err are of type PrintStream.

You can redirect these standard streams by calling the methods System.setIn, System.setOut, and System.setErr.

You can obtain a reference to the console using the System.console method. If the Java Virtual Machine is not associated with any console, this method will fail and return null.

The Console class provides many methods for formatted input and output. You can use the printf and format methods to print formatted text. The overloaded readLine and readPassword methods can take format strings as arguments.

The template for format specifiers is as follows: a percent sign, followed by optional flags, width, and precision, and ending with a data type specifier. In the format string, the flags, width, and precision are optional, but the percent sign and data type specifier are mandatory.

Use the readPassword method for reading secure strings such as passwords. It is recommended to use the fill method of the Array class to clear the password from the character array after reading, to avoid malicious access to the typed passwords.

Now, let’s discuss the java.io package.

The java.io package provides classes that support both character streams and byte streams.

Character streams are used for text-based input and output, while byte streams are used for data-based input and output.

Character streams for reading and writing are called readers and writers, represented by the abstract classes Reader and Writer.

Byte streams for reading and writing are called input streams and output streams, represented by the abstract classes InputStream and OutputStream.

You should use character streams for processing text files or human-readable files, and byte streams for data files. If you use the wrong type of stream, your program may not work as expected, or you may encounter subtle bugs. Therefore, do not mix up streams—use the right stream for the task at hand.

For both byte and character streams, you can use buffering. Buffer classes are provided as wrappers for the underlying streams. Using buffering will speed up input and output when performing bulk operations.

For processing data with primitive data types and strings, you can use data streams.

Finally, you can use object streams—specifically, the ObjectInputStream and ObjectOutputStream classes—for reading and writing objects in memory to files and vice versa.


