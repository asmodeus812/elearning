NIO Streams

Java offers a rich set of application programming interfaces, or APIs, that you can use to manipulate files and directories. In Java 7, a new set of input and output APIs was introduced, called NIO dot two, which stands for New I/O. This update provided convenient ways to perform operations related to the file system. Starting with Java 8, these APIs can also be used alongside the Stream API.

Path

All file systems are typically organized as a tree structure. The file system starts with a root directory, which contains files and other directories. Each directory, in turn, may have its own subdirectories or files. To locate a specific file, you need to combine the directories from the root down to the immediate directory containing the file, and then add the file name itself, using the correct file separator for your operating system. This combination forms a unique resource name, or identifier, for the file on disk—sometimes called a URN.

A path can be either absolute or relative. An absolute path always starts from the root directory. A relative path, on the other hand, is defined in relation to the current working directory. The current working directory is the directory from which a program or process is started, and it is always an absolute path from the root. The operating system provides ways to obtain this current working directory.

Another important concept is symbolic links. A symbolic link acts like a pointer or reference to an actual file. In general, symbolic links are transparent to applications, meaning that most operations are performed directly on the files they point to, rather than on the links themselves. However, certain operations, such as deleting or moving, may behave differently. Symbolic links are often referred to as "sym links" in practice.

The Path interface is a programming abstraction for a file or directory path. A Path object contains the names of directories and files that make up the full path to a resource. The Path abstraction provides methods to extract, manipulate, and append path elements. Almost all methods that access or manipulate files and directories use Path objects.

The new Path interface is the cornerstone of the NIO library and serves as the building block for much of the API.

Here are some key methods provided by the Path interface:

The getRoot method returns a Path object representing the root of the given path, or null if the path does not have a root.

The getFileName method returns the file or directory name of the given path. This is always the last element in the path.

The getParent method returns the Path object representing the parent of the given path, or null if there is no parent component.

The getNameCount method returns the number of file or directory names in the given path. If the path represents the root, it returns zero.

The getName method returns the file or directory name at a specific index, starting from zero, which is closest to the root.

The subpath method returns a Path object that represents a portion of the original path, starting at a given index and ending just before another index. If the indices are out of range or invalid, this method throws an exception.

The normalize method removes redundant elements in the path, such as the single dot, which indicates the current directory, and the double dot, which indicates the parent directory.

The resolve method combines the current path with another path and returns the resulting path.

The isAbsolute method returns true if the path is absolute, and false if it is relative.

The startsWith method checks if the current Path object starts with a given path.

The toAbsolutePath method returns the absolute version of the path.

Information

In the following example, you will see how to obtain full information for a given path that points to a test file on the D drive in Windows.

This code creates a Path object for the file located at D colon backslash test backslash testfile dot t x t. It then retrieves and prints basic information about the path, such as the file name, the root of the path, and the parent directory. Finally, it iterates over the elements of the path and prints each one. This demonstrates how to use the Path interface to access and display detailed information about a file path.


Let’s walk through what the output of this code might look like. The path elements are printed from top to bottom. In this example, there are only two elements, and the root drive is not included. The path instance is obtained using the Paths utility class. You call the get static final method, passing in the path location. The get method can accept a variable number of string arguments, which represent the path elements. This means you can build a path from individual elements, for example, by calling Paths dot get with the arguments D colon, test, and testfile dot t x t.

The code prints information about a file. It displays the file name, which is testfile dot t x t, the root of the path, which is D colon backslash, and the parent of the target, which is D colon backslash test. Then, it prints the elements of the path, listing test and testfile dot t x t.

Next, let’s look at how to obtain an object for a relative path. This is based on where the program is started. The actual current path will be used, and this is where the Test directory will be resolved to point to. For example, it might resolve to the current absolute path, followed by backslash Test. Note that calling the toRealPath method will fail if the Test directory does not exist. The toRealPath method tries to resolve the real path to this directory, and if it does not exist, it throws an exception.

In the code, a path object is created with a relative path, using Paths dot get with dot backslash Test. The code then prints the file name, its URI, its absolute path, and its normalized path. Another path object is created with the normalized relative path, and its normalized absolute path is printed. Finally, the code attempts to print the normalized real path, but this will throw an exception if the directory does not exist.

To summarize, this code demonstrates how to create a Path object for a relative path, print various representations of the path, and handle the exception that occurs when trying to resolve a non-existent directory to its real path. It also shows the difference between the URI, absolute path, and normalized absolute path. The URI and absolute path include the slash and the dot, while the normalized absolute path does not. This is why it is good practice to normalize a path, especially if it comes from user input, before performing any operations on it.

When the code is run, the output shows the file name as Test. The URI is displayed as file colon slash slash slash D colon slash O C P J P slash programs slash N I O 2 slash dot slash Test. The absolute path is D colon backslash O C P J P backslash programs backslash N I O 2 backslash dot backslash Test. The normalized path is simply Test. The normalized absolute path is D colon backslash O C P J P backslash programs backslash N I O 2 backslash Test. Finally, an exception is thrown, specifically a No Such File Exception, because the Test directory does not exist.

The toPath method in the java dot i o dot File class returns a Path object. This method was added in Java 7. Similarly, you can use the toFile method in the Path interface to get a File object. These methods serve as bridges between the old I O and the new N I O, which Java provides out of the box.

Comparison

The Path interface provides two methods to compare Path objects: equals and compareTo. The equals method checks if two Path objects are equal and returns true or false. The compareTo method compares two Path objects character by character and returns an integer. It returns zero if the paths are equal, a negative integer if the current path is lexicographically less than the parameter path, and a positive integer if it is greater.

In the example, two Path objects are created. The first is path one, which is Paths dot get with the argument Test. The second is path two, which is Paths dot get with the argument D colon backslash O C P J P backslash programs backslash N I O 2 backslash Test. The code compares the two paths using the compareTo method and prints whether the result is zero. It also compares the two paths using the equals method and prints the result. Finally, it compares path two with the absolute path of path one using equals and prints the result.

Assume that the current working directory is D colon backslash O C P J P backslash programs backslash N I O 2. The output of these comparisons will show that comparing path one and path two directly yields false, both for compareTo and equals. However, when the relative path is converted to an absolute path, the equals check passes. This is because the Path class does not make any hidden assumptions. Even though the two paths are logically the same, one is relative and the other is absolute, so their data fields are not identical. This is a good design, as you would not want the library to assume that relative and absolute paths are always equal.

The output of the comparison code is as follows. The result of path one compareTo path two equals zero is false. The result of path one equals path two is false. The result of path two equals path one to absolute path is true.

Files

The previous sections discussed how to create and work with Path instances, and how to extract useful information from them. In this section, Path objects are used to manipulate files or directories. Java 7 introduced the Files class, which is in the java dot nio dot file package. This class can be used to perform various file-related operations on files or directories. The Files class is a utility class, meaning it is final, has a private constructor, and consists only of static methods. You can use the Files class by calling its static methods, such as copy, to copy files. This class provides a wide range of functionality.


File and Directory Operations in Java NIO

Let’s walk through some of the key methods available for working with files and directories using Java’s NIO Path API.

First, the createDirectory method creates a new directory at the specified path, applying any given file attributes. If the directory already exists, or if the attributes cannot be set as requested, an exception may be thrown. In contrast, the createDirectories method will create not only the target directory, but also any intermediate directories along the path that do not already exist.

Next, the createTempFile method is used to create a temporary file in a specified directory. You can provide a prefix and suffix for the file name, as well as any desired file attributes. Similarly, the createTempDirectory method creates a temporary directory with a given prefix and attributes in the specified location.

The copy method copies a file from a source path to a target path. You can specify options such as replacing an existing file, copying file attributes, or not following symbolic links. If the target file already exists, or if another error occurs, an exception may be thrown.

The move method is similar to copy, but after the operation, the source file is removed. If the source and target are in the same directory, this effectively renames the file.

To check if two Path objects refer to the same file, use the isSameFile method. This is useful for verifying file identity, especially when working with symbolic links or different path representations.

The exists method checks whether a file or directory exists at the given path. You can specify whether to follow symbolic links or not.

To determine if a path represents a regular file, use the isRegularFile method. For symbolic links, use isSymbolicLink. To check if a file is hidden, use isHidden.

The size method returns the size of the file in bytes.

To get or set the owner of a file, use getOwner and setOwner. These methods allow you to retrieve or change the user principal associated with the file.

For file timestamps, getLastModifiedTime retrieves the last modified time, while setLastModifiedTime allows you to update it.

Finally, getAttribute and setAttribute provide a way to get or set specific attributes of a file, such as permissions or custom metadata.

These methods form the foundation for robust file and directory management in Java applications, offering both flexibility and control over file system operations.


Metadata

To quickly check some basic file metadata, you can use several methods provided by the Java NIO package. In a previous section, we looked at how to determine if two paths point to the same file. There is a more robust way to do this using the isSameFile method.

In this approach, you create two Path objects—one relative and one absolute—and then use Files.isSameFile to check if they refer to the same file on disk. If either file or directory does not exist at the given path, a NoSuchFileException will be thrown.

To avoid such exceptions, you can first check if a file or directory exists using the exists or isDirectory methods. For example, you can create a Path object and then use Files.exists with the NOFOLLOW_LINKS option to check for its existence. If it exists, you can further check whether it is a directory or a file using Files.isDirectory. It is important to note that the exists method alone cannot tell you if the path is a directory or a file, and sometimes the path itself does not provide enough information. This is especially true on operating systems where files and directories can have the same names, or where files do not have extensions. Using these methods helps you avoid unnecessary exceptions in your code, which is generally considered good practice.

To check if you have permission to read or write to a file or directory, you can use the isReadable and isWritable methods. There is also an isExecutable method to check if a path points to an executable file. For example, if you have a path that points to a directory, and you check its readability and writability, these calls should return true. However, checking if it is executable will typically return false for directories.

To get a broader view of a file’s attributes, you can use the getAttribute method. This allows you to retrieve properties such as creation time, last modified time, size, whether the file is hidden, and whether it is a directory. The tricky part here is specifying the correct attribute name pattern. The attribute name should be in the format view:attribute, where view is the type of FileAttributeView and attribute is the name of the attribute supported by that view. If you do not specify a view, it defaults to the basic view. For example, creationTime, size, and isDirectory are basic view attributes and are supported across operating systems. If you provide an incorrect view or attribute name, an UnsupportedOperationException will be thrown.

There is also a way to read all attributes of a file or directory at once. Instead of retrieving them one by one, you can use the readAttributes method with the appropriate attribute class, such as BasicFileAttributes. This allows you to access properties like file size, whether it is a directory, a regular file, a symbolic link, and the last access and modification times. There are also PosixFileAttributes and DosFileAttributes for POSIX and DOS compliant operating systems, which provide OS-specific file attributes. However, you should check the current operating system type before using these attribute types.

Copying

Copying a file is straightforward using the copy method from the Files class. The third argument to the copy method specifies file copy options, such as what to do if the destination file already exists. For example, if you copy a file from a source path to a destination path, and the destination file already exists, the operation will throw a FileAlreadyExistsException by default. To force the copy to overwrite the existing file, you can pass the REPLACE_EXISTING option as the third argument.

It is important to note that if the destination is a directory path that does not exist, a NoSuchFileException will be thrown. The full destination path must exist before you can copy a file or directory. If you are copying a directory, the destination location must exist, but the target directory itself will be created as part of the copy.

For example, if you are copying a directory named Test, the source directory must exist, as well as the destination location. The same applies when copying a file, such as test.txt—the source file and the destination location must both exist.

It is important to note that the copy method does not copy the files or directories contained within a directory. It only copies the top-level directory itself. If you want to copy the contents of a directory, you must do so recursively or explicitly.

Moving

Moving a file is similar to copying, but with some differences. Like the copy operation, the move method must handle the case where a file or directory already exists at the destination. You can provide explicit instructions to replace the destination if it already exists by passing the REPLACE_EXISTING option. Otherwise, a FileAlreadyExistsException will be thrown.

If you are moving a symbolic link, only the link itself is moved, not the file or directory it points to. There is an option to move the file itself by using the FOLLOW_LINKS option. A non-empty directory can be moved as long as the move does not require moving the contained files or directories separately. If the move is successful, all contained files and directories are moved as well.

You can also specify that the move should be performed as an atomic operation using the ATOMIC_MOVE option. With this option, either the entire move completes successfully, or the source remains unchanged. If the move is not atomic and fails during the process, the state of both the source and destination files or directories is undefined.

Deleting

Now, let’s move on to deleting files and directories.


The Files class provides a delete method as well. This method can be used to delete a file, a directory, or a symbolic link. There are a few important points to remember about deleting, especially when it comes to directories. The delete method should only be invoked on an empty directory—otherwise, it will fail. In the case of a symbolic link, only the link itself is deleted, not the target file that the link points to. The file or directory you intend to delete must actually exist; otherwise, a No Such File Exception will be thrown.

If you want to delete a file silently, you can use the deleteIfExists method instead. This method does not throw an error if the file does not exist, and it deletes the file if it does exist. Also, keep in mind that if a file is read-only, some platforms may prevent you from deleting it.

The API for the delete method is quite simple. It accepts only the path of the target to be deleted. No other options or actions can be passed to this method, or to the deleteIfExists method. In summary, you call the delete method on the Files class, passing in the path of the file or directory you want to delete.

Notes

Here are some general notes in relation to the classes already reviewed.

Do not confuse the File class with the Files class, or the Path interface with the Paths class. These are very different. File is an older class that represents file or directory path names. Files, on the other hand, was introduced in Java 7 as a utility class with comprehensive support for input and output operations. The Path interface represents a file or directory path unit and defines a useful list of methods. However, the Paths class is a utility class that offers only two methods, both of which are used to construct path objects.

The file or directory represented by a Path object may not actually exist. Other than methods such as toRealPath, most methods in Path do not require that the underlying file or directory be present for a Path object to be created.

Streaming

As already mentioned, the Stream API, which was added in Java 8, can be used along with the new Files and Path classes from the NIO package. There are several new methods in the Files class that produce streams, which can then be used to read file contents or metadata.

List

The list method lists all files or directories in the current directory. Internally, it uses DirectoryStream, so the close method must be called to release the input and output resources.

In the code example, a stream of Path objects is obtained by calling the list method on the Files class, passing in the current directory. The stream is used in a try-with-resources block to ensure that it is closed properly, releasing any underlying resources. Each entry in the stream is printed out. This approach is smart because DirectoryStream itself does not extend Stream, but its iterator is wrapped around an anonymous Stream implementation.

The list method does not perform any recursive traversal. It simply lists the entries in the current path. There is a recursive version of list, called walk, which walks the tree formed by the path passed in as an argument.

The walk method can be used to recursively traverse a directory tree. It accepts a path, an optional maximum depth, and an optional FileVisitOption, such as FOLLOW_LINKS. The maxDepth argument is useful when you want to limit how deep the traversal goes. Note that using FOLLOW_LINKS does not guarantee that infinite recursion cannot occur. The walk method has no built-in loop detection. For example, if there is a symbolic link somewhere in the tree that points to a parent directory, infinite recursion could occur.

In the code example, the walk method is used to traverse the current directory, following symbolic links and restricting the depth to a maximum of four levels. The number of entries found is then printed out.

Find

The find method is used to locate a file somewhere in the current directory tree formed by the path argument. Find is built on top of walk and does essentially the same operations, with the only difference being that only the files that match a given predicate are returned by the stream. It is effectively like applying a filter operation to the walk method, but it is much more efficient. The method signature of find matches that of walk.

The find method returns a stream that is lazily populated with Path objects by searching for files in a file tree rooted at a given starting file. For each file encountered, a given BiPredicate is invoked with its Path and BasicFileAttributes. The Path object is obtained as if by the walk method.

Lines

There is also a way to obtain the lines from a file using the lines or readAllLines methods. Both are slightly different. The lines method returns a stream of strings, which is an anonymous implementation that wraps around the NIO operations. The stream can then be used to read the lines lazily. This means that, depending on the type of operation—such as findFirst or findAny—there might be cases where not the entire file is read. For example, only the first N number of lines might be read, and then the stream is closed, which also closes the internal file resources held by it.

The readAllLines method, however, is different. It eagerly reads the entire file and all of the lines in the file, returning a list of strings.

In the code example, a stream object is obtained for the lines of the file pointed to by the given path. The returned stream is an anonymous implementation that wraps the file resource and input and output operations to obtain the lines lazily as the stream is being iterated over. This can be more efficient, depending on what operations are applied to the stream. In the example, the entire file is read and all lines are printed, but that might not always be the case. Internally, the Files.lines method uses BufferedReader.lines, which returns a stream.

Summary

Let’s review the key points about the Path interface and its operations.

A Path object is a programming abstraction used to represent the path of a file or directory. You can get an instance of Path using the get method of the Paths class. Path provides two methods to compare Path objects: equals and compareTo. Even if two Path objects point to the same file or directory, the equals method is not guaranteed to return true.

For reading, deleting, copying, moving, and managing metadata:

You can check the existence of a file using the exists method of the Files class. The Files class also provides the methods isReadable, isWritable, and isExecutable to check whether the program can read, write, or execute a file programmatically. You can retrieve the attributes of a file using the getAttributes method. You can use the readAttributes method of the Files class to read file attributes in bulk. The copy method can be used to copy a file from one location to another. Similarly, the move method moves a file from one location to another. While copying, all the directories—except the last one, if you are copying a directory—on the specified path must exist to avoid a No Such File Exception. Use the delete method to delete a file, and use the deleteIfExists method to delete a file only if it exists.

For streams and NIO version two:

The Files.list method returns a stream of Path objects. It does not recursively traverse the directories in the given path. The Files.walk method returns a stream of Path objects by recursively traversing the entries from the given path. In one of its overloaded versions, you can also pass the maximum depth for such traversal and provide FileVisitOption.FOLLOW_LINKS as an option. The Files.find method returns a stream of Path objects by recursively traversing the entries from the given path. It also takes the maximum depth to search, a BiPredicate, and an optional FileVisitOption as arguments. Files.lines is a very convenient method to read the contents of a file. It returns a stream of strings.

This concludes the overview of the Files and Path classes, their methods, and how they interact with the Stream API for efficient file and directory operations in Java.


