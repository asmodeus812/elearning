Net.io

Networking

Let’s begin with the basics of networking, which revolve around the concept of sockets. A socket is a fundamental building block in the networking world. Each machine can open any number of socket connections, allowing other machines to connect to it or to receive information from it.

The socket, sometimes called the Berkeley Socket, was invented during the UNIX era in the nineteen seventies. Its main purpose is to represent an endpoint for both receiving and sending information. This duplex mode allows it to handle both directions of communication at the same time.

A socket is defined by two main components. The first is the IP address, which provides a unique address for the device on the network. The second is the port number, which identifies a specific process or service running on that device.

The IP address of a machine is usually defined by either the IPv4 or IPv6 versions. Both serve the same purpose, but the main difference is the range of addresses each can represent. IPv4 can only represent four octets, totaling thirty-two bytes, which allows for about four billion unique combinations. In contrast, IPv6 can represent many more—about one hundred twenty-six bytes of information—enabling trillions of unique addresses.

The typical socket lifecycle starts when an application, such as a web server, creates a socket on a specific port. This means the application will be listening on that port for incoming connections and information. It can also send information on the same socket, which is common for web servers.

When a socket is created, it is said to be bound. This means the underlying operating system starts listening for incoming connections on that port. When a client wants to connect to the server application, it must create its own socket using the server’s unique IP address and the port number that identifies the application it wants to communicate with.

The operating system on the server may accept or deny the connection. Furthermore, the process running on that port—such as the web server—might also deny the connection unless certain conditions are met. Once the connection is established between the client and server sockets, communication can begin.

There are two main types of sockets in widespread use on the internet, each using different protocols to transmit data. While the IP protocol is used at a lower level to transmit data, it does not guarantee data integrity. It simply streams data from one socket to another, whether from server to client or vice versa.

To ensure reliable data transmission, two main protocols are widely used. The first is TCP, or Transmission Control Protocol, which provides reliable, ordered, and error-checked delivery of a stream of bytes. This is mostly used in applications where the delivery of information is crucial, such as web browsing and file transfers. The second is UDP, or User Datagram Protocol. Unlike TCP, UDP is not a streaming-based protocol. It sends messages without establishing a connection, resulting in lower overhead. This makes it suitable for applications that require fast, real-time communication, such as video streaming or online gaming, where some data loss is acceptable.

TCP and IP sockets are used to implement reliable, bidirectional, persistent, point-to-point, stream-based connections between hosts on the internet. A socket can be used to connect Java’s input and output system to other programs, whether they reside on the local machine or on any other machine on the internet.

InetAddress

The InetAddress class is used to encapsulate both the numerical IP address and the domain name for that address. You can interact with this class using the name of the IP host, which is more convenient and understandable than using its IP address directly. InetAddress can handle both IPv4 and IPv6 addresses.

To create an instance of InetAddress, you use one of its factory methods, since it does not have a public constructor. These static methods allow you to create an instance from a given host name or domain name. Internally, the implementation uses DNS lookup to resolve the actual IP address for the given host. In Java, this is done by asking the underlying operating system to resolve the domain name to an IP address. The operating system, in turn, uses the configured DNS server to perform the lookup.

Typically, your internet service provider, or ISP, supplies default DNS servers, which are automatically configured when your machine connects to the internet. This configuration is handled through DHCP, or Dynamic Host Configuration Protocol.

DHCP is a network management protocol. It is the first exchange that occurs when a machine connects to the internet. The machine requests an IP address and other configuration settings from the network, including the default DNS server address. The DNS server provided is usually owned by the ISP, which may also offer additional features such as parental controls or an internet control panel.

Here’s how the DHCP process works. First, when you connect your device—such as a computer, smartphone, or tablet—to a network, it sends a broadcast message to the local network, requesting an IP address and other configuration settings. Next, the device sends a DHCP Discover message to find available DHCP servers on the network. Any DHCP server that receives this message responds with a DHCP Offer, which includes an available IP address, subnet mask, default gateway, and DNS server information.

The device may receive one or more DHCP offers and selects one of them. It then sends a DHCP Request message back to the selected server, indicating that it has accepted the offer. The DHCP server acknowledges this with a DHCP Acknowledgment, or ACK, confirming that the device can use the provided IP address and other settings, including the DNS server information. Once the DHCP ACK is received, the device configures itself with the IP address, subnet mask, default gateway, and DNS server or servers as specified by the DHCP server. The DNS server address is now set for use in resolving domain names to IP addresses.

Java includes support for both IPv4 and IPv6 addresses. To accommodate this, two subclasses of InetAddress were created: Inet4Address and Inet6Address. Inet4Address represents a traditional IPv4 address, while Inet6Address encapsulates a newer IPv6 address. Because they are subclasses of InetAddress, a reference to InetAddress can refer to either type. This approach allowed Java to add IPv6 functionality without breaking existing code or introducing many new classes. For most purposes, you can simply use InetAddress when working with IP addresses, since it can handle both styles.

Byte Order — Endianness

The order in which bytes are transmitted on a network is also well defined. In computing, there are two main ways to order bytes. Some processors use different byte order representations internally, but this is usually hidden from the user, and the operating system ensures consistency.

The first method is called big endianness. In this approach, a multi-byte value is ordered from the lowest to the highest bytes. In other words, the lower bytes of a multi-byte value are placed at a lower address than the higher ones. For example, the hexadecimal value twelve thirty-four fifty-six would be represented as the three bytes: twelve, thirty-four, fifty-six.

The second method is called little endianness. Here, a multi-byte value is ordered from the highest to the lowest bytes. The higher bytes are placed at a lower address than the lower ones. Using the same example, the hexadecimal value twelve thirty-four fifty-six would be represented as the three bytes: fifty-six, thirty-four, twelve.

In the networking world, the big endianness approach is always used. This means that the order of bytes in multi-byte values matches their actual representation.

Sockets

In Java, there are two main types of sockets, each meant for a different purpose. The first is the ServerSocket, and the second is the Socket class for clients. The main difference is that the ServerSocket is blocking, since it acts as a listener. It waits for clients to connect to it, because otherwise, there would be no one to serve information to.


When a Socket, also known as a client socket, is created, it automatically tries to establish a connection to the server socket at the specified address. This means there are no separate methods to explicitly connect; if the socket is created successfully, you can immediately start sending data through it.

There are several ways to create a socket in Java. For example, you can create a socket by providing an Internet address and a port, by specifying a host name and a port, or by using an IP address and a port. Each of these constructors will attempt to connect to the server as soon as the socket object is created.

Let’s look at a minimal example. This code connects to the public WHOIS server at whois.internic.net on port forty-three. It then gets the input and output streams from the socket. The output stream is used to send a request, and the input stream is used to read the response from the server.

In this example, a string containing the domain name is sent to the server. The server responds with information about the domain, such as the domain name, registry ID, registrar details, creation and expiry dates, name servers, and more. The code reads this response byte by byte and prints it to the console. Finally, the socket is closed.

WHOIS is a protocol used to query databases that store registered domain names and IP addresses. It allows you to retrieve information about who owns a domain or an IP address, as well as registration dates, contact details, and the registrar responsible for the domain.

URL

A Uniform Resource Locator, or URL, is a way to locate a resource on the internet and provides a means to interact with that resource. A URL is made up of several components.

First, there is the scheme. This is the initial part of the URL and specifies which protocol should be used to access the resource. Common schemes include HTTP, HTTPS, file, gopher, and FTP.

Next is the host. This is the middle part of the URL and specifies the host or domain name where the resource can be found. Usually, this is resolved to an IP address using DNS, but you can also use an IP address directly in the URL.

The port is another component. It is optional and, if omitted, is usually inferred based on the protocol. For example, HTTP uses port eighty by default, HTTPS uses port four hundred forty-three, and FTP uses port twenty-one. The first one thousand twenty-four ports are reserved for special purposes.

Here are some examples of protocols and their default ports. HTTP uses port eighty, so a typical URL would be http://example.com. HTTPS uses port four hundred forty-three, as in https://example.com. FTP uses port twenty-one, for example, ftp://ftp.example.com. The file protocol does not use a port, as in file:///C:/example.txt. SFTP uses port twenty-two, SMTP uses ports twenty-five and five hundred eighty-seven, Telnet uses port twenty-three, and WebSocket uses ports eighty and four hundred forty-three.

The Java networking package provides ways to construct URL objects. The base class is called URL, and it has several overloaded constructors. You can create a URL from a string, from a protocol, host, and path, or by specifying the protocol, host, port, and path. You can also resolve a relative URL within a base context, or use a custom stream handler for managing protocols.

It is important to note that all of these constructors can throw a MalformedURLException if the provided string does not represent a valid URL format.

Here is an example. The code creates a URL object for the address http://www.HerbSchildt.com/WhatsNew. It then prints out the protocol, port, host, path, and the full external form of the URL. When you run this code, you will see output showing the protocol as HTTP, the port as negative one, which means the default port is used, the host as www.HerbSchildt.com, the path as slash WhatsNew, and the external form as the full URL.

URLConnection

A URLConnection is a special type of object that you can obtain from a URL instance by calling the openConnection method. This creates a URLConnection object, which internally establishes a connection to the URL, often by creating a socket connection. For protocols like HTTP, HTTPS, and FTP, this means opening a socket to the server.

URLConnection is a high-level abstraction that uses protocol handlers. For example, for HTTP and HTTPS requests, it wraps around the Socket API. For other protocols, different handlers are used. This abstraction allows you to communicate with a resource server without worrying about the low-level details of the protocol.

The actual connection is established when you call connect, getInputStream, or getOutputStream on the URLConnection. This sets up the communication link between your application and the remote server.

For example, to make a regular GET request and fetch data from a target URL, you would create a URL object, open a connection, get the input stream, and read the response line by line. This allows you to retrieve the contents of a web page or other resource.

To make a POST request and send data to the target URL, you would follow a similar process, but configure the connection for output and write your data to the output stream. This is useful for submitting forms or sending data to a server.


This section begins with an example of how to make an HTTP POST request in Java using the HttpURLConnection class. The code creates a URL object pointing to a login page, opens a connection, sets the request method to POST, and specifies that output will be sent. It also sets the content type to indicate form data, then writes the username and password as form-encoded data to the request body. This is a typical pattern for sending login credentials or form data to a web server in Java.

Next, let's discuss the different classes that implement the URLConnection interface in Java. Each of these classes is designed to handle communication with URLs using different protocols.

The HttpURLConnection class provides features specific to the HTTP protocol, such as handling various HTTP methods like GET and POST, and managing HTTP headers and responses.

The HttpsURLConnection class extends HttpURLConnection and adds support for secure HTTPS connections, enabling encrypted communication using SSL or TLS.

The JarURLConnection class is used for accessing resources inside JAR files, allowing you to read entries from a JAR archive.

The FileURLConnection class enables access to local files using the file protocol, making it possible to read files from the local filesystem.

The FtpURLConnection class is designed for accessing resources over the FTP protocol, which is commonly used for file transfers.

Finally, the DataSourceURLConnection class is used for reading data from DataSource objects, which is a pattern often seen in JavaMail for accessing resources.

Now, let's talk about the URI class. The URI, or Uniform Resource Identifier, is a more general concept than a URL. While a URI simply identifies a resource, a URL, or Uniform Resource Locator, not only identifies the resource but also provides information on how to access it. In other words, every URL is a URI, but not every URI is a URL. For example, a URI that includes a scheme locator, such as "https://www.example.com," is considered a URL. In contrast, a URI that serves as a unique name, like "urn:isbn:12345," is called a URN, or Uniform Resource Name.

Moving on to cookies. Cookies are a mechanism for maintaining a stateful connection between a server and a client. Typically, a cookie is sent with each request and response, allowing the server to recognize and track individual clients. The server sends a cookie header in its response, and the client includes the same cookie in subsequent requests. This process enables the server to uniquely identify different clients.

In addition to regular cookies, there are companion cookies such as CSRF tokens. These are used to secure cookies and ensure that requests are coming from legitimate clients, not from malicious actors.

In Java, the HttpCookie class provides a generic implementation of an HTTP cookie. This class works together with the CookieStore interface and the CookieManager class. The CookieManager acts as a bridge between HttpURLConnection and HttpCookie, using a CookieStore implementation internally to manage cookies for multiple HTTP requests and responses.

To set up cookie management, you typically set a default CookieHandler using the CookieManager. For example, you might call CookieHandler.setDefault with a new CookieManager instance. This ensures that all HTTP requests and responses automatically use the specified CookieManager.

Internally, the link between HttpURLConnection and the cookie management system is handled by the platform-specific implementation, which uses CookieHandler.getDefault to retrieve the default CookieManager. This is the mechanism that ensures each HttpURLConnection is properly populated with cookies.

The HttpCookie class provides several constructors for creating cookies with different parameters, such as name, value, header, and creation time. The HttpURLConnection class also has constructors for creating connections to specific URLs, hosts, and ports.

The relationship between these classes can be visualized as follows: CookieHandler is used by HttpURLConnection. CookieManager implements CookieHandler and uses CookiePolicy, HttpCookie, and CookieStore. CookieStore, in turn, has an internal in-memory implementation.

Here's a summary of how to use CookieManager in practice. First, you create a CookieManager and set it as the default CookieHandler. Then, you make an HTTP connection using HttpURLConnection. When you send a request, any applicable cookies from the store are automatically added. After receiving the response, you can check for any cookies sent by the server, which are also automatically added to the store. You can then retrieve cookies from the store for a specific URI and process them as needed.

Now, let's discuss CSRF tokens. Cross-Site Request Forgery, or CSRF, tokens are a critical security mechanism for protecting web applications from unauthorized actions initiated by third-party sites. By embedding a unique, unpredictable token in each state-changing request and validating it on the server side, web applications can ensure that only legitimate actions performed by authenticated users are allowed.

CSRF tokens are effective because they are tied to both the user's session and the specific site. An attacker's website cannot access the legitimate site's CSRF token, so it cannot include the correct token in any malicious request.

A typical CSRF protection flow works as follows. When the user loads a page, the server sets two cookies: one HTTP-only cookie for the session, and another HTTP-only cookie for the CSRF token. When the user makes an API call, such as with fetch or XMLHttpRequest, the browser reads the CSRF token cookie and includes it in a special header, often called X-CSRF-Token. The server then verifies both the session and the CSRF token to ensure the request is legitimate.

Finally, let's cover CORS, or Cross-Origin Resource Sharing. CORS is a security feature built on top of the Same-Origin Policy. It allows web servers to explicitly permit cross-origin requests. When a website needs to make a request to another domain, the browser uses CORS to check whether the server hosting the resource allows that request.

The browser determines if a request is cross-origin based on the protocol, domain, and port of both the requesting page and the requested resource. If the server does not respond with the proper CORS headers or explicitly denies cross-origin access, the browser blocks the response from being made available to JavaScript. The request may still be sent, but the browser will refuse to pass the response data back to the page's JavaScript if the CORS policy is not met.

The CORS process typically works as follows. When a script, such as an AJAX call or a fetch request, tries to access a resource from a different origin, the browser first checks if the request adheres to the Same-Origin Policy. If the request is cross-origin, the browser sends a special HTTP request known as a preflight request for certain methods, asking the server if the actual request is allowed.


Let’s begin by discussing the process of a CORS preflight request.

A preflight request is an HTTP OPTIONS request sent by the browser to the server before making an actual cross-origin request. The purpose is to ask the server if it allows cross-origin requests from the requesting origin, and for the specific HTTP method and headers that will be used.

In this example, the browser sends an OPTIONS request to the server at original dot com, with the Origin header set to example dot com. It also includes Access-Control-Request-Method and Access-Control-Request-Headers headers, indicating the method and headers it intends to use in the actual request.

The server, if configured to allow cross-origin requests, responds with headers such as Access-Control-Allow-Origin, Access-Control-Allow-Methods, and Access-Control-Allow-Headers. These headers specify which origins, methods, and headers are permitted.

The browser then checks the returned CORS headers to ensure the request is allowed. If the headers are missing or do not match the request—for example, if the origin is not allowed—the browser will block the response and prevent JavaScript on the page from reading it.

Now, let’s move on to the topic of Datagram sockets in Java.

Datagram

Unlike the regular Socket class, which is designed for TCP packet communication in Java, the Datagram socket implementation is intended for use with UDP-style packets. The Datagram API provides several ways to construct a DatagramSocket, but the constructors are similar to those for regular TCP sockets. You can create a DatagramSocket by specifying a port, a host address, both, or with no arguments at all. If you use no arguments, the socket binds to the first available port on the machine that is not reserved.

The main constructors for DatagramSocket allow you to create a socket with no arguments, with a specific port, with a port and an IP address, or with a SocketAddress object.

The DatagramSocket class provides two key methods: send and receive. The send method transmits a DatagramPacket, while the receive method waits for a packet to arrive and fills the provided DatagramPacket with the received data.

The DatagramPacket class is used to send and receive data through a DatagramSocket. When constructing a DatagramPacket, you must provide a buffer to hold the data. The constructors for DatagramPacket allow you to specify the data buffer, the offset and size within the buffer, and, when sending, the destination IP address and port.

The first two constructors are used when receiving data, as you only need a buffer to store incoming information. The last two constructors are used when sending data, since you must specify the recipient’s address and port.

Next, let’s look at an example Java class called WriteServer.

This class demonstrates how to use DatagramSocket and DatagramPacket to implement a simple UDP-based server and client. The server reads input from standard input, accumulates it in a buffer, and sends it to the client when a newline character is received. The client listens for incoming packets and prints the received data to the screen.

The main method determines whether to start the application as a server or a client based on the number of command-line arguments. If one argument is provided, it starts as a server, binding to the server port. Otherwise, it starts as a client, binding to the client port.

To use the same application as both the server and client, you simply pass a dummy argument when starting the server. For example, running “java WriteServer” starts a client, while “java WriteServer 1” starts a server.

This example illustrates how UDP communication can be implemented in Java using DatagramSocket and DatagramPacket, allowing for simple message exchange between a server and a client.


