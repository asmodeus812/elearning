Generics

Generics in Java provide a way to create classes, interfaces, and methods that operate on types specified by the programmer at compile time. This allows for type-safe code that can be reused for different data types, without sacrificing safety or clarity.

In earlier versions of Java, before generics were introduced, developers would use the Object type to achieve similar flexibility. However, this approach was not type-safe. It required explicit type casting and often led to runtime errors that could have been caught at compile time.

The syntax for generics in Java uses angle brackets. For example, a class might be defined as Generic with a type parameter T. Inside the class, T can be used as the type for fields, method parameters, and return values. This means you can write a class that works with any reference type, and the compiler will enforce type safety.

It’s important to note that generics in Java only work with reference types. You cannot create a generic class that uses primitive types directly. Additionally, you cannot assign references between generically parameterized types with different type arguments. For example, a Generic of Integer is not the same as a Generic of Double. The type parameter is an integral part of the class definition.

Erasure

A key aspect of Java generics is that all generic type information is removed at runtime—a process known as type erasure. This means that, after compilation, the Java Virtual Machine has no knowledge of the generic type parameters used in your code.

This design choice was made to ensure backward compatibility with older versions of Java. Generic code had to work seamlessly with preexisting, non-generic code, so the language and the virtual machine could not be fundamentally changed.

When your code is compiled, the compiler replaces all type parameters with their bound types. If no explicit bound is specified, Object is used. The compiler also inserts the necessary type casts to maintain compatibility. As a result, type parameters exist only in the source code and are not available at runtime.

Ambiguity

Type erasure can sometimes lead to ambiguity, especially when overloading methods that use generics. For example, if you define a generic class with two type parameters, T and V, and then try to overload a method called set with both T and V as parameters, you may encounter a compile-time error.

If both type parameters are the same, such as String, the methods become indistinguishable after type erasure, leading to a conflict. However, if the type parameters are different, such as String and Integer, the methods remain distinct and the code compiles successfully.

To avoid these issues, it’s important to provide bounding restrictions or ensure that your type parameters are from different type hierarchies.

Bounded Generics

Generics become even more powerful when you provide bounds for the type parameters. By specifying a boundary, you give the compiler more information about what methods and properties are available on the type.

For example, you might define a class called Sum with a type parameter T that extends Number. This tells the compiler that T will always be a subclass of Number, so you can safely use methods like integerValue. This allows you to create a generic class that can sum any type of number, such as Double, Integer, or Short.

Unbound Generics and Wildcards

Sometimes, you may want a generic class to interact with another generic class, even if their type parameters are not the same. Java provides wildcards, represented by a question mark, to allow for this flexibility.

For instance, you can define a method that takes a Sum of any type by using Sum with a wildcard. This allows you to compare two Sum objects, even if their type parameters are different, while still maintaining type safety. The compiler knows that the wildcard type extends from a certain base class, such as Number.

Wildcards can also be bounded, meaning you can specify an upper or lower limit on what the wildcard represents.

Upper Boundary

An upper boundary specifies the highest class or type in the hierarchy that can be used in place of the wildcard. Any subclass of the specified boundary is also allowed.

For example, if you define a method that takes a Usage of any type that extends LevelTwo, you can pass in objects of LevelTwo, LevelThree, or any other subclass of LevelTwo.

Lower Boundary

A lower boundary specifies the lowest class in the hierarchy, and any superclass of that class can be used. For example, if you define a method that takes a Usage of any type that is a superclass of LevelTwo, you can pass in LevelTwo, LevelOne, Base, or even Object.

Methods

Generics are not limited to classes—they can also be applied to methods. You can define a generic method inside a non-generic class, giving you even more flexibility.

For example, you might define a method that takes two type parameters, T and V, with specific bounds. T could be required to implement Comparable, and V could be required to extend T. This allows you to compare objects of different, but related, types, as long as they meet the specified constraints.

This approach enables you to write highly flexible and reusable code, while still maintaining type safety.

Constructors

Now, let’s move on to constructors.


Just as with methods, constructors in Java can also be defined as generic, even if their enclosing class is not. This approach provides a more flexible and convenient way to initialize or construct an object from a wide variety of input types.

For example, consider a class called NoGenericClass. It has a constructor that is generic, accepting any type that extends the Number class. Inside the constructor, the value is converted to a double. This means you can create instances of NoGenericClass using any numeric type, such as integers, longs, floats, or doubles. Thanks to Java’s autoboxing feature, you can even use primitive values directly, and they will be automatically converted to their corresponding wrapper classes.

The key takeaway is that this pattern allows you to instantiate the class with many different types of numbers, making the code more flexible and reusable.

Inheritance

When inheriting from or implementing a generic class or interface, there is a specific requirement: the subclass or implementing class must specify the same or a more restrictive boundary for the type parameter. For example, if an interface called MinMax defines a type parameter T that must extend Comparable, then any class that implements MinMax must also specify that T extends Comparable, or a more specific subtype.

To illustrate, imagine an interface MinMax with a type parameter T that extends Comparable. A class called MyClass implements MinMax and also specifies that its type parameter T extends Comparable. This ensures type safety and consistency. If you try to use a less restrictive boundary, the compiler will produce an error.

It is important to note that you can provide a more specific boundary if needed, but you cannot relax the restriction set by the original interface or superclass.

Raw Types

To support older code written before generics were introduced, Java allows you to use a generic type without specifying type parameters. This is known as using a raw type. When you do this, all type safety and compile-time checks are lost, and the generic type is implicitly treated as an Object. This can lead to runtime errors.

For example, you might see code that creates a new instance of a generic class without specifying a type parameter. While this is not a compile-time error, it is not recommended. In contrast, specifying the type parameter, such as Integer, is the correct and safe way to use generics.

Inference

Java provides a feature called type inference, which allows you to omit explicit type arguments when creating an instance of a generic class. This is done using the diamond operator, which is a pair of angle brackets with nothing inside. For example, you might declare a variable of type MyClass with Integer and String as type parameters, and then use the diamond operator when creating the new instance.

The diamond operator tells the compiler to infer the type arguments needed by the constructor. The main advantage of this syntax is that it makes the code shorter and easier to read, especially when dealing with long or complex type declarations.

Restrictions

There are several important restrictions to keep in mind when working with generics in Java.

First, type parameters cannot be instantiated directly. This is because the type parameter, such as T, is just a placeholder, and the compiler does not have enough information to know how to create an instance of it. For example, if you try to write a constructor that creates a new instance of T, the compiler will produce an error.

Second, you cannot declare static members that use the type parameter in a generic class. This is a special case of the previous restriction. Since type parameters are defined on a per-instance basis, the compiler cannot determine how to construct static members that depend on them. For example, declaring a static variable or static method that uses T will result in a compile-time error.

Third, creating arrays of generic types is not allowed. There are two common cases. If you try to create a new array of a generic type, the compiler will complain because it does not have enough information about the type. However, you can assign a reference to an existing array of the correct type. Similarly, you cannot create an array of a parameterized type, such as Gen of Integer, but you can create an array of a wildcard type, such as Gen of question mark, due to type erasure.

Finally, a generic class cannot extend Throwable. This means you cannot create generic exception classes in Java.

These restrictions exist to ensure type safety and to avoid issues related to type erasure and the way generics are implemented in Java.


