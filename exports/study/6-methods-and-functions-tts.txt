Methods

Overloading

Method overloading, also known as compile-time polymorphism, allows you to define multiple methods with the same name but different parameter lists. This is called compile-time polymorphism because the method signatures and their behaviors are determined when the code is compiled.

The overloaded methods must share the same name, but they can differ in the type or number of arguments. The return type can be the same, but it is not required to be. The main idea is that, at runtime, the compiler selects the correct implementation of the overloaded method based on the arguments provided.

For example, consider a class called OverloadDemo. In this class, there are several methods named test. One version takes no parameters, another takes a single integer, a third takes two integers, and a fourth takes a double and returns a double. Each method prints out which version was called and the values of its arguments.

When you create an instance of OverloadDemo and call the test method with different arguments, the correct version is chosen automatically. For instance, calling test with no arguments invokes the no-parameter version. Calling it with one integer invokes the single-integer version, and so on.

However, there are some caveats. If you try to call test with two double values, and there is no method that matches that signature, you will get a compile-time error. On the other hand, if you call test with a float, and there is a version that takes a double, Java will automatically promote the float to a double and call the double version.

Constructors can also be overloaded in the same way as methods. The rules are the same: the constructor name stays the same, and each version must have a unique combination of parameter types and numbers. Type promotion can also occur with overloaded constructors.

Invocation

In Java, all arguments are passed by value. This means that a copy of the argument is made and pushed onto the stack before the method is invoked. For primitive types like numbers, booleans, and characters, this is straightforward: the value is simply copied.

For objects, the situation is a bit more nuanced. When you pass an object to a method, the reference to the object is copied by value. However, both the original and the copied reference point to the same object in memory. So, while the reference itself is passed by value, changes to the object through the reference will affect the original object.

Returning

Returning values from methods in Java also happens by value. The returned value is copied back onto the call stack. For object references, the reference itself is copied, but both the caller and the callee will point to the same object on the heap.

You can also return new objects from methods. For example, you might have a method called createBox that returns a new Box object. If you assign the result to a variable, that variable will reference the new object, and the garbage collector will not remove it as long as at least one reference exists. If you call createBox and do not use the result, the object becomes eligible for garbage collection.

Arguments

A particularly useful feature in Java is the variable arguments list, or varargs. This allows a method to accept an unknown, possibly zero, number of arguments of the same type. You define a varargs parameter using three dots after the type, such as int dot dot dot v.

When you call a method with varargs, you can pass any number of arguments, including none. Internally, the compiler treats the varargs parameter as an array, so inside the method, you can iterate over the arguments and use properties like length.

A method can have both normal parameters and a variable-length parameter, but the varargs parameter must be the last one declared. You cannot declare more than one varargs parameter in a single method.

Varargs methods can also be overloaded. For example, you can have one version that takes a string and a variable number of integers, and another that takes a string and a variable number of booleans. The compiler uses both the number and types of arguments to determine which version to call.

It is important to note that varargs are essentially syntactic sugar for an array of a given type. This means you can call a varargs method by explicitly passing an array, although this is rarely necessary.

However, you cannot overload a method by having one version that takes an array and another that takes varargs of the same type, because the compiler treats them as the same signature. This will result in a compile-time error.

There can also be ambiguity when overloading varargs methods. For example, if you have two methods, one that takes a variable number of integers and another that takes a variable number of booleans, calling the method with no arguments will cause a compile-time error because both versions are equally valid. Similarly, if you have one method that takes a variable number of integers and another that takes one integer followed by a variable number of integers, calling the method with a single integer will also result in a compile-time error due to ambiguity.


