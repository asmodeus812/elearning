Streams

Possibly the most important addition to the Java library in the Java 8 release is the stream API. The stream API is part of the java dot util dot stream package.

Optional

The Optional class type was introduced to allow users of the language to express a value that might be empty, or in the case of Java, null. The Optional class provides certain methods to validate that the value it holds is not null before it can be used. It also offers a convenient interface to avoid the dreaded “if not null, do this, else do that” blocks, which can often make code less readable. Instead, the Optional interface often provides ways to express these checks in a single line of code, chaining certain operations.

You can think of the Optional class or interface as a stream with only one element, since some of its methods match those in the Stream interface. Optional values can be extracted, mapped, and filtered.

To create an Optional object, there are several options provided by the language:

First, you can create an empty Optional using Optional dot empty. This is usually required when, for example, a method that returns an optional value does not find any value to return. Instead of returning plain null, the empty Optional is preferred.

Second, you can create an Optional from a concrete value using Optional dot of, passing in the value. Note that this method performs a null check. If the variable is null, calling this method will throw an exception.

Third, you can create an Optional from a nullable value using Optional dot ofNullable. This allows you to create both an empty and a non-empty Optional with a single statement. If the value is null, the Optional that will be created is an empty one, and no exception will be thrown.

The Optional class type, similarly to streams, also has primitive versions: OptionalDouble, OptionalLong, and OptionalInt. The interface of these optional types is pretty much the same as the regular Optional type, with some very slight differences. They do not inherit from the Optional type, just as the primitive streams do not inherit from Stream, but only from BaseStream.

In the example provided, a DoubleStream is created with several temperature values. The max method is called to find the maximum value, which returns an OptionalDouble. If a value is present, it is printed to the console.

The primitive versions of the streams use the primitive versions of the Optional types. This should be obvious and expected, since primitive streams do not interact with the base Optional non-primitive type. The base Optional is only a wrapper around object or class types and cannot be used on primitive types.

Of course, there is a way to convert between the primitive version of the Optional and the object type by using the auto-boxed numeric types, which are classes.

Operations

There are certain important operations exposed by the stream API that allow you to search, filter, and convert data in the stream. These are used to build up the stream transformation pipeline.

Searching

Methods ending with the word “Match” and methods starting with the word “find” in the Stream interface are useful for searching data from the stream. These methods return a boolean value.

For searching operations, findFirst and findAny may not find matching elements in the stream, so they return an Optional of type T.

The anyMatch method returns true if there are any elements in the stream that match the given predicate. It returns false if the stream is empty or if there are no matching elements.

The allMatch method returns true only if all elements in the stream match the given predicate. It returns true if the stream is empty, without evaluating the predicate.

The noneMatch method returns true only if none of the elements in the stream match the given predicate. It also returns true if the stream is empty, without evaluating the predicate.

The findFirst method returns the first element from the stream. If there is no element present in the stream, it returns an empty Optional object.

The findAny method returns one of the elements from the stream. If there is no element present, it returns an empty Optional object.

Unlike the anyMatch method, which returns false when the stream is empty, the allMatch and noneMatch methods return true if the stream is empty. This should be rather obvious, since no elements in the stream will always imply that allMatch or noneMatch return true for any condition for those methods.

In the example provided, an IntStream is created with several negative temperature values. The anyMatch method checks if any temperature is greater than zero. The allMatch method checks if all temperatures are greater than zero. The noneMatch method checks if none of the temperatures are greater than zero. The results are printed to the console.

This example demonstrates a simple usage of the matching functions. These are useful to avoid filtering first and then checking the size or count of the final collection. Instead, this operation is condensed into a single searching operation.

The companion functions to the boolean any, all, and none match methods are the findFirst and findAny methods. In the next example, all methods in the Stream API or interface that end with “Match” are filtered, sorted, and then the first one is extracted. In this case, the sorting is in ascending order, so “allMatch” comes before “anyMatch” and “noneMatch.” The result is printed to the console.

The reason there are two find methods in the API is that the method called findAny is tailored for use cases involving parallel streams. For any streams, findFirst is always defined to return the first element in the stream. However, the behavior of findAny is not defined for normal and parallel streams. It may return any element in the stream, especially in parallel streams.

It is important to note that the match and find operations are short-circuiting in nature. This means that the moment they find a matching element, they will terminate, and the iteration over the rest of the entries in the stream is not done.

Calculation

There are certain calculation methods on the Stream and primitive streams API. Methods like min, max, and average are available. These operations are also called implicit reducers, since internally they are implemented using the reduce method of the stream. The reduce method is made to accumulate a result of some computation and then return that result. The reduce method is, however, much more general and has applications outside the simple operations such as the ones listed above.

In the example provided, a string is split into words, and the minimum word is found using the min method with a comparator. The result is printed to the console.

The min and max methods in the Stream version, which is the non-primitive one, require a comparator to be passed in for the calculation to be performed. Otherwise, there is no way to truly find a meaningful result for the min or max expression. For the primitive versions of the streams, that is not necessary, since the integral types have well-defined comparison rules.


Stream and Primitive Stream Methods

Let’s begin by reviewing the main methods available in both the general Stream interface and the specialized primitive stream interfaces in Java.

The count method returns the number of elements in the stream. If the stream is empty, it returns zero.

The min method, which takes a comparator, returns the minimum value in the stream. If the stream is empty, it returns an empty Optional value.

Similarly, the max method, also using a comparator, returns the maximum value in the stream, or an empty Optional if the stream is empty.

For primitive streams, there are additional methods. The sum method returns the sum of all elements in the stream, or zero if the stream is empty.

The min and max methods for primitive streams return the minimum and maximum integer values, respectively, or an empty Optional of the primitive type if the stream is empty.

The average method returns the average value of the elements in the stream, or an empty OptionalDouble if the stream is empty.

The summaryStatistics method is particularly interesting. It returns a statistics object that contains the sum, count, average, minimum, and maximum values of the stream. This is useful because, after calling a terminal operation like sum or count, the stream is closed and cannot be used for further operations. The summaryStatistics method collates all these statistics in one go, making it efficient and convenient.

Here’s an example that demonstrates the use of summaryStatistics. In this example, a limerick is split into words, and the length of each word is analyzed. The summaryStatistics method is used to gather the number of words, the sum of their lengths, the minimum and maximum word sizes, and the average word size. The results are then printed out.

Sorting

Sorting is another powerful capability of the stream API. It allows you to order the items in a stream based on a specific criterion. The sorted method, which takes a comparator, is used for this purpose.

For example, consider a list of words. You can sort these words by their length in ascending order by providing a comparator that compares the lengths of two strings. The stream is first made distinct to remove duplicates, then sorted using the comparator, and finally printed out.

If you want to sort the words first by length and then alphabetically, you can chain comparators using the thenComparing method. This means that if two words have the same length, the second comparator, in this case the natural alphabetical order, is used to break the tie. You can chain as many comparators as needed, since thenComparing returns a comparator instance.

To reverse the order of sorting, you have two options. You can modify the comparator to compare the second argument to the first, but this is not always possible, especially if you are reusing existing comparison methods like String’s compareTo. Alternatively, you can use the reversed method, which wraps the previous comparator and inverts the order of comparison. This is done internally by swapping the arguments passed to the comparator.

The term “natural order” is often used in the Comparable and Comparator interfaces. It refers to the default order implied when comparing elements, which is typically ascending order. This convention ensures consistency across the API.

Collecting

The stream API provides several methods to collect the results of a transformation pipeline into reusable data structures. The most generic method is collect, which takes a Collector interface as input. This allows the elements of the stream to be collected in any way you choose.

There are also helper functions that provide predefined collectors for common data structures like lists, sets, and maps.

For example, you can split a string into words and collect them into a list using the toList method from the Collectors interface. This provides a quick way to gather the stream’s entries into an ArrayList by default.

Similarly, you can collect elements into a set using the toSet method. By default, this creates a HashSet, which does not allow duplicate values.

For more complex mappings, the toMap method is available. This method requires at least two arguments: one for mapping the key and one for mapping the value. For instance, you can create a map where the key is the entry itself and the value is the length of the string. The result is a map from names to their lengths, which can then be printed out.

In summary, the stream API in Java provides a rich set of methods for processing, sorting, and collecting data in a functional style. The ability to chain operations and collect results into various data structures makes it a powerful tool for developers.


This example shows how to provide a custom lambda reference for creating a collection. Since all collections have a way to add elements, in the simplest case, you only need to provide a way to create the desired collection. The rest is handled internally, adding the elements of the stream to that collection instance.

In the code, a string containing the phrase “a rose is a rose is a rose” is split into words. These words are then streamed and collected into a TreeSet, which automatically sorts and removes duplicates. Finally, each word in the set is printed out.

Grouping

There is another subset of collection operations called grouping. The grouping operation provides a way to create a map of entries based on some criteria. In other words, it groups them according to a certain rule. The result is always a map, where the key represents the unique criteria, and the value is a list of all the values that match that criteria.

For example, consider a string: “you never know what you have until you clean your room.” This string is split into words, and the distinct words are grouped by their length. The final map will have keys representing the word lengths, and each value will be a list of words with that length.

There is also a special case of grouping called partitioning. Partitioning is similar to grouping, but instead of grouping by a specific value, it splits the entries into two groups based on a predicate. In the example, all words with a length less than four are grouped under the map key false, and all words with a length greater than four are grouped under the map key true. Note that the map is keyed on a boolean value, not an integer.

The groupingBy method always accepts at least one argument, which is a function from the functional interface. In contrast, the partitioningBy method always accepts a predicate, also from the functional interface package java.util.function. This difference is due to the nature of both methods: groupingBy organizes entries into buckets based on a function, while partitioningBy splits them into at most two groups—those that match the predicate and those that do not.

Mapping

Mapping is the process of converting the starting type of the stream entry to another type. These operations can be chained, meaning you can make unlimited calls to map, transforming each preceding type into a new one. Mapping is very handy when the starting type of the stream entries is not suitable for certain operations, and you want to refine the type so calculations can be performed more efficiently or at all.

For example, a list of integers is streamed, and each integer is mapped to its square. The mapped type remains an integer, but the value changes. This is the simplest demonstration of mapping: it allows you to mutate each entry of the stream, changing the value and even its type. However, each map must return the same type for all entries. It is not possible to return heterogeneous types unless they are all children of the same supertype.

There are several mapping methods available. For example, mapToDouble converts the current stream into a primitive double stream. Similarly, mapToLong and mapToInt convert the stream into primitive long and integer streams, respectively. The map method itself can convert the stream into one containing elements of a different type.

Flat mapping is a special case of regular mapping. It is usually used when the source collection is a nested, two- or multi-dimensional one. For example, with a two-dimensional array, flat mapping reduces this structure into a single dimension after the mapping. FlatMap always accepts a function that takes the current type of entry in the stream and returns a stream, or one of the primitive versions of streams.

For instance, suppose you have a stream of words and you want to find the unique characters in the sentence. Each word must be split into characters, and then only the unique ones extracted. However, if you use map, each word is mapped to an array of strings, which does not flatten the structure. Using flatMap, on the other hand, ensures that the nested streams are flattened into their composite elements, allowing you to extract unique characters from the entire sentence.

Summary

Optional

When there are no entries in a stream and operations such as max are called, instead of returning null or throwing an exception, Java 8 returns Optional values. For primitive types, there are versions such as OptionalInt, OptionalLong, and OptionalDouble.

Streams

The Stream interface provides data and calculation methods such as count, min, and max. When invoking min or max, you need to pass a comparator object as a parameter. The primitive type versions of the Stream interface provide methods like count, sum, average, min, and max. The summaryStatistics method in IntStream, LongStream, and DoubleStream calculates count, sum, average, minimum, and maximum values of elements in the stream.

The peek method is useful for debugging, as it helps you understand how elements are transformed in the pipeline. You can transform or extract elements in a stream using the map method.

To search for data, use the search methods of the Stream classes, including findFirst, findAny, anyMatch, allMatch, and noneMatch. You can match a given predicate in a stream using allMatch, noneMatch, and anyMatch. Unlike anyMatch, which returns false when the stream is empty, allMatch and noneMatch return true if the stream is empty.

To look for elements in a stream, use findFirst and findAny. The findAny method is faster than findFirst when using parallel streams. Both the match and find methods are short-circuiting, meaning the evaluation stops once the result is found and the rest of the stream is not evaluated.

Comparator and Comparable

One way to sort a collection is to get a stream from the collection and call the sorted method on that stream. The sorted method sorts the elements in their natural order, which requires that the stream elements implement the Comparable interface.


Sorting with a Comparator

When you want to sort elements in a stream using an order other than their natural order, you can provide a Comparator object to the sorted method. The Comparator interface in Java 8 has been enhanced with several useful static and default methods, such as thenComparing and reversed. These methods allow you to build complex sorting logic by chaining comparators or reversing their order.

Collectors and Collections

The collect method, found in the Collectors class, supports gathering elements from a stream into a collection. The Collectors class offers methods like toList, toSet, toMap, and toCollection. These methods help you create various types of collections from a stream’s elements.

You can also group elements in a stream by using the groupingBy method from the Collectors class. This method takes a function as an argument, which defines the criteria for grouping the elements.

If you need to separate elements in a stream based on a condition, you can use the partition method in the Collectors class. This method takes a predicate and splits the stream into two groups: those that match the condition and those that do not.

Using the flatMap Method of the Stream API

The flatMap method in the Stream API is used to flatten streams. When you map each element to a stream, flatMap combines all resulting streams into one continuous, flat stream. This is especially useful when working with nested collections or when you want to process all elements at the same level.


