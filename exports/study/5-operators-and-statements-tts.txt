Operators

Let’s start with operators in Java.

Arithmetic operators include addition, subtraction, multiplication, division, modulus, increment, and decrement. You’ll also find assignment versions of these, such as addition assignment, subtraction assignment, multiplication assignment, division assignment, and modulus assignment. These operators work much as you’d expect if you’ve used other programming languages.

Next, there are bitwise operators. These include bitwise NOT, AND, OR, exclusive OR, as well as shift operators for shifting bits left or right. There are also assignment versions of these bitwise operators, such as bitwise AND assignment, OR assignment, exclusive OR assignment, and shift assignments.

Caveats

Besides the standard arithmetic and bitwise operators, Java exposes two special shift operators: the triple right shift and the triple left shift. In Java, the regular shift operators—shift right and shift left—behave a bit differently than you might expect, because Java does not have unsigned integer types. When you use the standard shift operators, the sign bit of the number is preserved. This means that shifting right or left by one bit effectively divides or multiplies the number by two, but the sign is maintained.

For example, if you shift the binary representation of thirty-five right by two, you lose the two least significant bits, and the result is eight. Similarly, shifting negative eight right by one divides it perfectly by two, resulting in negative four. However, the top bits are filled with the sign bit—one for negative numbers, zero for positive numbers. This preserves the two’s complement representation.

To avoid this sign extension, Java introduced the triple right shift and triple left shift operators. These perform shifts on signed numbers without filling or touching the higher order bits. In most other languages, this kind of shift is the default behavior.

Representation

All of Java’s integer types, except for char, are signed integers. This means they can represent both negative and positive values. Java uses an encoding called two’s complement to represent negative numbers. In two’s complement, you represent a negative number by inverting all the bits of its positive counterpart and then adding one.

For example, to represent negative forty-two, you start with the binary for forty-two, which is zero zero one zero one zero one zero. Invert all the bits to get one one zero one zero one zero one, then add one, resulting in one one zero one zero one one zero. This is the two’s complement representation of negative forty-two.

To decode a negative number, you invert all the bits and add one. For instance, negative forty-two in binary, when inverted, gives you forty-one, and adding one brings you back to forty-two.

The reason Java and most other languages use two’s complement is to handle zero crossing correctly. In one’s complement, inverting all the bits of zero gives you negative zero, which is invalid in integer math. Two’s complement solves this by adding one to the complement, which causes any extra bit to overflow, ensuring that negative zero is treated the same as zero, and that the encoding for negative one is all ones.

Although this example uses a byte, the same principle applies to all of Java’s integer types.

Statements

If

The if statement in Java is used to route program execution through two different paths. There’s nothing unusual about it compared to other languages.

While

Similarly, the while and do-while statements in Java behave just as they do in most other languages.

Switch

The switch statement is Java’s multi-way branch statement. It provides a convenient way to dispatch execution to different parts of your code based on the value of an expression. Traditionally, the switch statement only accepted constant or literal values to switch on, unlike if statements. However, in recent versions of Java, the switch statement has been improved and is now more flexible.

A typical switch statement in Java evaluates an expression and, depending on its value, executes the corresponding case block. If no case matches, the default block is executed. The break statement is used to exit the switch after a case is executed. If you omit the break, execution will continue into the next case, including the default block. This is a common mistake and is rarely intentional.

Switch statements are usually more efficient than a set of nested if statements. This is because the Java compiler creates a jump table for the case constants, allowing for faster selection of the execution path.

Jumps

Break

In Java, the break statement has three main uses. First, it terminates a statement sequence in a switch statement. Second, it can be used to exit a loop. Third, it can be used as a controlled form of goto.

For example, you can label blocks of code and use break with a label to exit out of nested blocks. In the provided example, a labeled break is used to exit the second block when a condition is met, skipping the rest of the inner and middle blocks and continuing after the labeled block.

The key feature here is that break can use labels, similar to how labels work in languages like C or assembly. You can mark a block of code with a label, and then use break with that label to exit out of nested loops or blocks.

Continue

The continue statement is similar to a goto that jumps just past the body of a loop, to the loop’s end. In while and do-while loops, a continue statement causes control to be transferred directly to the conditional expression that controls the loop.

For example, you can use labeled continue statements to control flow in nested loops. In the provided example, when a certain condition is met, control is returned to the outer loop, continuing the increment of the outer variable. This results in a step-like output structure.

Just like break, continue can also use labels. However, instead of exiting early, it returns control to an earlier statement, typically the start of a loop.

Return

The return statement is used to explicitly return from a method. It causes program control to transfer back to the caller of the method. The behavior of return in Java is straightforward and similar to other languages. You can return without a value for void methods, or return a specific value from the method’s control block. There are no hidden special cases.


