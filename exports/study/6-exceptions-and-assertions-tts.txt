Throwable

Throwable is the top-level class used in nearly all exception and error handling in the Java language. It is fundamental to how the Java Virtual Machine, or JVM, manages errors. All exceptions—both checked and unchecked—are subclasses of Throwable. Additionally, the special type called Error, which is mostly used internally by the JVM, also extends from Throwable.

Every object that is thrown in Java code must be a subclass of Throwable or one of its descendants. The language constructs for exception handling, such as throw statements, the throws clause, and the catch clause, all work exclusively with Throwable and its subclasses.

There are three important subclasses of Throwable: Error, Exception, and RuntimeException.

The general hierarchy of the Java exception model is as follows. At the top is Object, followed by Throwable, then Exception, and finally RuntimeException.

Exceptions of type Exception in Java are known as checked exceptions. If your code can throw an Exception, you must either handle it using a catch block or declare that the method throws that exception. This forces the caller of the method to handle the exception as well.

RuntimeException is a subclass of Exception. Exceptions that derive from RuntimeException are known as unchecked exceptions. Handling unchecked exceptions is optional. If a method can throw an unchecked exception, it is not mandatory to catch it or declare it in the throws clause.

Error is another subclass of Throwable. When the JVM detects a serious abnormal condition in the program, it raises an exception of type Error. Errors indicate an abnormal, often irrecoverable, state in the program. It is generally considered bad practice to catch these exceptions and pretend nothing has happened. If an Error occurs, it signals that the program has reached a state from which it cannot recover.

Throwing

Let’s look at how exceptions are thrown in Java.

The first example defines a main method that checks if any command-line arguments are provided. If none are present, it throws an IllegalArgumentException, which is a type of RuntimeException. Since RuntimeExceptions are unchecked, it is not mandatory to handle them. If this exception is thrown, the program will exit, and the call stack will unwind accordingly. If arguments are present, the program prints them out, separated by spaces.

Since there is no explicit user-defined handler for the exception thrown in this example, the JVM itself will catch the exception when the program terminates. The JVM does this to at least log the error, so the user can get some information about what went wrong.

In another example, the main method prompts the user to type an integer in the console. It uses a Scanner to read the next integer from standard input. If the input is not a valid integer, the nextInt method can throw an unchecked exception. This possibility is documented in the method’s documentation. Therefore, user code can choose to catch and handle the exception gracefully, even though it is unchecked, instead of letting the program crash.

A useful feature of try-catch blocks is that you can wrap an exception in another one and re-throw it, instead of handling it immediately. This is often useful in practice, because simply swallowing an exception—by leaving the catch block empty or printing a generic message—can lose important information about the cause of the error. Wrapping an exception preserves the original cause, which can be helpful if it cannot be handled at the current level. This technique is often used for exception translation, where internal system exceptions are wrapped in more generic business-level exceptions that are easier to handle at higher layers of the program.

Catching

Besides creating exceptions, user code can also catch them. This is the companion action to throwing exceptions.

The next example extends the previous one. It reads an integer from standard input and tries to handle the case where the input is not a valid integer. If the input cannot be parsed as an integer, the program prints an error message. In a more robust solution, you might use a loop to keep prompting the user until a valid integer is entered.

In this example, the try block contains the code that might throw an exception. If an exception occurs, the catch block is triggered. If the exception matches the type specified in the catch block, that block is executed. Multiple catch statements are allowed, and it is possible that no catch block matches, in which case the JVM handles the exception.

If, in the example above, an exception other than InputMismatchException is thrown, the catch block will not be triggered, and the JVM will handle the exception.

Multi-catch catching

Now, let’s look at an example with multiple catch blocks.

In this example, a string that does not represent an integer is used to initialize a Scanner. The program tries to read an integer from this string using nextInt. Several catch blocks are provided to handle different exceptions: InputMismatchException, NoSuchElementException, and IllegalStateException.

In this case, calling nextInt will fail with a NoSuchElementException. This happens because the scanner is initialized with a string that cannot be parsed as an integer. The order in which exceptions are caught matters, especially when exceptions have a common hierarchy. For example, InputMismatchException extends from NoSuchElementException. Therefore, you cannot catch NoSuchElementException before InputMismatchException, because the more general catch block would prevent the more specific one from ever being reached.

To summarize, the order of catch statements is important when exceptions have an inheritance relationship. Catching a parent exception before a child exception will make the child’s catch block unreachable. This is a common source of errors in exception handling code.


Let’s start by discussing exception handling order in Java.

When you write multiple catch blocks, the order matters. If you try to catch a parent exception type, like NoSuchElementException, before a child type, such as InputMismatchException, the compiler will give you an error. This is because InputMismatchException is a subclass of NoSuchElementException. If the parent is caught first, the child’s catch block will never be reached. The compiler enforces this rule to help you avoid logical mistakes that would be hard to detect at runtime. If this were allowed, any InputMismatchException would always be caught by the NoSuchElementException block, making the more specific handler useless.

So, when you provide multiple catch handlers, always handle the more specific exceptions before the general ones. If you put a derived class exception after a base class exception, the compiler will stop you with an error. This is a logical safeguard, not just a syntactic one.

Now, let’s talk about multi-catch blocks.

Java allows you to catch multiple unrelated exceptions in a single catch block using the pipe symbol. For example, you might want to handle both NoSuchElementException and IllegalStateException in the same way. However, you cannot use multi-catch for exceptions that have a parent-child relationship. If you try to combine related exceptions, like NoSuchElementException and InputMismatchException, the compiler will reject it. This is because the more general exception would always catch the more specific one, making the code ambiguous.

In summary, in a multi-catch block, you can only combine exceptions that do not share a base or derived class relationship. Only unrelated exceptions can be listed together.

You might wonder when to use multiple catch statements versus a multi-catch block. If the exceptions are thrown for the same or similar reasons, a multi-catch block makes your code more readable and maintainable. But if you need to handle each exception differently, use separate catch blocks.

Let’s move on to general exception catching.

All exceptions in Java extend from the Throwable class, and more specifically from the Exception class. This means you can catch a higher-level exception type, like Exception or even Throwable, to handle any exception that might be thrown in a try block. While this is not always the best idea, it can be useful in situations where many different exceptions might occur, such as when working with input and output operations. If you try to handle every possible exception individually, your code can become unreadable and hard to maintain. In these cases, it’s often better to catch Exception for less important cases and report a general error.

For example, you might have a try block that reads an integer from the console. You can catch InputMismatchException specifically, which occurs if the input is not an integer. For all other exceptions, you can use a general catch block for Exception. This way, the most important exception is handled directly, and everything else is caught by the general handler.

Now, let’s talk about finalizing resources.

In all the examples so far, there’s a common issue: the Scanner object is not closed. You can fix this by calling the close method on the Scanner. Java provides two main ways to ensure resources are closed: the finally block and try-with-resources.

First, let’s discuss the finally block.

The finally block is always executed after the try and catch blocks, regardless of whether an exception was thrown or caught. This makes it a safe place to clean up resources, like closing a Scanner or a file stream. However, if the close method itself throws an exception, any code after it in the finally block will not be executed. This is one reason why using finally to close resources is not always recommended, as it can still lead to resource leaks in some cases.

It’s also possible to have a try-catch inside a finally block. This was the traditional way to close file streams, since their close method can throw a checked exception that must be handled.

One important caveat: if you call System.exit inside a method, the program will terminate immediately. Any finally blocks will not be executed, and resources may leak. For this reason, it’s considered bad practice to use System.exit to terminate a program.

There are also some odd behaviors with finally blocks. For example, if you return a value from both the try and finally blocks, the value from the finally block will override the one from the try block. This can lead to confusing and unintended results, so it’s best not to return values from finally blocks.

Now, let’s look at try-with-resources.

Introduced in Java 8, try-with-resources is designed to simplify resource management and avoid the pitfalls of the finally block. Any resource that implements the AutoCloseable interface can be declared in the try-with-resources statement. When the try block finishes, the resource’s close method is called automatically, even if an exception occurs. This ensures that resources are always closed properly.

The syntax is straightforward. You declare and initialize the resource inside the parentheses of the try statement. You can declare multiple resources by separating them with a semicolon. All resources declared this way are effectively final.

Internally, the compiler translates try-with-resources into a try-catch-finally block during code generation. This means you get the benefits of proper resource management without the boilerplate code and potential logical errors of manual finally blocks.

To declare more than one resource in a try-with-resources statement, simply separate them with a semicolon. All resources must be explicitly defined as effectively final.

In summary, always catch specific exceptions before general ones, use multi-catch blocks for unrelated exceptions, and prefer try-with-resources for managing resources that need to be closed. This will make your code safer, more readable, and easier to maintain.


Let’s begin by discussing the try-with-resources statement in Java.

The try-with-resources statement

In Java, the try-with-resources statement allows you to declare and use resources—such as streams—within a try block. These resources are automatically closed at the end of the block, even if an exception occurs. For example, you might see a try-with-resources statement that opens a ZipOutputStream to write to a zip file, and a FileInputStream to read from an input file. Inside the block, the code puts a new entry into the zip file, then reads bytes from the input file and writes them into the zip file. The key point is that both streams are closed automatically when the block finishes, so you don’t need to write explicit finally blocks to close them.

All resources declared within the try-with-resources block are effectively final. This means you cannot reassign them inside the block. If you did, the original reference would be lost, and the resource might not be closed properly, leading to a resource leak.

However, it is possible to declare and initialize a resource outside the try-with-resources block, and then capture the reference inside the block. For example, you might create a Scanner for the console input outside the try block, and then use it inside the try-with-resources statement. This is allowed, and the resource will still be closed automatically.

The main benefit of try-with-resources is that it simplifies your code and makes it less verbose. It also ensures correctness, since you don’t have to remember to write finally blocks to close resources. These finally blocks can be forgotten, or written incorrectly, leading to bugs.

It is also possible to use a try-with-resources block without a catch statement. While this is allowed by the language, it is generally not recommended. For example, you might open a Scanner for console input inside a try-with-resources block, read an integer, and not provide a catch block. The resource will still be closed automatically.

If you use a finally block together with try-with-resources, the resources inside the try-with-resources statement will be closed before the finally block is executed. This means you should not try to close them again in the finally block. Doing so is incorrect and can lead to undefined behavior, such as exceptions being thrown because the resource is already closed. Instead, you can use the finally block to log or notify that all resources have been cleaned up.

Throws

Now, let’s talk about the throws clause in Java.

The throws clause is another important part of Java’s exception framework. This clause is used in method declarations to indicate that a method might throw certain exceptions. If a method throws an unchecked exception, using the throws clause is optional. However, if a method throws a checked exception, the throws clause is required. You must declare all checked exceptions that the method might throw.

It is good practice to document which exceptions a method can throw, and under what conditions. For example, you might have a main method that reads an integer from a file. If the file does not exist, a FileNotFoundException is thrown. In this case, the main method must declare that it throws FileNotFoundException, otherwise the code will not compile.

When a method declares that it throws a checked exception, any method that calls it must either handle the exception with a try-catch block, or declare that it also throws the exception. This rule ensures that checked exceptions are either handled or explicitly acknowledged.

There are some additional rules regarding the throws clause and method overriding. If a base method declares a throws clause, a subclass that overrides the method must adhere to the contract. The overriding method cannot throw more general checked exceptions, nor can it add new checked exceptions that are not part of the original method’s throws clause. However, the overriding method can declare a more specific checked exception, as long as it is a subtype of the exception declared in the base method.

For example, suppose you have an interface with a method that throws IOException. If a class implements this interface, it can override the method and declare that it throws FileNotFoundException, which is a subtype of IOException. This is allowed.

The throws declaration in an overridden method can only be changed to add unchecked exceptions, or to specify a more specific checked exception. Any other modification to the list of checked exceptions will result in a compiler error.

Documentation

It is good practice to use the at-throws JavaDoc tag to document the specific situations in which an exception might be thrown from a method. For example, the nextInt method from the Scanner class documents that it can throw InputMismatchException if the next token does not match the integer regular expression or is out of range, NoSuchElementException if the input is exhausted, and IllegalStateException if the scanner is closed. These exceptions are listed in alphabetical order, not by severity or class hierarchy.

Miscellaneous

Here are some additional points to keep in mind.

If a method does not have a throws clause, it does not mean it cannot throw any exceptions. It just means it cannot throw any checked exceptions.

Static block initializers cannot throw checked exceptions. This is because static initialization blocks are invoked when the class is loaded, and there is no way to handle the thrown exceptions in the caller. There is also no way to declare checked exceptions in a throws clause for static initializers.

Non-static initializer blocks can throw checked exceptions, but all constructors must declare those exceptions in their throws clause. This is because the compiler merges the code in the non-static initializer block and the constructors during code generation, so the throws clause of the constructor can be used to declare checked exceptions that a non-static initializer block might throw.

An overriding method cannot declare more checked exceptions in its throws clause than the base method. However, it can declare more specific exceptions, meaning it can declare derived exceptions in the throws clause.

If a method is declared in two or more interfaces, and each interface declares different exceptions in the throws clause, the implementing method must declare all of these exceptions in its throws clause. In other words, the throws clauses are merged together.

User-defined exceptions

Finally, let’s discuss custom exceptions.

You can declare your own exceptions by extending either the Exception class or the RuntimeException class. It is considered bad practice to extend from the Throwable or Error classes. As mentioned earlier, if you want to create a checked exception, you should extend from Exception. If you want to create an unchecked exception, you should extend from RuntimeException.


The Exception class, and by extension the RuntimeException class, provide several constructors for creating exception objects in Java.

First, there is the default constructor, which creates an Exception object without any additional or detailed information.

Next, you can use a constructor that takes a string argument. This allows you to provide a detailed message describing the exception.

There is also a constructor that accepts both a string message and another exception as the cause. This is useful for chaining exceptions, so you can indicate not only what went wrong, but also what caused it.

Finally, there is a constructor that takes only a Throwable cause as an argument, allowing you to wrap another exception without providing a custom message.

In addition to these constructors, the Exception class provides several important methods.

The getMessage method returns the detailed message that was passed when the exception was created.

The getCause method returns the cause of the exception, if one was provided. If not, it returns null.

The getSuppressed method returns an array of suppressed exceptions. These are typically exceptions that were thrown when using a try-with-resources statement.

The printStackTrace method prints the stack trace to the console, showing the list of method calls and relevant line numbers that led to the exception. If the exception has a cause or any suppressed exceptions, those are printed as well.

Now, let's look at an example of a custom user exception.

This example defines a class called InvalidInputException, which extends RuntimeException. Because it extends RuntimeException, it is an unchecked exception. The class provides three constructors: a default constructor, one that takes a message, and one that takes both a message and a cause. This allows you to create custom exceptions with as much detail as you need, while relying on the default behavior provided by the parent classes.

Assertions

The assert statement in Java is used to check or test your assumptions about the program. The assert keyword provides support for assertions. Each assertion statement contains a Boolean expression. If the expression evaluates to true, nothing happens. However, if it evaluates to false, an AssertionError is thrown.

It is important to remember that the Error class and its derived classes, such as AssertionError, indicate serious runtime errors and are not meant to be handled. If an AssertionError is thrown, the best course of action is to let the program terminate and then examine the assertion to understand why it failed.

Assertions are a useful tool for making assumptions explicit in your code. They help you discover when those assumptions are violated.

A very important detail is that assertions are disabled by default at runtime. To enable them, you use the dash e a switch, or its longer form, dash enable asserts. To disable assertions at runtime, use the dash d a switch.

You might wonder, if assertions are disabled by default, what is the use of the dash d a switch? There are several scenarios. For example, you might want to enable assertions for all classes within a given package, but disable them in a specific class within that package. In such cases, the dash d a switch is useful.

Here are some common command-line arguments for controlling assertions:

The dash e a option enables assertions by default, except for system classes.

The dash e a followed by a class name enables assertions for that specific class.

The dash e a followed by a package name and three dots enables assertions for all members of the given package.

The dash e a followed by three dots enables assertions in the unnamed package.

The dash e s a option, which stands for enable system assertions, enables assertions in system classes. This option is rarely used.

The dash d a option disables assertions by default, except for system classes.

The dash d a followed by a class name disables assertions for that specific class.

The dash d a followed by a package name and three dots disables assertions for all members of the given package.

The dash d a followed by three dots disables assertions in the unnamed package.

The dash d s a option, which stands for disable system assertions, disables assertions in system classes. This option is also rarely used.

Summary

When an exception is thrown from a try block, the Java Virtual Machine looks for a matching catch handler in the method call chain. If no matching handler is found, the unhandled exception will cause the application to crash.

When providing multiple exception handlers, you should list specific exception handlers before general ones.

You can programmatically access the stack trace using methods such as printStackTrace and getStackTrace, which can be called on any exception object.

A try block can have multiple catch handlers. If two or more exceptions have similar causes and handling code, you can combine them into a multi-catch block.

A catch block should either handle the exception or rethrow it. Catching an exception and doing nothing is considered bad practice.

You can wrap one exception and throw it as another, creating chained exceptions. From the thrown exception, you can retrieve the cause.

The code inside a finally block will always execute, regardless of whether the try block completed successfully or threw an exception.

Forgetting to release resources by explicitly calling the close method is a common mistake. You can use a try-with-resources statement to simplify your code and automatically close resources.

You can also auto-close multiple resources within a try-with-resources statement. These resources should be separated by semicolons in the statement header.


Exception Handling and Suppressed Exceptions

If a try block throws an exception, and the finally block also throws one or more exceptions, the exceptions from the finally block will be added as suppressed exceptions to the original exception from the try block. This means that the exception from the try block is the main one that gets thrown to the caller, while the exceptions from the finally block are attached to it as additional context.

Custom Exceptions

When creating your own exceptions, it is recommended to derive them from either the Exception class or the RuntimeException class. This ensures that your custom exceptions integrate properly with Java’s exception handling system.

Throws Clause in Methods

A method’s throws clause is part of its contract. Any overriding methods in derived classes must follow this contract. Specifically, an overriding method can declare the same throws clause as the base method, or it can declare a more specific throws clause. However, it cannot declare a more general throws clause or add new checked exceptions that were not present in the base method’s throws clause.

Try-with-Resources and AutoCloseable

For a resource to be used in a try-with-resources statement, its class must implement the java.lang.AutoCloseable interface and define the close method. This allows the resource to be automatically closed when the try block finishes, whether it completes normally or with an exception.

Assertions and Invariants

Assertions are used to explicitly check the assumptions you make while writing programs. They help you verify that certain conditions hold true during execution.

The assert statement comes in two forms. One form takes a Boolean argument, and the other takes a Boolean argument along with an additional string message. If the Boolean condition in the assert statement evaluates to false, the program will terminate by throwing an AssertionError. It is generally not advisable to catch and recover from an AssertionError, as it indicates a violation of a program assumption.

By default, assertions are disabled at runtime. You can enable assertions by using the dash e a command-line argument, or disable them with dash d a and their variants when you start the Java Virtual Machine.


