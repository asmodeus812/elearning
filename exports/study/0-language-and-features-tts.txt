Release

In this document, we will discuss the most recent Java releases. Java 19 was released on September fifteenth, twenty twenty-two. Java 20 followed on March twenty-first, twenty twenty-three. Java 21 arrived on September twelfth, twenty twenty-three. These dates reflect Oracle’s typical six-month release cadence for Java, with new feature releases coming out in March and September each year.

Language

Patterns

There have been several improvements to pattern matching in Java, especially with the instanceOf keyword and its use with records. Now, you can deconstruct and directly reference the fields of a record within a conditional block that uses instanceOf. This means you can access a record’s fields without first referencing the instance variable itself. However, if two records have the same field names, deconstruction will not work and will result in a compiler error.

For example, consider a record called Point with fields x and y. You can now check if an object is an instance of Point and, if so, access x and y directly within the conditional block. This makes code more concise and readable, but remember that field name collisions between different records are not allowed in this context.

Switch

The switch statement in Java has also been extended. It can now match based on type patterns and conditional expressions. This is not limited to record types, but it is particularly useful for them, as it avoids the need for multiple type checks.

For instance, you can write a function that takes an object called shape and uses a switch expression to match on its type. If the shape is a Circle, Rectangle, or Triangle, the switch will extract the relevant fields and return a formatted string describing the shape. If the type is unknown, it returns a default message.

The new switch syntax also allows you to match not just on the type, but on the value of a property. For example, you can match on a Circle with a positive radius and return a special message, while still handling other Circle cases separately. Switch expressions are still evaluated from top to bottom, so more specific cases must come before general ones.

This pattern matching can also be applied to regular class hierarchies, not just records. For example, you might have an abstract class called Shape, with subclasses Circle and Rectangle. You can use a switch expression to match on the type and properties of these subclasses, such as checking if a Rectangle is actually a square by comparing its length and width. The when keyword allows for even more refined checks within these patterns.

Traditionally, achieving this kind of logic would require nested switch statements or multiple if-else blocks. The new pattern matching for switch in Java flattens what would have been a multi-level structure into a single, more readable statement. This makes it much easier to write, read, and maintain branching logic that involves both type-checking and value-based conditions.

Templates

Templates are a preview feature in Java 21. This feature provides an alternative to the String.format method, supporting a more familiar template syntax such as dollar sign, open curly brace, variable, close curly brace. The goal is to avoid the usual string concatenation when embedding variables within a string.

For example, instead of writing a message by concatenating strings and variables, you can now use a string template. The new syntax allows you to write a string like, “Hello, dollar sign, open curly brace, name, close curly brace! You are dollar sign, open curly brace, age, close curly brace years old.” The variables name and age are automatically parsed and bound into the string template when it is evaluated.

Any variable, method, or field accessible in the scope of the string template at the time of definition can be used within the template. Importantly, any runtime value evaluated within the expression will be treated as a literal string, even if it contains template keywords or symbols. This prevents the misuse of templates by bad actors, as there is no way for external variables to inject dangerous templates into another template.

The new STR dot syntax allows the string to reference variables from the local context. In the example above, the string variables name and age are referenced within the template. This is essentially syntactic sugar, which gets compiled to a String.format type of expression, but it provides an easy and safe way to construct strings with embedded variables.

Platform

There are several small improvements at the platform level, but the most significant is the introduction of lightweight platform thread alternatives, known as virtual threads. Virtual threads provide seamless integration with existing code, requiring only minor adjustments. Most of these adjustments involve using different implementations of the ExecutorService, which can now spawn and manage virtual threads instead of native platform threads.

Next, we will discuss virtual threads in more detail.


One of the most significant additions to the Java language is the introduction of the new virtual thread model. This model allows developers to create extremely lightweight and fast threads, which are much less resource-intensive compared to the traditional operating system-level threads that have been the standard in Java up until now.

Virtual threads are managed directly by the Java Virtual Machine, or JVM. Instead of creating a dedicated platform thread for each task, the JVM creates internal threads that it schedules and manages itself. In this way, the JVM acts much like an operating system scheduler, but specifically for virtual threads.

Although virtual threads are ultimately executed on real platform threads provided by the operating system, the JVM has much more control over how these virtual threads are scheduled. This means that the JVM can run many virtual threads on a single platform thread, something that was not possible before. Each virtual thread is given a specific amount of execution time. If a virtual thread blocks for input or output, or if it takes too long, it can yield control to another virtual thread running on the same platform thread. The JVM distributes execution time among all virtual threads sharing a platform thread, scheduling them in a way similar to how an operating system schedules platform threads.

This approach allows the JVM to create far fewer platform threads, while supporting a much larger number of virtual threads running on top of them. In effect, this introduces a third level of threading in Java.

First, there is CPU multi-core threading, which is true hardware-level multi-threading.

Second, there is platform or operating system-level threading, where the operating system schedules tasks on each CPU core.

Third, there are Java virtual threads, where the Java Virtual Machine schedules tasks on top of the platform threads.

To illustrate how this works in practice, consider the following example. The familiar ExecutorService API can now be used to create thread pools that use virtual threads instead of platform threads. This is achieved by providing a different thread factory to the executor. Since the new virtual threading model is, from a user’s perspective, indistinguishable from platform threads, there is no friction in adopting virtual threads in existing code.

In the example, a fixed thread pool is created with four virtual threads using the Executors.newFixedThreadPool method, and a virtual thread factory is specified. Ten tasks are submitted to the pool. Each task prints a message indicating it is running in a virtual thread, then simulates some blocking work by sleeping for a short period. If a thread blocks, the JVM can yield control to other virtual threads, ensuring that all concurrent tasks are scheduled fairly. Finally, the executor is shut down, which ensures that all pending tasks are completed, but no new tasks are accepted.

Next, let’s discuss the Foreign Function and Memory, or FFM, interface.

With recent Java releases, there is a move to deprecate the old Java Native Interface, or JNI, and Remote Method Invocation, or RMI, in favor of a more modern approach: the Foreign Function and Memory interface. This is also known as FFI, or foreign function interface, in other languages. It allows Java programs to interact with functions implemented in other languages, primarily C and C plus plus.

For example, consider a C structure called Person, which contains an integer age and a character array for the name. There is also a function called print_person that prints the name and age of a Person. This C code is compiled into a shared library using the GCC compiler.

The Java application that interacts with this library uses the FFM API to define the memory layout of the Person struct, allocate memory for it, and set its fields. The memory layout in Java matches exactly the layout defined in the C API, and the memory is allocated on the heap. The address of the struct is then passed to the native print_person function.

It is important to note that Java does not manage dynamic structures when interacting with FFM. This means that dynamic structures, such as character arrays or strings, must be appropriately sized to avoid overflow issues, just as in plain C. While there are some safeguards, the FFM interface itself does not fully protect against such scenarios. Its main purpose is to provide a way to interact with external libraries written in other languages.

In summary, the FFM example demonstrates how to define a struct layout in Java, allocate and populate the struct, and call a native function from a shared library, all while managing memory manually to ensure compatibility with the external C code.


