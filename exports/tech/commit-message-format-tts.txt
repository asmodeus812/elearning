Commit Message Guidelines

This document brings together best practices from various sources to offer a practical guide for writing commit messages.

Why write good commit messages?

Clear and structured commit messages make it easier to browse a project's history. They also allow scripts to easily generate changelogs, and help developers ignore non-essential commits when needed.

Commit Message Format

A commit message is made up of three parts: a header, a body, and a footer. The header follows a specific format, which includes a type, an optional scope, and a subject. The general structure is: type, followed by an optional scope in parentheses, then a colon and the subject. After a blank line, you can add the body, and after another blank line, the footer.

The header is required, but the scope is optional. The footer should include a reference to any related issues, if applicable.

Many projects follow the fifty-seventy-two rule. This means the first line of the commit message, not counting the type and scope, should be no longer than fifty characters. The description lines should be no longer than seventy-two characters each.

Here are some general guidelines:

Make separate commits for logically distinct changes.

Describe your changes clearly.

Type

The type is defined by the project, but here are some common examples:

Build is used for changes that affect the build system or external dependencies, such as updates to gulp, broccoli, or npm.

CI is for changes to continuous integration configuration files and scripts, like those for Circle, BrowserStack, or SauceLabs.

Docs is for documentation-only changes.

Feat, or feature, is for new features.

License is for licensing compliance and changes.

Fix is for bug fixes.

Perf is for code changes that improve performance.

Refactor is for code changes that neither fix a bug nor add a feature.

Style is for changes that do not affect the meaning of the code, such as whitespace, formatting, or missing semicolons.

Test is for adding missing tests or correcting existing ones.

Revert is used when reverting a previous commit. The message should start with "revert," followed by the header of the commit being reverted. In the body, include the phrase, "This reverts commit," followed by the commit's hash.

Scope

If relevant, the scope should be the name of the package or area affected, as it would appear to someone reading a changelog generated from commit messages. Some example scopes include: common, compiler, compiler-cli, core, http, and router.

Subject

The subject is a brief description of the change. Use the imperative, present tense, such as "change" instead of "changed" or "changes." Imagine reading your commit message as, "This commit will..." Do not capitalize the first letter, and do not end with a period.

Body

Like the subject, the body should use the imperative, present tense. The body should explain the motivation for the change and contrast it with previous behavior.

Footer

The footer should include any information about breaking changes, and is also the place to reference issue numbers or identifiers that the commit closes.

For breaking changes, start with the words "BREAKING CHANGE," followed by a colon and a space, or two newlines. The rest of the message should describe the breaking change.

For referencing issues, list closed bugs on a separate line in the footer, prefixed with the word "Closes," followed by the issue number. For multiple issues, separate them with commas.

Generate a Changelog

When generating a changelog, use three sections: new features, bug fixes, and breaking changes. This list can be generated by a script during a release, along with links to related commits.

To list all subjects, or first lines in commit messages, since the last release, you can use a command that logs the commit messages between the last tag and the current head.

To list only new features in the current release, you can use a command that searches for commits with the "feat" type since the last release.

Ignore Non-Important Commits

You may want to ignore certain commits, such as formatting changes. For example, when using git bisect, you can skip these commits by running a command that skips all commits matching a certain pattern.

Examples

Here are some example commit messages:

A documentation update might be written as, "docs: update changelog to beta."

A bug fix for a pencil might be, "fix(pencil): stop graphite breaking when too much pressure applied."

A new feature could be, "feat(pencil): add graphiteWidth option."

A performance improvement that removes an option might look like this: "perf(pencil): remove graphiteWidth option." In the footer, you would add, "BREAKING CHANGE: The graphiteWidth option has been removed. The default graphite width of ten millimeters is always used for performance reasons." Note that the "BREAKING CHANGE" token must be in the footer of the commit.

Another example for adding new directives might be, "feat(directive): add directives disabled, checked, multiple, readonly." The body would explain that new directives have been added for proper binding of these attributes in older browsers, along with corresponding descriptions, live examples, and end-to-end tests. The footer would include, "Closes number three hundred fifty-one."

A more complex example for simplifying isolate scope bindings might be, "feat(compile): simplify isolate scope bindings." The body would explain that the isolate scope binding options have changed, listing the new options and describing the simplification. The footer would include, "BREAKING CHANGE: isolate scope bindings definition has changed and the inject option for the directive controller injection was removed." It would also provide migration instructions, showing the before and after code structure, and note that the removed inject option was not generally useful.

Pull Requests

To resolve conflicts, rebase pull request branches onto their target branch instead of merging the target branch into the pull request branch. This results in a cleaner history without criss-cross merges.

When addressing review comments in a pull request, fix the issue in the commit where it appears, rather than adding a new commit on top of the pull request's history. This may require force-pushing the updated branch, but it has several advantages.

First, reviewers who go through larger pull requests commit by commit will always see the latest fixes, instead of finding a commit that addresses their remarks only at the end.

Second, it maintains a cleaner history without distracting commits like "Address review comments."

As a result, tools like git bisect can operate more meaningfully.

Fixing up commits also allows you to make changes to commit messages, which is not possible if you only add new commits.

If you are unfamiliar with fixing up existing commits, read about rewriting history and using git rebase in interactive mode.


