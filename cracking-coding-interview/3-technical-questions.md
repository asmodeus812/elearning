# Important topics

For each of the topics below make sure you understand how to use and implement
them, on paper and then on a computer.

## Structures
1. Linked lists
2. Trees, Tires and Graphs
3. Stacks & Queues
4. Heaps
5. Vectors / Arrays
6. Hash tables

## Algorithms
1. Breadth-First Search
2. Depth-First Search
3. Binary Search
4. Merge Sort
5. Quick Sort
6. Other Sorting algorithms

## Concepts

1. Bit manipulation
2. Memory (Stack & Heap)
3. Recursion
4. Dynamic programming
5. Big O time & space

# Solving process

Make sure to understand the problem , ask for paper and pen and record the
problem on it, write it down, do not try to memorize it otherwise you will miss
important details. Ask for example, draw and write down it too.

When drawing an example make it as specific to the problem as possible, use the
data you have been given, or make up one yourself, but try to make the example
about the problem, do not draw generic trees, stacks etc. Make it large so you
can see patterns, edge cases etc.

Try to trade off space or time for the other e.g. - store data (hash-table,
vector, list, stack, tree etc.), sort data (mutate the input example, by sorting
it to fit in the problem's solution).

Sometimes it might be useful to write down an implementation that solves the
issue incorrectly, or not completely.

1. Listen - pay very close attention to any information, in the problem
   description, ask for more details, as much as you can think of to narrow down
   the problem at hand, try to make no assumptions about the problem.
2. Example - ask for example, more than one if you have to, be aggressive with
   the questions, to allow for no foul play
3. Brute force - try to solve the problem in the most naive obvious way, that
   comes to mind
4. Optimize - try to apply different approaches to the problem solution
   afterwards, such as dynamiting programming or memorization etc - avoid
   bottlenecks, unnecessary work or duplicated work
5. Walk through - analyze the problem, try to describe it, make sure it makes
   sense, if not, go back to the example and start over, from step 2
6. Implement - make sure whatever you implement is well structured, now that it
7. Test - go through your code and test it, if you have to do any changes to
   adjust the logic go back to step 3

Important to note that, one might be better off trying to approximate or try to
solve the issue as a real world example, instead of 

